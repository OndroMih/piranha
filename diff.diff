diff --git a/MIGRATION.md b/MIGRATION.md
deleted file mode 100644
index 32e2ab1f..00000000
--- a/MIGRATION.md
+++ /dev/null
@@ -1,14 +0,0 @@
-# Migration
-
-The Piranha codebase is migrating towards Jakarta EE 9 and as such some projects
-that are used might or might not be up to speed yet. This document tracks what
-projects are not up to speed and where it impacts the Piranha codebase.
-
-## Piranha Nano
-
-1. Tests usings Apache Wicket have been disabled.
-
-## Piranha Upload - Apache FileUpload
-
-1. Project has been commented out until either a) project catches up or b) the
-Apache source code can be changed on the fly and compiled into this module.
diff --git a/bom/pom.xml b/bom/pom.xml
index 2eb20551..26d49d47 100644
--- a/bom/pom.xml
+++ b/bom/pom.xml
@@ -197,12 +197,12 @@
             <dependency>
                 <groupId>jakarta.el</groupId>
                 <artifactId>jakarta.el-api</artifactId>
-                <version>4.0.0</version>
+                <version>3.0.3</version>
             </dependency>
             <dependency>
                 <groupId>org.glassfish</groupId>
                 <artifactId>jakarta.el</artifactId>
-                <version>4.0.0</version>
+                <version>3.0.3</version>
             </dependency>
             
             <!-- Jakarta Faces -->
@@ -316,12 +316,12 @@
             <dependency>
                 <groupId>jakarta.servlet.jsp</groupId>
                 <artifactId>jakarta.servlet.jsp-api</artifactId>
-                <version>3.0.0-M1</version>
+                <version>2.3.6</version>
             </dependency>
             <dependency>
                 <groupId>org.glassfish.web</groupId>
                 <artifactId>jakarta.servlet.jsp</artifactId>
-                <version>3.0.0-RC1</version>
+                <version>2.3.6</version>
             </dependency>
 
             <!-- Jakarta Servlet -->
diff --git a/cdi/openwebbeans/src/main/java/cloud/piranha/cdi/openwebbeans/OpenWebBeansInitializer.java b/cdi/openwebbeans/src/main/java/cloud/piranha/cdi/openwebbeans/OpenWebBeansInitializer.java
index 35ce1e15..e2ef877e 100644
--- a/cdi/openwebbeans/src/main/java/cloud/piranha/cdi/openwebbeans/OpenWebBeansInitializer.java
+++ b/cdi/openwebbeans/src/main/java/cloud/piranha/cdi/openwebbeans/OpenWebBeansInitializer.java
@@ -29,9 +29,9 @@ package cloud.piranha.cdi.openwebbeans;
 
 import cloud.piranha.webapp.api.WebApplication;
 import java.util.Set;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 /**
  * The OpenWebBeans initializer.
diff --git a/cdi/openwebbeans/src/main/java/cloud/piranha/cdi/openwebbeans/OpenWebBeansObjectInstanceManager.java b/cdi/openwebbeans/src/main/java/cloud/piranha/cdi/openwebbeans/OpenWebBeansObjectInstanceManager.java
index a99a7c33..4cbc2f78 100644
--- a/cdi/openwebbeans/src/main/java/cloud/piranha/cdi/openwebbeans/OpenWebBeansObjectInstanceManager.java
+++ b/cdi/openwebbeans/src/main/java/cloud/piranha/cdi/openwebbeans/OpenWebBeansObjectInstanceManager.java
@@ -32,9 +32,9 @@ import java.util.EventListener;
 import javax.enterprise.inject.spi.BeanManager;
 import javax.enterprise.inject.spi.CDI;
 import javax.enterprise.inject.spi.Unmanaged;
-import jakarta.servlet.Filter;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
+import javax.servlet.Filter;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
 
 /**
  * The OpenWebBeans object instance manager.
diff --git a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/RealtimeHttpServletRequestWrapper.java b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/RealtimeHttpServletRequestWrapper.java
index 0acbc949..a2a6a7b2 100644
--- a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/RealtimeHttpServletRequestWrapper.java
+++ b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/RealtimeHttpServletRequestWrapper.java
@@ -36,20 +36,20 @@ import java.util.Enumeration;
 import java.util.Locale;
 import java.util.Map;
 
-import jakarta.servlet.AsyncContext;
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletInputStream;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpUpgradeHandler;
-import jakarta.servlet.http.Part;
+import javax.servlet.AsyncContext;
+import javax.servlet.DispatcherType;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpUpgradeHandler;
+import javax.servlet.http.Part;
 
 /**
  * An HttpServletRequest wrapper that consistently consults the getWrapped() method for every operation.
diff --git a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldHttpServletRequest.java b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldHttpServletRequest.java
index 6307ef37..65d7f3b5 100644
--- a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldHttpServletRequest.java
+++ b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldHttpServletRequest.java
@@ -29,7 +29,7 @@ package cloud.piranha.cdi.weld;
 
 import static cloud.piranha.webapp.api.CurrentRequestHolder.CURRENT_REQUEST_ATTRIBUTE;
 
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequest;
 
 import cloud.piranha.webapp.impl.DefaultCurrentRequestHolder;
 import cloud.piranha.webapp.api.CurrentRequestHolder;
diff --git a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldInitListener.java b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldInitListener.java
index 5356fe09..99575818 100644
--- a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldInitListener.java
+++ b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldInitListener.java
@@ -27,9 +27,9 @@
  */
 package cloud.piranha.cdi.weld;
 
-import jakarta.servlet.ServletContextEvent;
-import jakarta.servlet.ServletRequestEvent;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletRequestEvent;
+import javax.servlet.http.HttpServletRequest;
 
 import org.jboss.weld.environment.servlet.Listener;
 import org.jboss.weld.servlet.api.ServletListener;
diff --git a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldInitializer.java b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldInitializer.java
index 1abfa448..04665d6d 100644
--- a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldInitializer.java
+++ b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldInitializer.java
@@ -29,10 +29,10 @@ package cloud.piranha.cdi.weld;
 
 import java.util.Set;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletContextEvent;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletException;
 
 import cloud.piranha.webapp.api.WebApplication;
 
diff --git a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldObjectInstanceManager.java b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldObjectInstanceManager.java
index a02a4fe5..8ed997e4 100644
--- a/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldObjectInstanceManager.java
+++ b/cdi/weld/src/main/java/cloud/piranha/cdi/weld/WeldObjectInstanceManager.java
@@ -32,9 +32,9 @@ import java.util.EventListener;
 import javax.enterprise.inject.spi.BeanManager;
 import javax.enterprise.inject.spi.CDI;
 import javax.enterprise.inject.spi.Unmanaged;
-import jakarta.servlet.Filter;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
+import javax.servlet.Filter;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
 
 /**
  * The Weld object instance manager.
diff --git a/embedded/pom.xml b/embedded/pom.xml
index 08df163c..58522b00 100644
--- a/embedded/pom.xml
+++ b/embedded/pom.xml
@@ -33,24 +33,22 @@
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
-         <dependency>
-            <groupId>cloud.piranha.naming</groupId>
-            <artifactId>piranha-naming-thread</artifactId>
+        <dependency>
+            <groupId>cloud.piranha.webapp</groupId>
+            <artifactId>piranha-webapp-impl</artifactId>
             <version>${project.version}</version>
-            <scope>compile</scope>
         </dependency>
         <dependency>
             <groupId>cloud.piranha.resource</groupId>
             <artifactId>piranha-resource</artifactId>
             <version>${project.version}</version>
-            <scope>compile</scope>
         </dependency>
-        <dependency>
-            <groupId>cloud.piranha.webapp</groupId>
-            <artifactId>piranha-webapp-impl</artifactId>
+         <dependency>
+            <groupId>cloud.piranha.naming</groupId>
+            <artifactId>piranha-naming-thread</artifactId>
             <version>${project.version}</version>
-            <scope>compile</scope>
         </dependency>
+        
         <dependency>
             <groupId>org.junit.jupiter</groupId>
             <artifactId>junit-jupiter-api</artifactId>
diff --git a/embedded/src/main/java/cloud/piranha/embedded/EmbeddedPiranha.java b/embedded/src/main/java/cloud/piranha/embedded/EmbeddedPiranha.java
index e53d3722..57031e50 100644
--- a/embedded/src/main/java/cloud/piranha/embedded/EmbeddedPiranha.java
+++ b/embedded/src/main/java/cloud/piranha/embedded/EmbeddedPiranha.java
@@ -32,9 +32,9 @@ import cloud.piranha.naming.thread.ThreadInitialContextFactory;
 import cloud.piranha.webapp.impl.DefaultWebApplication;
 import cloud.piranha.webapp.api.WebApplication;
 import java.io.IOException;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 /**
  * The embeddable servlet container version of Piranha.
diff --git a/embedded/src/main/java/cloud/piranha/embedded/EmbeddedPiranhaBuilder.java b/embedded/src/main/java/cloud/piranha/embedded/EmbeddedPiranhaBuilder.java
index 85d6d292..d504ab9b 100644
--- a/embedded/src/main/java/cloud/piranha/embedded/EmbeddedPiranhaBuilder.java
+++ b/embedded/src/main/java/cloud/piranha/embedded/EmbeddedPiranhaBuilder.java
@@ -43,8 +43,8 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import static javax.naming.Context.INITIAL_CONTEXT_FACTORY;
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.ServletRegistration;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletRegistration;
 
 
 /**
diff --git a/embedded/src/main/java/cloud/piranha/embedded/EmbeddedRequestBuilder.java b/embedded/src/main/java/cloud/piranha/embedded/EmbeddedRequestBuilder.java
index b31366dd..7edf3f06 100644
--- a/embedded/src/main/java/cloud/piranha/embedded/EmbeddedRequestBuilder.java
+++ b/embedded/src/main/java/cloud/piranha/embedded/EmbeddedRequestBuilder.java
@@ -27,7 +27,7 @@
  */
 package cloud.piranha.embedded;
 
-import jakarta.servlet.http.Cookie;
+import javax.servlet.http.Cookie;
 
 import cloud.piranha.webapp.api.WebApplication;
 
diff --git a/embedded/src/main/java/module-info.java b/embedded/src/main/java/module-info.java
index 5e2cb48e..c61860c1 100644
--- a/embedded/src/main/java/module-info.java
+++ b/embedded/src/main/java/module-info.java
@@ -34,15 +34,13 @@
 module cloud.piranha.embedded {
     
     exports cloud.piranha.embedded;
-    
     opens cloud.piranha.embedded;
-    
     requires cloud.piranha.api;
     requires cloud.piranha.naming.api;
     requires cloud.piranha.naming.thread;
     requires cloud.piranha.resource.api;
     requires cloud.piranha.resource;
-    requires cloud.piranha.servlet.api;
+    requires cloud.piranha.servlet4.api;
     requires cloud.piranha.webapp.impl;
     requires cloud.piranha.webapp.api;
     requires java.naming;
diff --git a/embedded/src/test/java/cloud/piranha/embedded/EmbeddedPiranhaTest.java b/embedded/src/test/java/cloud/piranha/embedded/EmbeddedPiranhaTest.java
index efa3a62c..0da4dfd1 100644
--- a/embedded/src/test/java/cloud/piranha/embedded/EmbeddedPiranhaTest.java
+++ b/embedded/src/test/java/cloud/piranha/embedded/EmbeddedPiranhaTest.java
@@ -31,9 +31,9 @@ import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 import java.util.Set;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import org.junit.jupiter.api.Test;
 
diff --git a/extension/micro-core/src/main/java/cloud/piranha/micro/core/MicroInnerApplication.java b/extension/micro-core/src/main/java/cloud/piranha/micro/core/MicroInnerApplication.java
index 0819bc2a..1178eaa5 100644
--- a/extension/micro-core/src/main/java/cloud/piranha/micro/core/MicroInnerApplication.java
+++ b/extension/micro-core/src/main/java/cloud/piranha/micro/core/MicroInnerApplication.java
@@ -38,8 +38,8 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.function.Consumer;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Cookie;
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
 
 /**
  * The inner Piranha Micro application.
diff --git a/extension/micro-core/src/main/java/cloud/piranha/micro/core/MicroInnerDeployer.java b/extension/micro-core/src/main/java/cloud/piranha/micro/core/MicroInnerDeployer.java
index deee6966..7a5e78ac 100644
--- a/extension/micro-core/src/main/java/cloud/piranha/micro/core/MicroInnerDeployer.java
+++ b/extension/micro-core/src/main/java/cloud/piranha/micro/core/MicroInnerDeployer.java
@@ -59,12 +59,12 @@ import javax.annotation.security.DenyAll;
 import javax.annotation.security.PermitAll;
 import javax.annotation.security.RolesAllowed;
 import javax.annotation.security.RunAs;
-import jakarta.servlet.annotation.MultipartConfig;
-import jakarta.servlet.annotation.ServletSecurity;
-import jakarta.servlet.annotation.WebFilter;
-import jakarta.servlet.annotation.WebInitParam;
-import jakarta.servlet.annotation.WebListener;
-import jakarta.servlet.annotation.WebServlet;
+import javax.servlet.annotation.MultipartConfig;
+import javax.servlet.annotation.ServletSecurity;
+import javax.servlet.annotation.WebFilter;
+import javax.servlet.annotation.WebInitParam;
+import javax.servlet.annotation.WebListener;
+import javax.servlet.annotation.WebServlet;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.xpath.XPath;
diff --git a/faces/mojarra/src/main/java/cloud/piranha/faces/mojarra/MojarraInitializer.java b/faces/mojarra/src/main/java/cloud/piranha/faces/mojarra/MojarraInitializer.java
index 7438191e..d14a50b5 100644
--- a/faces/mojarra/src/main/java/cloud/piranha/faces/mojarra/MojarraInitializer.java
+++ b/faces/mojarra/src/main/java/cloud/piranha/faces/mojarra/MojarraInitializer.java
@@ -31,10 +31,10 @@ import static java.lang.Boolean.TRUE;
 
 import java.util.Set;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRegistration.Dynamic;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration.Dynamic;
 
 /**
  * The Mojarra initializer.
diff --git a/faces/myfaces/src/main/java/cloud/piranha/faces/myfaces/MyFacesInitializer.java b/faces/myfaces/src/main/java/cloud/piranha/faces/myfaces/MyFacesInitializer.java
index 5c502d38..5cea391a 100644
--- a/faces/myfaces/src/main/java/cloud/piranha/faces/myfaces/MyFacesInitializer.java
+++ b/faces/myfaces/src/main/java/cloud/piranha/faces/myfaces/MyFacesInitializer.java
@@ -28,10 +28,10 @@
 package cloud.piranha.faces.myfaces;
 
 import java.util.Set;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRegistration.Dynamic;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration.Dynamic;
 
 /**
  * The MyFaces initializer.
diff --git a/http/nano/src/main/java/cloud/piranha/http/nano/NanoHttpServerProcessor.java b/http/nano/src/main/java/cloud/piranha/http/nano/NanoHttpServerProcessor.java
index b66e90f7..0dba3221 100644
--- a/http/nano/src/main/java/cloud/piranha/http/nano/NanoHttpServerProcessor.java
+++ b/http/nano/src/main/java/cloud/piranha/http/nano/NanoHttpServerProcessor.java
@@ -34,7 +34,7 @@ import cloud.piranha.http.webapp.HttpWebApplicationRequest;
 import cloud.piranha.http.webapp.HttpWebApplicationResponse;
 import cloud.piranha.nano.NanoPiranha;
 import java.io.IOException;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletException;
 
 /**
  * The Piranha Nano HttpServerProcessor.
diff --git a/http/webapp/src/main/java/cloud/piranha/http/webapp/HttpWebApplicationServer.java b/http/webapp/src/main/java/cloud/piranha/http/webapp/HttpWebApplicationServer.java
index a9262184..bc41c536 100644
--- a/http/webapp/src/main/java/cloud/piranha/http/webapp/HttpWebApplicationServer.java
+++ b/http/webapp/src/main/java/cloud/piranha/http/webapp/HttpWebApplicationServer.java
@@ -37,8 +37,8 @@ import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Cookie;
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
 
 import cloud.piranha.webapp.api.WebApplicationServer;
 import cloud.piranha.webapp.api.WebApplicationServerRequestMapper;
diff --git a/http/webapp/src/main/java/module-info.java b/http/webapp/src/main/java/module-info.java
index e7390101..60c18319 100644
--- a/http/webapp/src/main/java/module-info.java
+++ b/http/webapp/src/main/java/module-info.java
@@ -37,12 +37,8 @@
  * @author Manfred Riem (mriem@manorrock.com)
  */
 module cloud.piranha.http.webapp {
-    
     exports cloud.piranha.http.webapp;
-    
     requires cloud.piranha.http.api;
-    requires cloud.piranha.servlet.api;
-    requires cloud.piranha.webapp.api;
     requires cloud.piranha.webapp.impl;
     requires java.logging;
 }
diff --git a/http/webapp/src/test/java/cloud/piranha/http/webapp/tests/HttpWebApplicationServerTest.java b/http/webapp/src/test/java/cloud/piranha/http/webapp/HttpWebApplicationServerTest.java
similarity index 96%
rename from http/webapp/src/test/java/cloud/piranha/http/webapp/tests/HttpWebApplicationServerTest.java
rename to http/webapp/src/test/java/cloud/piranha/http/webapp/HttpWebApplicationServerTest.java
index c628b086..cbcd6b38 100644
--- a/http/webapp/src/test/java/cloud/piranha/http/webapp/tests/HttpWebApplicationServerTest.java
+++ b/http/webapp/src/test/java/cloud/piranha/http/webapp/HttpWebApplicationServerTest.java
@@ -25,13 +25,11 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.http.webapp.tests;
+package cloud.piranha.http.webapp;
 
 import cloud.piranha.webapp.impl.DefaultWebApplication;
 import cloud.piranha.http.impl.DefaultHttpServer;
 import cloud.piranha.http.api.HttpServer;
-import cloud.piranha.http.webapp.HttpWebApplicationServer;
-import cloud.piranha.http.webapp.HttpWebApplicationServerRequestMapper;
 import java.io.IOException;
 import java.net.URI;
 import java.net.http.HttpClient;
diff --git a/http/webapp/src/test/java/cloud/piranha/http/webapp/tests/TestSnoopServlet.java b/http/webapp/src/test/java/cloud/piranha/http/webapp/TestSnoopServlet.java
similarity index 97%
rename from http/webapp/src/test/java/cloud/piranha/http/webapp/tests/TestSnoopServlet.java
rename to http/webapp/src/test/java/cloud/piranha/http/webapp/TestSnoopServlet.java
index 20d00436..2eb166e2 100644
--- a/http/webapp/src/test/java/cloud/piranha/http/webapp/tests/TestSnoopServlet.java
+++ b/http/webapp/src/test/java/cloud/piranha/http/webapp/TestSnoopServlet.java
@@ -25,18 +25,18 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.http.webapp.tests;
+package cloud.piranha.http.webapp;
 
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Enumeration;
 import java.util.Locale;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A test Snoop Servlet.
diff --git a/http/webapp/src/test/java/module-info.java b/http/webapp/src/test/java/module-info.java
index 917f2430..f199218b 100644
--- a/http/webapp/src/test/java/module-info.java
+++ b/http/webapp/src/test/java/module-info.java
@@ -26,17 +26,11 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-module cloud.piranha.http.webapp.tests {
-    
-    exports cloud.piranha.http.webapp.tests;
-    
-    opens cloud.piranha.http.webapp.tests;
-    
+module cloud.piranha.http.webapp {
+    exports cloud.piranha.http.webapp;
+    opens cloud.piranha.http.webapp;
     requires cloud.piranha.http.api;
     requires cloud.piranha.http.impl;
-    requires cloud.piranha.http.webapp;
-    requires cloud.piranha.servlet.api;
-    requires cloud.piranha.webapp.api;
     requires cloud.piranha.webapp.impl;
     requires java.net.http;
     requires java.logging;
diff --git a/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeHealthServlet.java b/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeHealthServlet.java
index 17b91309..28314fac 100644
--- a/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeHealthServlet.java
+++ b/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeHealthServlet.java
@@ -31,10 +31,10 @@ import io.smallrye.health.SmallRyeHealth;
 import io.smallrye.health.SmallRyeHealthReporter;
 import java.io.IOException;
 import javax.inject.Inject;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * The Smallrye Health Servlet.
diff --git a/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeLivenessServlet.java b/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeLivenessServlet.java
index e1905a3c..ad640813 100644
--- a/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeLivenessServlet.java
+++ b/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeLivenessServlet.java
@@ -31,10 +31,10 @@ import io.smallrye.health.SmallRyeHealth;
 import io.smallrye.health.SmallRyeHealthReporter;
 import java.io.IOException;
 import javax.inject.Inject;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * The Smallrye Liveness Servlet.
diff --git a/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeReadinessServlet.java b/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeReadinessServlet.java
index bf533e7c..15b855b4 100644
--- a/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeReadinessServlet.java
+++ b/microprofile/smallrye/health/src/main/java/cloud/piranha/microprofile/smallrye/health/SmallRyeReadinessServlet.java
@@ -32,10 +32,10 @@ import io.smallrye.health.SmallRyeHealthReporter;
 import java.io.IOException;
 
 import javax.inject.Inject;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * The Smallrye Readiness Servlet.
diff --git a/monitor/jmx/src/main/java/cloud/piranha/monitor/jmx/JMXServerInitializer.java b/monitor/jmx/src/main/java/cloud/piranha/monitor/jmx/JMXServerInitializer.java
index 6740f593..5d32e29b 100644
--- a/monitor/jmx/src/main/java/cloud/piranha/monitor/jmx/JMXServerInitializer.java
+++ b/monitor/jmx/src/main/java/cloud/piranha/monitor/jmx/JMXServerInitializer.java
@@ -39,9 +39,9 @@ import javax.management.MBeanServer;
 import javax.management.MalformedObjectNameException;
 import javax.management.NotCompliantMBeanException;
 import javax.management.ObjectName;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 /**
  * Bootstraps the JMX server.
diff --git a/monitor/jmx/src/main/java/module-info.java b/monitor/jmx/src/main/java/module-info.java
index 98404c1b..df0e978e 100644
--- a/monitor/jmx/src/main/java/module-info.java
+++ b/monitor/jmx/src/main/java/module-info.java
@@ -28,7 +28,7 @@
 
 import cloud.piranha.monitor.jmx.JMXServerInitializer;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 module cloud.piranha.monitor.jmx {
     requires cloud.piranha.api;
diff --git a/nano/src/main/java/cloud/piranha/nano/NanoFilterChain.java b/nano/src/main/java/cloud/piranha/nano/NanoFilterChain.java
index 9715e236..3d352593 100644
--- a/nano/src/main/java/cloud/piranha/nano/NanoFilterChain.java
+++ b/nano/src/main/java/cloud/piranha/nano/NanoFilterChain.java
@@ -28,12 +28,12 @@
 package cloud.piranha.nano;
 
 import java.io.IOException;
-import jakarta.servlet.Filter;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 /**
  * The FilterChain class used by {@link cloud.piranha.nano.NanoPiranha} for
diff --git a/nano/src/main/java/cloud/piranha/nano/NanoFilterConfig.java b/nano/src/main/java/cloud/piranha/nano/NanoFilterConfig.java
index f08dab98..4856978f 100644
--- a/nano/src/main/java/cloud/piranha/nano/NanoFilterConfig.java
+++ b/nano/src/main/java/cloud/piranha/nano/NanoFilterConfig.java
@@ -31,8 +31,8 @@ import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.UUID;
-import jakarta.servlet.FilterConfig;
-import jakarta.servlet.ServletContext;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletContext;
 
 /**
  * The FilterConfig class used by {@link cloud.piranha.nano.NanoPiranhaBuilder}
diff --git a/nano/src/main/java/cloud/piranha/nano/NanoPiranha.java b/nano/src/main/java/cloud/piranha/nano/NanoPiranha.java
index 7903fe06..15573c79 100644
--- a/nano/src/main/java/cloud/piranha/nano/NanoPiranha.java
+++ b/nano/src/main/java/cloud/piranha/nano/NanoPiranha.java
@@ -34,11 +34,11 @@ import java.io.IOException;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
-import jakarta.servlet.Filter;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.Filter;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 /**
  * The smallest version of Piranha in our lineup.
diff --git a/nano/src/main/java/cloud/piranha/nano/NanoPiranhaBuilder.java b/nano/src/main/java/cloud/piranha/nano/NanoPiranhaBuilder.java
index 94bf4e9c..3e9c1bfe 100644
--- a/nano/src/main/java/cloud/piranha/nano/NanoPiranhaBuilder.java
+++ b/nano/src/main/java/cloud/piranha/nano/NanoPiranhaBuilder.java
@@ -36,9 +36,9 @@ import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import jakarta.servlet.Filter;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
+import javax.servlet.Filter;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
 
 /**
  * The builder so you can easily build instances of
diff --git a/nano/src/main/java/cloud/piranha/nano/NanoServletConfig.java b/nano/src/main/java/cloud/piranha/nano/NanoServletConfig.java
index 4b3ff18f..30c74a4a 100644
--- a/nano/src/main/java/cloud/piranha/nano/NanoServletConfig.java
+++ b/nano/src/main/java/cloud/piranha/nano/NanoServletConfig.java
@@ -30,8 +30,8 @@ package cloud.piranha.nano;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletContext;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletContext;
 
 /**
  * The ServletConfig class used by {@link cloud.piranha.nano.NanoPiranhaBuilder}
diff --git a/nano/src/main/java/module-info.java b/nano/src/main/java/module-info.java
index 1ffb51b6..a5ab6c0b 100644
--- a/nano/src/main/java/module-info.java
+++ b/nano/src/main/java/module-info.java
@@ -38,13 +38,11 @@
 module cloud.piranha.nano {
 
     exports cloud.piranha.nano;
-    
     opens cloud.piranha.nano;
-    
     requires cloud.piranha.api;
     requires cloud.piranha.resource.api;
     requires cloud.piranha.resource;
-    requires cloud.piranha.servlet.api;
+    requires cloud.piranha.servlet4.api;
     requires cloud.piranha.webapp.api;
     requires cloud.piranha.webapp.impl;
 }
diff --git a/nano/src/test/java/cloud/piranha/nano/NanoPiranhaTest.java b/nano/src/test/java/cloud/piranha/nano/NanoPiranhaTest.java
index 30b1d4eb..e8a39e59 100644
--- a/nano/src/test/java/cloud/piranha/nano/NanoPiranhaTest.java
+++ b/nano/src/test/java/cloud/piranha/nano/NanoPiranhaTest.java
@@ -32,16 +32,15 @@ import org.apache.jasper.servlet.JspServlet;
 import org.apache.wicket.protocol.http.WicketFilter;
 import org.junit.jupiter.api.Test;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
-import org.junit.jupiter.api.Disabled;
 
 /**
  * The JUnit tests for the NanoPiranha class.
@@ -196,9 +195,7 @@ class NanoPiranhaTest {
      * @throws Exception when a serious error occurs.
      */
     @Test
-    @Disabled
     void testService6() throws Exception {
-        /*
         NanoPiranha piranha = new NanoPiranhaBuilder()
                 .directoryResource("src/test/wicket")
                 .filter("WicketFilter", new WicketFilter())
@@ -218,7 +215,6 @@ class NanoPiranhaTest {
 
         piranha.service(request, response);
         assertTrue(outputStream.toString().contains("Hello Wicket"));
-        */
     }
 
     /**
@@ -227,9 +223,7 @@ class NanoPiranhaTest {
      * @throws Exception when a serious error occurs.
      */
     @Test
-    @Disabled
     void testService7() throws Exception {
-        /*
         NanoPiranha piranha = new NanoPiranhaBuilder()
                 .webApplication(new DefaultWebApplication())
                 .directoryResource("src/test/wicket")
@@ -250,7 +244,6 @@ class NanoPiranhaTest {
 
         piranha.service(request, response);
         assertTrue(outputStream.toString().contains("Hello Wicket"));
-        */
     }
 
     /**
diff --git a/nano/src/test/java/cloud/piranha/nano/NanoRequestTest.java b/nano/src/test/java/cloud/piranha/nano/NanoRequestTest.java
index 9bedd237..0a8bfaaa 100644
--- a/nano/src/test/java/cloud/piranha/nano/NanoRequestTest.java
+++ b/nano/src/test/java/cloud/piranha/nano/NanoRequestTest.java
@@ -34,9 +34,9 @@ import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpUpgradeHandler;
-import jakarta.servlet.http.WebConnection;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpUpgradeHandler;
+import javax.servlet.http.WebConnection;
 
 import org.junit.jupiter.api.Test;
 
diff --git a/nano/src/test/java/cloud/piranha/nano/NanoResponseTest.java b/nano/src/test/java/cloud/piranha/nano/NanoResponseTest.java
index 5e1cf28e..ce338215 100644
--- a/nano/src/test/java/cloud/piranha/nano/NanoResponseTest.java
+++ b/nano/src/test/java/cloud/piranha/nano/NanoResponseTest.java
@@ -29,7 +29,7 @@ package cloud.piranha.nano;
 
 import cloud.piranha.webapp.impl.DefaultWebApplication;
 import java.io.ByteArrayOutputStream;
-import jakarta.servlet.http.Cookie;
+import javax.servlet.http.Cookie;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
diff --git a/pages/jasper/pom.xml b/pages/jasper/pom.xml
index 8d05f2d3..b8c938a4 100644
--- a/pages/jasper/pom.xml
+++ b/pages/jasper/pom.xml
@@ -2,14 +2,18 @@
 
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
+
     <parent>
         <groupId>cloud.piranha.pages</groupId>
         <artifactId>project</artifactId>
         <version>21.1.0-SNAPSHOT</version>
     </parent>
+
     <artifactId>piranha-pages-jasper</artifactId>
     <packaging>jar</packaging>
+
     <name>Piranha Pages - Jasper Integration</name>
+
     <dependencies>
         <dependency>
             <groupId>org.glassfish.web</groupId>
@@ -17,22 +21,14 @@
             <scope>compile</scope>
             <exclusions>
                 <exclusion>
-                    <groupId>jakarta.el</groupId>
-                    <artifactId>jakarta.el-api</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>org.apache.ant</groupId>
-                    <artifactId>ant</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>eclipse</groupId>
-                    <artifactId>jdtcore</artifactId>
+                    <groupId>org.glassfish</groupId>
+                    <artifactId>javax.el</artifactId>
                 </exclusion>
             </exclusions>
         </dependency>
         <dependency>
-            <groupId>cloud.piranha.servlet</groupId>
-            <artifactId>piranha-servlet-api</artifactId>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
             <version>${project.version}</version>
             <scope>provided</scope>
         </dependency>
@@ -61,8 +57,8 @@
             <scope>test</scope>
         </dependency>
         <dependency>
-            <groupId>jakarta.el</groupId>
-            <artifactId>jakarta.el-api</artifactId>
+            <groupId>org.glassfish</groupId>
+            <artifactId>jakarta.el</artifactId>
             <scope>test</scope>
         </dependency>
         <dependency>
diff --git a/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperExtension.java b/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperExtension.java
index 3f8636ce..4b438f16 100644
--- a/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperExtension.java
+++ b/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperExtension.java
@@ -32,7 +32,7 @@ import static java.util.logging.Level.WARNING;
 import java.lang.reflect.InvocationTargetException;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.api.WebApplicationExtension;
diff --git a/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperInitializer.java b/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperInitializer.java
index e7355097..d6a8adb2 100644
--- a/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperInitializer.java
+++ b/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperInitializer.java
@@ -34,11 +34,11 @@ import java.io.File;
 import java.util.Set;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.jsp.JspFactory;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.jsp.JspFactory;
 
 import org.apache.jasper.runtime.JspFactoryImpl;
 
diff --git a/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperJspManager.java b/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperJspManager.java
index b776b359..fa135952 100644
--- a/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperJspManager.java
+++ b/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperJspManager.java
@@ -27,8 +27,8 @@
  */
 package cloud.piranha.pages.jasper;
 
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.descriptor.JspConfigDescriptor;
+import javax.servlet.ServletRegistration;
+import javax.servlet.descriptor.JspConfigDescriptor;
 
 import cloud.piranha.webapp.api.JspManager;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperServlet.java b/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperServlet.java
index 69acec82..c4a6ebc1 100644
--- a/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperServlet.java
+++ b/pages/jasper/src/main/java/cloud/piranha/pages/jasper/JasperServlet.java
@@ -31,9 +31,9 @@ import static org.apache.jasper.Constants.JSP_FILE;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.apache.jasper.servlet.JspServlet;
 
diff --git a/pages/jasper/src/main/java/module-info.java b/pages/jasper/src/main/java/module-info.java
index 1eb1f4f1..04a7e3d6 100644
--- a/pages/jasper/src/main/java/module-info.java
+++ b/pages/jasper/src/main/java/module-info.java
@@ -27,14 +27,14 @@
  */
 
 module cloud.piranha.pages.jasper {
-    
-    exports cloud.piranha.pages.jasper;
-
-    opens cloud.piranha.pages.jasper;
-
-    requires cloud.piranha.servlet.api;
+    requires cloud.piranha.servlet4.api;
     requires cloud.piranha.webapp.api;
+
     requires jakarta.servlet.jsp.api;
     requires jakarta.servlet.jsp;
+
     requires java.logging;
+
+    exports cloud.piranha.pages.jasper;
+    opens cloud.piranha.pages.jasper;
 }
diff --git a/pages/jasper/src/test/java/cloud/piranha/pages/jasper/tests/JasperInitializerTest.java b/pages/jasper/src/test/java/cloud/piranha/pages/jasper/JasperInitializerTest.java
similarity index 96%
rename from pages/jasper/src/test/java/cloud/piranha/pages/jasper/tests/JasperInitializerTest.java
rename to pages/jasper/src/test/java/cloud/piranha/pages/jasper/JasperInitializerTest.java
index 60ea047f..84453cd1 100644
--- a/pages/jasper/src/test/java/cloud/piranha/pages/jasper/tests/JasperInitializerTest.java
+++ b/pages/jasper/src/test/java/cloud/piranha/pages/jasper/JasperInitializerTest.java
@@ -25,9 +25,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.pages.jasper.tests;
+package cloud.piranha.pages.jasper;
 
-import cloud.piranha.pages.jasper.JasperInitializer;
 import cloud.piranha.webapp.impl.DefaultWebApplication;
 import cloud.piranha.resource.DirectoryResource;
 import org.junit.jupiter.api.Test;
diff --git a/pages/jasper/src/test/java/cloud/piranha/pages/jasper/tests/JspWriterTest.java b/pages/jasper/src/test/java/cloud/piranha/pages/jasper/JspWriterTest.java
similarity index 98%
rename from pages/jasper/src/test/java/cloud/piranha/pages/jasper/tests/JspWriterTest.java
rename to pages/jasper/src/test/java/cloud/piranha/pages/jasper/JspWriterTest.java
index 957e7b41..852f7f1e 100644
--- a/pages/jasper/src/test/java/cloud/piranha/pages/jasper/tests/JspWriterTest.java
+++ b/pages/jasper/src/test/java/cloud/piranha/pages/jasper/JspWriterTest.java
@@ -25,7 +25,7 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.pages.jasper.tests;
+package cloud.piranha.pages.jasper;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.embedded.EmbeddedPiranha;
@@ -33,7 +33,6 @@ import cloud.piranha.embedded.EmbeddedPiranhaBuilder;
 import cloud.piranha.embedded.EmbeddedRequest;
 import cloud.piranha.embedded.EmbeddedRequestBuilder;
 import cloud.piranha.embedded.EmbeddedResponse;
-import cloud.piranha.pages.jasper.JasperInitializer;
 import java.io.IOException;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
diff --git a/pom.xml b/pom.xml
index b9e3f36b..99e2b996 100644
--- a/pom.xml
+++ b/pom.xml
@@ -38,14 +38,11 @@
     </developers>
 
     <modules>
-        <module>api</module>
+        <!-- BOM -->
         <module>bom</module>
-        <module>embedded</module>
-        <module>naming</module>
-        <module>nano</module>
-        <module>pages</module>
-        <module>resource</module>
-        <module>server</module>
+        
+        <!-- Core -->
+        <module>api</module>
         <module>servlet</module>
         <module>webapp</module>
     
@@ -55,7 +52,10 @@
         <module>faces</module>
         <module>http</module>
         <module>monitor</module>
+        <module>naming</module>
         <module>session</module>
+        <module>resource</module>
+        <module>pages</module>
         <module>security</module>
         <module>transaction</module>
         <module>upload</module>
@@ -64,7 +64,10 @@
         <module>extension</module>
 
         <!-- Distributions -->
+        <module>nano</module>
+        <module>embedded</module>
         <module>micro</module>
+        <module>server</module>
         <module>server2</module>
         
         <!-- Arquillian -->
@@ -79,8 +82,10 @@
         <!-- MicroProfile -->
         <module>microprofile</module>
         
+        <!-- Applications -->
+        <module>war</module>
         <module>policy</module>
-	<module>war</module>
+        <module>servlet4</module>
     </modules>
 
     <scm>
diff --git a/security/eleos/src/main/java/cloud/piranha/security/eleos/AuthenticationFilter.java b/security/eleos/src/main/java/cloud/piranha/security/eleos/AuthenticationFilter.java
index 2f0db883..7b7b261e 100644
--- a/security/eleos/src/main/java/cloud/piranha/security/eleos/AuthenticationFilter.java
+++ b/security/eleos/src/main/java/cloud/piranha/security/eleos/AuthenticationFilter.java
@@ -28,18 +28,18 @@
 package cloud.piranha.security.eleos;
 
 import static cloud.piranha.webapp.api.SecurityManager.AuthenticateSource.PRE_REQUEST_CONTAINER;
-import static jakarta.servlet.http.HttpServletResponse.SC_FORBIDDEN;
+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;
 
 import java.io.IOException;
 
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.FilterConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.http.HttpFilter;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpFilter;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import cloud.piranha.webapp.api.FilterPriority;
 import cloud.piranha.webapp.api.SecurityManager;
diff --git a/security/eleos/src/main/java/cloud/piranha/security/eleos/AuthenticationInitializer.java b/security/eleos/src/main/java/cloud/piranha/security/eleos/AuthenticationInitializer.java
index d3ea52b5..867356b5 100644
--- a/security/eleos/src/main/java/cloud/piranha/security/eleos/AuthenticationInitializer.java
+++ b/security/eleos/src/main/java/cloud/piranha/security/eleos/AuthenticationInitializer.java
@@ -34,10 +34,10 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import org.omnifaces.eleos.config.factory.ConfigParser;
 import org.omnifaces.eleos.config.factory.DefaultConfigFactory;
diff --git a/security/eleos/src/main/java/cloud/piranha/security/eleos/DoNothingServerAuthModule.java b/security/eleos/src/main/java/cloud/piranha/security/eleos/DoNothingServerAuthModule.java
index 6b69e419..edea6c92 100644
--- a/security/eleos/src/main/java/cloud/piranha/security/eleos/DoNothingServerAuthModule.java
+++ b/security/eleos/src/main/java/cloud/piranha/security/eleos/DoNothingServerAuthModule.java
@@ -44,8 +44,8 @@ import javax.security.auth.message.MessageInfo;
 import javax.security.auth.message.MessagePolicy;
 import javax.security.auth.message.callback.CallerPrincipalCallback;
 import javax.security.auth.message.module.ServerAuthModule;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * Default SAM that does nothing
diff --git a/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationFilter.java b/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationFilter.java
index aeeda17f..e6abff36 100644
--- a/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationFilter.java
+++ b/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationFilter.java
@@ -27,18 +27,18 @@
  */
 package cloud.piranha.security.exousia;
 
-import static jakarta.servlet.http.HttpServletResponse.SC_FORBIDDEN;
+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;
 
 import java.io.IOException;
 
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.FilterConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.http.HttpFilter;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpFilter;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import cloud.piranha.webapp.api.FilterPriority;
 import cloud.piranha.webapp.api.SecurityManager;
diff --git a/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationInitializer.java b/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationInitializer.java
index 4314ecf9..db540264 100644
--- a/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationInitializer.java
+++ b/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationInitializer.java
@@ -29,10 +29,10 @@ package cloud.piranha.security.exousia;
 
 import java.util.Set;
 
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import cloud.piranha.webapp.api.WebApplication;
 
diff --git a/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationPreFilter.java b/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationPreFilter.java
index dc2a7cc5..cf77ad80 100644
--- a/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationPreFilter.java
+++ b/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationPreFilter.java
@@ -27,19 +27,19 @@
  */
 package cloud.piranha.security.exousia;
 
-import static jakarta.servlet.http.HttpServletResponse.SC_FORBIDDEN;
+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;
 
 import java.io.IOException;
 
 import javax.security.jacc.PolicyContext;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.FilterConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.http.HttpFilter;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpFilter;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import cloud.piranha.webapp.api.FilterPriority;
 import cloud.piranha.webapp.api.SecurityManager;
diff --git a/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationPreInitializer.java b/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationPreInitializer.java
index de1818ee..5b894933 100644
--- a/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationPreInitializer.java
+++ b/security/exousia/src/main/java/cloud/piranha/security/exousia/AuthorizationPreInitializer.java
@@ -40,10 +40,10 @@ import java.util.Set;
 
 import javax.security.jacc.PolicyConfiguration;
 import javax.security.jacc.PolicyContextException;
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import org.omnifaces.exousia.AuthorizationService;
 import org.omnifaces.exousia.constraints.SecurityConstraint;
diff --git a/security/exousia/src/main/java/cloud/piranha/security/exousia/PiranhaToExousiaConverter.java b/security/exousia/src/main/java/cloud/piranha/security/exousia/PiranhaToExousiaConverter.java
index d1f4fd25..555e5dec 100644
--- a/security/exousia/src/main/java/cloud/piranha/security/exousia/PiranhaToExousiaConverter.java
+++ b/security/exousia/src/main/java/cloud/piranha/security/exousia/PiranhaToExousiaConverter.java
@@ -28,8 +28,8 @@
 package cloud.piranha.security.exousia;
 
 import static java.util.Collections.emptyList;
-import static jakarta.servlet.annotation.ServletSecurity.TransportGuarantee.CONFIDENTIAL;
-import static jakarta.servlet.annotation.ServletSecurity.TransportGuarantee.NONE;
+import static javax.servlet.annotation.ServletSecurity.TransportGuarantee.CONFIDENTIAL;
+import static javax.servlet.annotation.ServletSecurity.TransportGuarantee.NONE;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -40,8 +40,8 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 
-import jakarta.servlet.ServletSecurityElement;
-import jakarta.servlet.annotation.ServletSecurity;
+import javax.servlet.ServletSecurityElement;
+import javax.servlet.annotation.ServletSecurity;
 
 import org.omnifaces.exousia.constraints.SecurityConstraint;
 import org.omnifaces.exousia.constraints.WebResourceCollection;
diff --git a/security/file/src/main/java/cloud/piranha/security/file/FileSecurityInitializer.java b/security/file/src/main/java/cloud/piranha/security/file/FileSecurityInitializer.java
index 15b360eb..858c0b3d 100644
--- a/security/file/src/main/java/cloud/piranha/security/file/FileSecurityInitializer.java
+++ b/security/file/src/main/java/cloud/piranha/security/file/FileSecurityInitializer.java
@@ -34,9 +34,9 @@ import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.Properties;
 import java.util.Set;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 /**
  * The ServletContainerInitializer that is used to bootstrap the
diff --git a/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityAllInitializer.java b/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityAllInitializer.java
index cfe2b0d0..ceadd022 100644
--- a/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityAllInitializer.java
+++ b/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityAllInitializer.java
@@ -32,9 +32,9 @@ import static cloud.piranha.security.exousia.AuthorizationPreInitializer.AUTHZ_P
 
 import java.util.Set;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import org.omnifaces.exousia.modules.def.DefaultPolicy;
 import org.omnifaces.exousia.modules.def.DefaultPolicyConfigurationFactory;
diff --git a/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityExtension.java b/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityExtension.java
index 3d861d34..df072462 100644
--- a/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityExtension.java
+++ b/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityExtension.java
@@ -31,7 +31,7 @@ import java.lang.reflect.InvocationTargetException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.api.WebApplicationExtension;
diff --git a/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityInitializer.java b/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityInitializer.java
index 741c50f3..010aabd8 100644
--- a/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityInitializer.java
+++ b/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityInitializer.java
@@ -29,9 +29,9 @@ package cloud.piranha.security.jakarta;
 
 import java.util.Set;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import cloud.piranha.webapp.api.WebApplication;
 
diff --git a/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityManager.java b/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityManager.java
index 6eae4ca4..47995b95 100644
--- a/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityManager.java
+++ b/security/jakarta/src/main/java/cloud/piranha/security/jakarta/JakartaSecurityManager.java
@@ -39,11 +39,11 @@ import java.util.Collection;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
 
 import org.omnifaces.eleos.config.helper.Caller;
 import org.omnifaces.eleos.services.DefaultAuthenticationService;
diff --git a/security/soteria/src/main/java/cloud/piranha/security/soteria/IdentityStoreLoginHandler.java b/security/soteria/src/main/java/cloud/piranha/security/soteria/IdentityStoreLoginHandler.java
index da4d28f6..f4703561 100644
--- a/security/soteria/src/main/java/cloud/piranha/security/soteria/IdentityStoreLoginHandler.java
+++ b/security/soteria/src/main/java/cloud/piranha/security/soteria/IdentityStoreLoginHandler.java
@@ -34,7 +34,7 @@ import javax.security.enterprise.credential.Password;
 import javax.security.enterprise.credential.UsernamePasswordCredential;
 import javax.security.enterprise.identitystore.CredentialValidationResult;
 import javax.security.enterprise.identitystore.IdentityStoreHandler;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequest;
 
 import cloud.piranha.webapp.impl.DefaultAuthenticatedIdentity;
 import cloud.piranha.webapp.api.AuthenticatedIdentity;
diff --git a/security/soteria/src/main/java/cloud/piranha/security/soteria/SoteriaInitializer.java b/security/soteria/src/main/java/cloud/piranha/security/soteria/SoteriaInitializer.java
index 1fed2c5e..be4c3e8e 100644
--- a/security/soteria/src/main/java/cloud/piranha/security/soteria/SoteriaInitializer.java
+++ b/security/soteria/src/main/java/cloud/piranha/security/soteria/SoteriaInitializer.java
@@ -30,9 +30,9 @@ package cloud.piranha.security.soteria;
 import java.util.Set;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import org.glassfish.soteria.servlet.SamRegistrationInstaller;
 
diff --git a/security/soteria/src/main/java/cloud/piranha/security/soteria/SoteriaPreCDIInitializer.java b/security/soteria/src/main/java/cloud/piranha/security/soteria/SoteriaPreCDIInitializer.java
index 68d9d770..0d3b8051 100644
--- a/security/soteria/src/main/java/cloud/piranha/security/soteria/SoteriaPreCDIInitializer.java
+++ b/security/soteria/src/main/java/cloud/piranha/security/soteria/SoteriaPreCDIInitializer.java
@@ -33,9 +33,9 @@ import cloud.piranha.webapp.impl.WebXmlManager;
 import java.util.Set;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 import org.glassfish.soteria.SoteriaServiceProviders;
 import org.glassfish.soteria.cdi.spi.WebXmlLoginConfig;
 
diff --git a/server2/src/main/java/cloud/piranha/server2/MicroWebApplication.java b/server2/src/main/java/cloud/piranha/server2/MicroWebApplication.java
index a54773fc..cb55db06 100644
--- a/server2/src/main/java/cloud/piranha/server2/MicroWebApplication.java
+++ b/server2/src/main/java/cloud/piranha/server2/MicroWebApplication.java
@@ -33,8 +33,8 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.function.Consumer;
 
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 import cloud.piranha.webapp.api.WebApplicationRequest;
 import cloud.piranha.webapp.api.WebApplicationResponse;
diff --git a/servlet/api/src/main/java/module-info.java b/servlet/api/src/main/java/module-info.java
index 66d9c93c..b4f0d371 100644
--- a/servlet/api/src/main/java/module-info.java
+++ b/servlet/api/src/main/java/module-info.java
@@ -26,13 +26,12 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-module cloud.piranha.servlet.api {
+module jakarta.servlet {
 
     exports jakarta.servlet;
     exports jakarta.servlet.annotation;
     exports jakarta.servlet.descriptor;
     exports jakarta.servlet.http;
-    
     opens jakarta.servlet;
     opens jakarta.servlet.annotation;
     opens jakarta.servlet.descriptor;
diff --git a/servlet4/annotationscan/pom.xml b/servlet4/annotationscan/pom.xml
new file mode 100644
index 00000000..6a8b7ab7
--- /dev/null
+++ b/servlet4/annotationscan/pom.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha.servlet4</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>piranha-servlet4-annotationscan</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Piranha Servlet 4 - Annotation Scan Integration</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>cloud.piranha.resource</groupId>
+            <artifactId>piranha-resource-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-impl</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/servlet4/annotationscan/src/main/java/cloud/piranha/servlet4/annotationscan/AnnotationScanExtension.java b/servlet4/annotationscan/src/main/java/cloud/piranha/servlet4/annotationscan/AnnotationScanExtension.java
new file mode 100644
index 00000000..f3fc32a0
--- /dev/null
+++ b/servlet4/annotationscan/src/main/java/cloud/piranha/servlet4/annotationscan/AnnotationScanExtension.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.annotationscan;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.servlet.ServletContainerInitializer;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationExtension;
+
+/**
+ * The extension that enables annotation scanning.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class AnnotationScanExtension implements WebApplicationExtension {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(AnnotationScanExtension.class.getName());
+
+    /**
+     * Configure the web application.
+     *
+     * @param webApplication the web application.
+     */
+    @Override
+    public void configure(WebApplication webApplication) {
+        try {
+            ClassLoader classLoader = webApplication.getClassLoader();
+            Class<? extends ServletContainerInitializer> clazz
+                    = classLoader
+                        .loadClass(AnnotationScanInitializer.class.getName())
+                        .asSubclass(ServletContainerInitializer.class);
+            ServletContainerInitializer initializer = clazz.getDeclaredConstructor().newInstance();
+            webApplication.addInitializer(initializer);
+        } catch (ClassNotFoundException | NoSuchMethodException | SecurityException
+                | InstantiationException | IllegalAccessException
+                | IllegalArgumentException | InvocationTargetException ex) {
+            LOGGER.log(Level.WARNING, "Unable to enable AnnotationScanExtension", ex);
+        }
+    }
+}
diff --git a/servlet4/annotationscan/src/main/java/cloud/piranha/servlet4/annotationscan/AnnotationScanInitializer.java b/servlet4/annotationscan/src/main/java/cloud/piranha/servlet4/annotationscan/AnnotationScanInitializer.java
new file mode 100644
index 00000000..1263b154
--- /dev/null
+++ b/servlet4/annotationscan/src/main/java/cloud/piranha/servlet4/annotationscan/AnnotationScanInitializer.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.annotationscan;
+
+import static java.util.Arrays.stream;
+
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import java.util.logging.Logger;
+import java.util.stream.Stream;
+
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.MultipartConfig;
+import javax.servlet.annotation.ServletSecurity;
+import javax.servlet.annotation.WebFilter;
+import javax.servlet.annotation.WebInitParam;
+import javax.servlet.annotation.WebListener;
+import javax.servlet.annotation.WebServlet;
+
+import cloud.piranha.resource.api.ResourceManagerClassLoader;
+import cloud.piranha.servlet4.webapp.AnnotationManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.impl.DefaultAnnotationManager;
+import cloud.piranha.servlet4.impl.DefaultAnnotationManager.DefaultAnnotationInfo;
+
+/**
+ * This ServletContainerInitializer deep scans for annotations and adds them to
+ * the DefaultAnnotationManager.
+ *
+ * @author Arjan Tijms
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class AnnotationScanInitializer implements ServletContainerInitializer {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(AnnotationScanInitializer.class.getName());
+
+    /**
+     * On startup.
+     *
+     * @param classes the classes.
+     * @param servletContext the servlet context.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
+        WebApplication webApp = (WebApplication) servletContext;
+
+        AnnotationManager annotationManager = webApp.getAnnotationManager();
+        if (annotationManager instanceof DefaultAnnotationManager == false) {
+            LOGGER.warning("DefaultAnnotationManager not installed. This scanner does not work");
+            return;
+        }
+
+        DefaultAnnotationManager defaultAnnotationManager = (DefaultAnnotationManager) annotationManager;
+
+        ClassLoader classLoader = webApp.getClassLoader();
+        if (classLoader instanceof ResourceManagerClassLoader == false) {
+            LOGGER.warning("ResourceManagerClassLoader not installed. This scanner does not work");
+            return;
+        }
+
+        ResourceManagerClassLoader resourceManagerClassLoader = (ResourceManagerClassLoader) classLoader;
+
+        resourceManagerClassLoader
+                .getResourceManager()
+                .getAllLocations()
+                .filter(e -> e.endsWith(".class"))
+                .map(e -> loadClass(classLoader, e))
+                .filter(this::hasWebAnnotation)
+                .forEach(targetClazz -> getWebAnnotations(targetClazz)
+                .forEach(annotationInstance
+                        -> defaultAnnotationManager.addAnnotation(
+                        new DefaultAnnotationInfo<>(annotationInstance, targetClazz))));
+    }
+
+    /**
+     * Load the class using the given class loader.
+     *
+     * @param classLoader the class loader.
+     * @param className the class name.
+     * @return the class.
+     */
+    public Class<?> loadClass(ClassLoader classLoader, String className) {
+        try {
+            return classLoader.loadClass(
+                    className.replaceAll("/", ".")
+                            .substring(1, className.length() - ".class".length()));
+        } catch (ClassNotFoundException e) {
+        }
+        return Object.class;
+    }
+
+    /**
+     * Get the web annotations for the given class.
+     *
+     * @param clazz the class.
+     * @return the stream of web annotations.
+     */
+    private Stream<Annotation> getWebAnnotations(Class<?> clazz) {
+        return stream(clazz.getAnnotations())
+                .filter(this::isWebAnnotation);
+    }
+
+    /**
+     * Does the given class have any web annotations.
+     *
+     * @param clazz the class.
+     * @return true if it does, false otherwise.
+     */
+    private boolean hasWebAnnotation(Class<?> clazz) {
+        return getWebAnnotations(clazz)
+                .findAny()
+                .isPresent();
+    }
+
+    /**
+     * Is this a web annotation.
+     *
+     * @param annotation the annotation.
+     * @return true if it is, false otherwise.
+     */
+    private boolean isWebAnnotation(Annotation annotation) {
+        return annotation instanceof WebServlet
+                || annotation instanceof WebListener
+                || annotation instanceof WebInitParam
+                || annotation instanceof WebFilter
+                || annotation instanceof ServletSecurity
+                || annotation instanceof MultipartConfig;
+    }
+}
diff --git a/servlet4/annotationscan/src/main/java/module-info.java b/servlet4/annotationscan/src/main/java/module-info.java
new file mode 100644
index 00000000..7bbaf4d0
--- /dev/null
+++ b/servlet4/annotationscan/src/main/java/module-info.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+module cloud.piranha.servlet4.annotationscan {
+    
+    exports cloud.piranha.servlet4.annotationscan;
+    requires cloud.piranha.resource.api;
+    requires cloud.piranha.servlet4.api;
+    requires cloud.piranha.servlet4.impl;
+    requires cloud.piranha.servlet4.webapp;
+    requires java.logging;
+}
diff --git a/servlet4/api/pom.xml b/servlet4/api/pom.xml
new file mode 100644
index 00000000..b9f21eb7
--- /dev/null
+++ b/servlet4/api/pom.xml
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha.servlet4</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>piranha-servlet4-api</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Piranha Servlet 4 - Servlet API</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>default-compile</id>
+                        <goals>
+                            <goal>compile</goal>
+                        </goals>
+                        <configuration>
+                            <includes>
+                                <includes>module-info.java</includes>
+                            </includes>
+                            <release>15</release>
+                        </configuration>
+                    </execution>
+                    <execution>
+                        <id>jdk8</id>
+                        <goals>
+                            <goal>compile</goal>
+                        </goals>
+                        <configuration>
+                            <excludes>
+                                <exclude>module-info.java</exclude>
+                            </excludes>
+                            <source>1.8</source>
+                            <target>1.8</target>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>clirr-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>install</id>
+                        <phase>install</phase>
+                        <goals>
+                            <goal>check</goal>
+                        </goals>
+                    </execution>
+                </executions>
+                <configuration>
+                    <includes>
+                        <include>javax/**</include>
+                    </includes>
+                    <comparisonArtifacts>
+                        <comparisonArtifact>
+                            <groupId>jakarta.servlet</groupId>
+                            <artifactId>jakarta.servlet-api</artifactId>
+                            <version>4.0.3</version>
+                        </comparisonArtifact>
+                    </comparisonArtifacts>
+                    <failOnError>true</failOnError>
+                    <logResults>true</logResults>
+                    <textOutputFile>${project.build.directory}/clirr.txt</textOutputFile>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+</project>
diff --git a/servlet4/api/src/main/java/javax/servlet/AsyncContext.java b/servlet4/api/src/main/java/javax/servlet/AsyncContext.java
new file mode 100644
index 00000000..ab1bb930
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/AsyncContext.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The AsyncContext API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface AsyncContext {
+
+    /**
+     * Defines the ASYNC_CONTEXT_PATH constant.
+     */
+    static final String ASYNC_CONTEXT_PATH = "javax.servlet.async.context_path";
+    
+    /**
+     * Defines the ASYNC_MAPPING constant.
+     */
+    static final String ASYNC_MAPPING = "javax.servlet.async.mapping";
+
+    /**
+     * Defines the ASYNC_PATH_INFO constant.
+     */
+    static final String ASYNC_PATH_INFO = "javax.servlet.async.path_info";
+
+    /**
+     * Defines the ASYNC_QUERY_STRING constant.
+     */
+    static final String ASYNC_QUERY_STRING = "javax.servlet.async.query_string";
+
+    /**
+     * Defines the ASYNC_REQUEST_URI constant.
+     */
+    static final String ASYNC_REQUEST_URI = "javax.servlet.async.request_uri";
+
+    /**
+     * Define the ASYNC_SERVLET_PATH constant.
+     */
+    static final String ASYNC_SERVLET_PATH = "javax.servlet.async.servlet_path";
+
+    /**
+     * Add the async listener.
+     *
+     * @param listener the async listener.
+     */
+    public void addListener(AsyncListener listener);
+
+    /**
+     * Add the async listener.
+     *
+     * @param listener the async listener.
+     * @param servletRequest the servlet request.
+     * @param servletResponse the servlet response.
+     */
+    public void addListener(AsyncListener listener, ServletRequest servletRequest, ServletResponse servletResponse);
+
+    /**
+     * Complete the request.
+     */
+    public void complete();
+
+    /**
+     * Create the listener.
+     *
+     * @param <T> the listener type.
+     * @param clazz the class.
+     * @return the listener.
+     * @throws ServletException when a serv
+     */
+    public <T extends AsyncListener> T createListener(Class<T> clazz) throws ServletException;
+
+    /**
+     * Dispatch the request.
+     */
+    public void dispatch();
+
+    /**
+     * Dispatch the request.
+     *
+     * @param context the servlet context.
+     * @param path the path.
+     */
+    public void dispatch(ServletContext context, String path);
+
+    /**
+     * Dispatch the request.
+     *
+     * @param path the path.
+     */
+    public void dispatch(String path);
+
+    /**
+     * Get the request.
+     *
+     * @return the request.
+     */
+    public ServletRequest getRequest();
+
+    /**
+     * Get the response.
+     *
+     * @return the response.
+     */
+    public ServletResponse getResponse();
+
+    /**
+     * Get the timeout.
+     *
+     * @return the timeout.
+     */
+    public long getTimeout();
+
+    /**
+     * Has the original request and response.
+     *
+     * @return true if it does, false otherwise.
+     */
+    public boolean hasOriginalRequestAndResponse();
+
+    /**
+     * Set the timeout.
+     *
+     * @param timeout the timeout.
+     */
+    public void setTimeout(long timeout);
+
+    /**
+     * Start the thread.
+     *
+     * @param runnable the runnable.
+     */
+    public void start(Runnable runnable);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/AsyncEvent.java b/servlet4/api/src/main/java/javax/servlet/AsyncEvent.java
new file mode 100644
index 00000000..a4e0eafe
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/AsyncEvent.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The AsyncEvent API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class AsyncEvent {
+
+    /**
+     * Stores the async context.
+     */
+    private AsyncContext context;
+
+    /**
+     * Stores the request.
+     */
+    private ServletRequest suppliedRequest;
+
+    /**
+     * Stores the response.
+     */
+    private ServletResponse suppliedResponse;
+
+    /**
+     * Stores the throwable.
+     */
+    private Throwable throwable;
+
+    /**
+     * Constructor.
+     *
+     * @param context the async context.
+     */
+    public AsyncEvent(AsyncContext context) {
+        this(context, context.getRequest(), context.getResponse(), null);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param context the async context.
+     * @param suppliedRequest the request.
+     * @param suppliedResponse the response.
+     */
+    public AsyncEvent(AsyncContext context, ServletRequest suppliedRequest, ServletResponse suppliedResponse) {
+        this(context, suppliedRequest, suppliedResponse, null);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param context the async context.
+     * @param throwable the throwable.
+     */
+    public AsyncEvent(AsyncContext context, Throwable throwable) {
+        this(context, context.getRequest(), context.getResponse(), throwable);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param context the context.
+     * @param suppliedRequest the request.
+     * @param suppliedResponse the response.
+     * @param throwable the throwable.
+     */
+    public AsyncEvent(AsyncContext context, ServletRequest suppliedRequest, ServletResponse suppliedResponse, Throwable throwable) {
+        this.context = context;
+        this.suppliedRequest = suppliedRequest;
+        this.suppliedResponse = suppliedResponse;
+        this.throwable = throwable;
+    }
+
+    /**
+     * Get the async context.
+     *
+     * @return the async context.
+     */
+    public AsyncContext getAsyncContext() {
+        return context;
+    }
+
+    /**
+     * Get the supplied request.
+     *
+     * @return the supplied request.
+     */
+    public ServletRequest getSuppliedRequest() {
+        return suppliedRequest;
+    }
+
+    /**
+     * Get the supplied response.
+     *
+     * @return the supplied response.
+     */
+    public ServletResponse getSuppliedResponse() {
+        return suppliedResponse;
+    }
+
+    /**
+     * Get the throwable.
+     *
+     * @return the throwable.
+     */
+    public Throwable getThrowable() {
+        return throwable;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/AsyncListener.java b/servlet4/api/src/main/java/javax/servlet/AsyncListener.java
new file mode 100644
index 00000000..52a2c5ef
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/AsyncListener.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+import java.util.EventListener;
+
+/**
+ * The AsyncListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface AsyncListener extends EventListener {
+
+    /**
+     * Handle the on complete event.
+     *
+     * @param event the event.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void onComplete(AsyncEvent event) throws IOException;
+
+    /**
+     * Handle the on error event.
+     *
+     * @param event the event.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void onError(AsyncEvent event) throws IOException;
+
+    /**
+     * Handle the on start async event.
+     *
+     * @param event the event.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void onStartAsync(AsyncEvent event) throws IOException;
+
+    /**
+     * Handle the on timeout event.
+     *
+     * @param event the event.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void onTimeout(AsyncEvent event) throws IOException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/DispatcherType.java b/servlet4/api/src/main/java/javax/servlet/DispatcherType.java
new file mode 100644
index 00000000..2ece1ca2
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/DispatcherType.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The DispatcherType API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public enum DispatcherType {
+    
+    /**
+     * The type for forward dispatches.
+     */
+    FORWARD,
+    
+    /**
+     * The type for include dispatches.
+     */
+    INCLUDE,
+    
+    /**
+     * The type for request dispatches.
+     */
+    REQUEST,
+    
+    /**
+     * The type for async dispatches.
+     */
+    ASYNC,
+    
+    /**
+     * The type for error dispatches.
+     */
+    ERROR
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/Filter.java b/servlet4/api/src/main/java/javax/servlet/Filter.java
new file mode 100644
index 00000000..7e97801f
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/Filter.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+
+/**
+ * The Filter API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface Filter {
+
+    /**
+     * Initialize the filter.
+     *
+     * @param filterConfig the filter configuration.
+     * @throws ServletException when a servlet error occurs.
+     */
+    default void init(FilterConfig filterConfig) throws ServletException {
+    }
+
+    /**
+     * Process the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @param chain the chain.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;
+
+    /**
+     * Destroy the filter.
+     */
+    default void destroy() {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/FilterChain.java b/servlet4/api/src/main/java/javax/servlet/FilterChain.java
new file mode 100644
index 00000000..d6a867f3
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/FilterChain.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+
+/**
+ * The FilterChain API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface FilterChain {
+
+    /**
+     * Process the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/FilterConfig.java b/servlet4/api/src/main/java/javax/servlet/FilterConfig.java
new file mode 100644
index 00000000..753a50e5
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/FilterConfig.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.Enumeration;
+
+/**
+ * The FilterConfig API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface FilterConfig {
+
+    /**
+     * Get the filter name.
+     *
+     * @return the filter name.
+     */
+    public String getFilterName();
+
+    /**
+     * Get the init parameter.
+     *
+     * @param name the name.
+     * @return the value.
+     */
+    public String getInitParameter(String name);
+
+    /**
+     * Get the init parameter names.
+     *
+     * @return the init parameter names.
+     */
+    public Enumeration<String> getInitParameterNames();
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    public ServletContext getServletContext();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/FilterRegistration.java b/servlet4/api/src/main/java/javax/servlet/FilterRegistration.java
new file mode 100644
index 00000000..4b71b3f3
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/FilterRegistration.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.Collection;
+import java.util.EnumSet;
+
+/**
+ * The FilterRegistration API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface FilterRegistration extends Registration {
+
+    /**
+     * Add a mapping for servlet names.
+     *
+     * @param dispatcherTypes the dispatcher types.
+     * @param isMatchAfter true if it should be matched after declared filters.
+     * @param servletNames the servlet names.
+     */
+    public void addMappingForServletNames(EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter, String... servletNames);
+
+    /**
+     * Add a mapping for URL patterns.
+     *
+     * @param dispatcherTypes the dispatcher types.
+     * @param isMatchAfter true if it should be matched after declared filters.
+     * @param urlPatterns the URL patterns.
+     */
+    public void addMappingForUrlPatterns(EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter, String... urlPatterns);
+
+    /**
+     * Get the servlet name mappings.
+     *
+     * @return the servlet name mappings.
+     */
+    public Collection<String> getServletNameMappings();
+
+    /**
+     * Get the URL pattern mappings.
+     *
+     * @return the URL pattern mappings.
+     */
+    public Collection<String> getUrlPatternMappings();
+
+    /**
+     * The FilterRegistration.Dynamic API.
+     *
+     * @author Manfred Riem (mriem@manorrock.com)
+     */
+    interface Dynamic extends FilterRegistration, Registration.Dynamic {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/GenericFilter.java b/servlet4/api/src/main/java/javax/servlet/GenericFilter.java
new file mode 100644
index 00000000..467fb5d3
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/GenericFilter.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.Serializable;
+import java.util.Enumeration;
+
+/**
+ * A generic filter.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public abstract class GenericFilter implements Filter, FilterConfig, Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Stores the filter configuration.
+     */
+    private transient FilterConfig filterConfig;
+
+    @Override
+    public void init(FilterConfig filterConfig) throws ServletException {
+        this.filterConfig = filterConfig;
+        init();
+    }
+
+    /**
+     * Initialize the filter.
+     * 
+     * @throws ServletException when a Servlet error occurs.
+     */
+    public void init() throws ServletException {
+    }
+
+    /**
+     * Get the filter configuration.
+     * 
+     * @return the filter configuration.
+     */
+    public FilterConfig getFilterConfig() {
+        return filterConfig;
+    }
+
+    @Override
+    public String getFilterName() {
+        return filterConfig.getFilterName();
+    }
+
+    @Override
+    public String getInitParameter(String name) {
+        return filterConfig.getInitParameter(name);
+    }
+
+    @Override
+    public Enumeration<String> getInitParameterNames() {
+        return filterConfig.getInitParameterNames();
+    }
+
+    @Override
+    public ServletContext getServletContext() {
+        return filterConfig.getServletContext();
+    }
+
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/GenericServlet.java b/servlet4/api/src/main/java/javax/servlet/GenericServlet.java
new file mode 100644
index 00000000..1b8a32c9
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/GenericServlet.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Enumeration;
+
+/**
+ * The GenericServlet API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public abstract class GenericServlet implements Servlet, ServletConfig, Serializable {
+
+    /**
+     * Stores the servlet config.
+     */
+    private ServletConfig servletConfig;
+
+    /**
+     * Constructor.
+     */
+    public GenericServlet() {
+    }
+
+    /**
+     * Destroy the servlet.
+     */
+    @Override
+    public void destroy() {
+    }
+
+    /**
+     * Get the init parameter.
+     *
+     * @param name the name.
+     * @return the value, or null.
+     *
+     */
+    @Override
+    public String getInitParameter(String name) {
+        return servletConfig.getInitParameter(name);
+    }
+
+    /**
+     * Get the init parameter names.
+     *
+     * @return the init parameter names.
+     */
+    @Override
+    public Enumeration<String> getInitParameterNames() {
+        return servletConfig.getInitParameterNames();
+    }
+
+    /**
+     * Get the servlet config.
+     *
+     * @return the servlet config.
+     */
+    @Override
+    public ServletConfig getServletConfig() {
+        return servletConfig;
+    }
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    @Override
+    public ServletContext getServletContext() {
+        return servletConfig.getServletContext();
+    }
+
+    /**
+     * Get the servlet info.
+     *
+     * @return ""
+     */
+    @Override
+    public String getServletInfo() {
+        return "";
+    }
+
+    /**
+     * Get the servlet name.
+     *
+     * @return the servlet name.
+     */
+    @Override
+    public String getServletName() {
+        return servletConfig.getServletName();
+    }
+
+    /**
+     * Called by the servlet container to indicate to a servlet that the servlet
+     * is being placed into service. See {@link Servlet#init}.
+     *
+     * <p>
+     * This implementation stores the {@link ServletConfig} object it receives
+     * from the servlet container for later use. When overriding this form of
+     * the method, call <code>super.init(config)</code>.
+     *
+     * @param config the <code>ServletConfig</code> object that contains
+     * configuration information for this servlet
+     *
+     * @exception ServletException if an exception occurs that interrupts the
+     * servlet's normal operation
+     *
+     * @see UnavailableException
+     */
+    @Override
+    public void init(ServletConfig config) throws ServletException {
+        this.servletConfig = config;
+        this.init();
+    }
+
+    /**
+     * Init the servlet.
+     *
+     * @throws ServletException when a servlet error occurs.
+     */
+    public void init() throws ServletException {
+    }
+
+    /**
+     * Log the message.
+     *
+     * @param message the message.
+     */
+    public void log(String message) {
+        getServletContext().log(getServletName() + ": " + message);
+    }
+
+    /**
+     * Log the message.
+     *
+     * @param message the message.
+     * @param throwable the throwable.
+     */
+    public void log(String message, Throwable throwable) {
+        getServletContext().log(getServletName() + ": " + message, throwable);
+    }
+
+    /**
+     * Process the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public abstract void service(ServletRequest request, ServletResponse response) throws ServletException, IOException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/HttpConstraintElement.java b/servlet4/api/src/main/java/javax/servlet/HttpConstraintElement.java
new file mode 100644
index 00000000..4cffe0c7
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/HttpConstraintElement.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import javax.servlet.annotation.ServletSecurity.EmptyRoleSemantic;
+import javax.servlet.annotation.ServletSecurity.TransportGuarantee;
+
+/**
+ * The HttpConstraintElement API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class HttpConstraintElement {
+
+    /**
+     * Stores the EmptyRoleSemantic.
+     */
+    private EmptyRoleSemantic emptyRoleSemantic;
+
+    /**
+     * Stores the roles allowed.
+     */
+    private String[] rolesAllowed;
+
+    /**
+     * Stores the TransportGuarantee.
+     */
+    private TransportGuarantee transportGuarantee;
+
+    /**
+     * Constructor.
+     */
+    public HttpConstraintElement() {
+        this(EmptyRoleSemantic.PERMIT);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param emptyRoleSemantic the EmptyRoleSemantic.
+     */
+    public HttpConstraintElement(EmptyRoleSemantic emptyRoleSemantic) {
+        this(emptyRoleSemantic, TransportGuarantee.NONE, new String[0]);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param transportGuarantee the TransportGuarantee.
+     * @param rolesAllowed the roles allowed.
+     */
+    public HttpConstraintElement(TransportGuarantee transportGuarantee, String... rolesAllowed) {
+        this(EmptyRoleSemantic.PERMIT, transportGuarantee, rolesAllowed);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param emptyRoleSemantic the EmptyRoleSemantic.
+     * @param transportGuarantee the TransportGuarantee.
+     * @param rolesAllowed the roles allowed.
+     */
+    public HttpConstraintElement(EmptyRoleSemantic emptyRoleSemantic, TransportGuarantee transportGuarantee, String... rolesAllowed) {
+        this.emptyRoleSemantic = emptyRoleSemantic;
+        this.transportGuarantee = transportGuarantee;
+        this.rolesAllowed = rolesAllowed;
+    }
+
+    /**
+     * Get the EmptyRoleSemantic.
+     *
+     * @return the EmptyRoleSemantic.
+     */
+    public EmptyRoleSemantic getEmptyRoleSemantic() {
+        return emptyRoleSemantic;
+    }
+
+    /**
+     * Get the transport guarantee.
+     *
+     * @return the transport guarantee.
+     */
+    public TransportGuarantee getTransportGuarantee() {
+        return transportGuarantee;
+    }
+
+    /**
+     * Get the roles allowed.
+     *
+     * @return the roles allowed.
+     */
+    public String[] getRolesAllowed() {
+        String[] result = new String[rolesAllowed.length];
+        System.arraycopy(rolesAllowed, 0, result, 0, result.length);
+        return result;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/HttpMethodConstraintElement.java b/servlet4/api/src/main/java/javax/servlet/HttpMethodConstraintElement.java
new file mode 100644
index 00000000..18f339af
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/HttpMethodConstraintElement.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The HttpMethodConstraintElement API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class HttpMethodConstraintElement extends HttpConstraintElement {
+
+    /**
+     * Stores the HTTP method name.
+     */
+    private final String methodName;
+
+    /**
+     * Constructor.
+     *
+     * @param methodName the HTTP method name.
+     */
+    public HttpMethodConstraintElement(String methodName) {
+        this.methodName = methodName;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param methodName the HTTP method name.
+     * @param constraint the constraint.
+     */
+    public HttpMethodConstraintElement(String methodName, HttpConstraintElement constraint) {
+        super(constraint.getEmptyRoleSemantic(), constraint.getTransportGuarantee(), constraint.getRolesAllowed());
+        this.methodName = methodName;
+    }
+
+    /**
+     * Get the HTTP method name.
+     *
+     * @return the HTTP method name
+     */
+    public String getMethodName() {
+        return methodName;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/MultipartConfigElement.java b/servlet4/api/src/main/java/javax/servlet/MultipartConfigElement.java
new file mode 100644
index 00000000..1c2df2ed
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/MultipartConfigElement.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import javax.servlet.annotation.MultipartConfig;
+
+/**
+ * The MultipartConfigElement API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class MultipartConfigElement {
+
+    /**
+     * Stores the file size threshold.
+     */
+    private final int fileSizeThreshold;
+
+    /**
+     * Stores the location.
+     */
+    private final String location;
+
+    /**
+     * Stores the max file size.
+     */
+    private final long maxFileSize;
+
+    /**
+     * Stores the max request size.
+     */
+    private final long maxRequestSize;
+
+    /**
+     * Constructor.
+     *
+     * @param location the location.
+     */
+    public MultipartConfigElement(String location) {
+        this.fileSizeThreshold = 0;
+        this.location = location;
+        this.maxFileSize = -1L;
+        this.maxRequestSize = -1L;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param location the location.
+     * @param maxFileSize the maximum file size.
+     * @param maxRequestSize the maximum request size.
+     * @param fileSizeThreshold the file size threshold.
+     */
+    public MultipartConfigElement(String location, long maxFileSize, long maxRequestSize, int fileSizeThreshold) {
+        this.fileSizeThreshold = fileSizeThreshold;
+        this.location = location;
+        this.maxFileSize = maxFileSize;
+        this.maxRequestSize = maxRequestSize;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param annotation the annotation value
+     */
+    public MultipartConfigElement(MultipartConfig annotation) {
+        this.fileSizeThreshold = annotation.fileSizeThreshold();
+        this.location = annotation.location();
+        this.maxFileSize = annotation.maxFileSize();
+        this.maxRequestSize = annotation.maxRequestSize();
+    }
+
+    /**
+     * Get the file size threshold.
+     *
+     * @return the file size threshold.
+     */
+    public int getFileSizeThreshold() {
+        return this.fileSizeThreshold;
+    }
+
+    /**
+     * Get the storage location.
+     *
+     * @return the storage location.
+     */
+    public String getLocation() {
+        return this.location;
+    }
+
+    /**
+     * Get the max file size.
+     *
+     * @return the max file size.
+     */
+    public long getMaxFileSize() {
+        return this.maxFileSize;
+    }
+
+    /**
+     * Get the max request size.
+     *
+     * @return the max request size.
+     */
+    public long getMaxRequestSize() {
+        return this.maxRequestSize;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ReadListener.java b/servlet4/api/src/main/java/javax/servlet/ReadListener.java
new file mode 100644
index 00000000..88dfdd1f
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ReadListener.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+import java.util.EventListener;
+
+/**
+ * The ReadListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ReadListener extends EventListener {
+
+    /**
+     * Called when all data has been read.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    public void onAllDataRead() throws IOException;
+
+    /**
+     * Called when data is available.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    public void onDataAvailable() throws IOException;
+
+    /**
+     * Called when an error occurs.
+     *
+     * @param throwable the throwable.
+     */
+    public void onError(Throwable throwable);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/Registration.java b/servlet4/api/src/main/java/javax/servlet/Registration.java
new file mode 100644
index 00000000..e75fa2ac
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/Registration.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * The Registration API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface Registration {
+
+    /**
+     * Get the class name.
+     *
+     * @return the class name.
+     */
+    public String getClassName();
+
+    /**
+     * Get the init parameter.
+     *
+     * @param name the name.
+     * @return the value, or null if not found.
+     */
+    public String getInitParameter(String name);
+
+    /**
+     * Get the init parameters.
+     *
+     * @return the init parameters.
+     */
+    public Map<String, String> getInitParameters();
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName();
+
+    /**
+     * Set the init parameter.
+     *
+     * @param name the name.
+     * @param value the value.
+     * @return true if it was set, false otherwise.
+     */
+    public boolean setInitParameter(String name, String value);
+
+    /**
+     * Set the init parameters.
+     *
+     * @param initParameters the init parameters.
+     * @return the init parameters that could NOT be set.
+     */
+    public Set<String> setInitParameters(Map<String, String> initParameters);
+
+    /**
+     * The Registration.Dynamic API.
+     *
+     * @author Manfred Riem (mriem@manorrock.com)
+     */
+    interface Dynamic extends Registration {
+
+        /**
+         * Set async supported.
+         *
+         * @param asyncSupported the async supported flag.
+         */
+        public void setAsyncSupported(boolean asyncSupported);
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/RequestDispatcher.java b/servlet4/api/src/main/java/javax/servlet/RequestDispatcher.java
new file mode 100644
index 00000000..672d0345
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/RequestDispatcher.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+
+/**
+ * The RequestDispatcher API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface RequestDispatcher {
+
+    /**
+     * Defines the ERROR_EXCEPTION constant.
+     */
+    static final String ERROR_EXCEPTION = "javax.servlet.error.exception";
+
+    /**
+     * Defines the ERROR_EXCEPTION_TYPE constant.
+     */
+    static final String ERROR_EXCEPTION_TYPE = "javax.servlet.error.exception_type";
+
+    /**
+     * Defines the ERROR_MESSAGE constant.
+     */
+    static final String ERROR_MESSAGE = "javax.servlet.error.message";
+
+    /**
+     * Defines the ERROR_REQUEST_URI constant.
+     */
+    static final String ERROR_REQUEST_URI = "javax.servlet.error.request_uri";
+
+    /**
+     * Defines the ERROR_SERVLET_NAME constant.
+     */
+    static final String ERROR_SERVLET_NAME = "javax.servlet.error.servlet_name";
+
+    /**
+     * Defines the ERROR_STATUS_CODE constant.
+     */
+    static final String ERROR_STATUS_CODE = "javax.servlet.error.status_code";
+
+    /**
+     * Defines the FORWARD_CONTEXT_PATH constant.
+     */
+    static final String FORWARD_CONTEXT_PATH = "javax.servlet.forward.context_path";
+    
+    /**
+     * Defines the FORWARD_MAPPING constant.
+     */
+    static final String	FORWARD_MAPPING	= "javax.servlet.forward.mapping";
+
+    /**
+     * Defines the FORWARD_PATH_INFO constant.
+     */
+    static final String FORWARD_PATH_INFO = "javax.servlet.forward.path_info";
+
+    /**
+     * Defines the FORWARD_QUERY_STRING constant.
+     */
+    static final String FORWARD_QUERY_STRING = "javax.servlet.forward.query_string";
+
+    /**
+     * Defines the FORWARD_REQUEST_URI constant.
+     */
+    static final String FORWARD_REQUEST_URI = "javax.servlet.forward.request_uri";
+
+    /**
+     * Defines the FORWARD_SERVLET_PATH constant.
+     */
+    static final String FORWARD_SERVLET_PATH = "javax.servlet.forward.servlet_path";
+
+    /**
+     * Defines the INCLUDE_CONTEXT_PATH constant.
+     */
+    static final String INCLUDE_CONTEXT_PATH = "javax.servlet.include.context_path";
+    
+    /**
+     * Defines the INCLUDE_MAPPING constant.
+     */
+    static final String INCLUDE_MAPPING = "javax.servlet.include.mapping";
+
+    /**
+     * Defines the INCLUDE_PATH_INFO constant.
+     */
+    static final String INCLUDE_PATH_INFO = "javax.servlet.include.path_info";
+
+    /**
+     * Defines the INCLUDE_QUERY_STRING constant.
+     */
+    static final String INCLUDE_QUERY_STRING = "javax.servlet.include.query_string";
+
+    /**
+     * Defines the INCLUDE_REQUEST_URI constant.
+     */
+    static final String INCLUDE_REQUEST_URI = "javax.servlet.include.request_uri";
+
+    /**
+     * Defines the INCLUDE_SERVLET_PATH constant.
+     */
+    static final String INCLUDE_SERVLET_PATH = "javax.servlet.include.servlet_path";
+
+    /**
+     * Forward the request.
+     *
+     * @param request the request.
+     * @param response the response
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    void forward(ServletRequest request, ServletResponse response) throws IOException, ServletException;
+
+    /**
+     * Include into the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    void include(ServletRequest request, ServletResponse response) throws IOException, ServletException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/Servlet.java b/servlet4/api/src/main/java/javax/servlet/Servlet.java
new file mode 100644
index 00000000..8ddd678b
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/Servlet.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+
+/**
+ * The Servlet API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface Servlet {
+
+    /**
+     * Destroy the servlet.
+     */
+    public void destroy();
+
+    /**
+     * Get the servlet config.
+     *
+     * @return the servlet config.
+     */
+    public ServletConfig getServletConfig();
+
+    /**
+     * Get the servlet information.
+     *
+     * @return the servlet information.
+     */
+    public String getServletInfo();
+
+    /**
+     * Initialize the servlet.
+     *
+     * @param servletConfig the servlet config.
+     * @throws ServletException when a servlet error occurs.
+     */
+    public void init(ServletConfig servletConfig) throws ServletException;
+
+    /**
+     * Process the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    public void service(ServletRequest request, ServletResponse response) throws IOException, ServletException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletConfig.java b/servlet4/api/src/main/java/javax/servlet/ServletConfig.java
new file mode 100644
index 00000000..d2624a5d
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletConfig.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.Enumeration;
+
+/**
+ * The ServletConfig API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletConfig {
+
+    /**
+     * Get the init parameter.
+     *
+     * @param name the name.
+     * @return the value, or null if not found.
+     */
+    public String getInitParameter(String name);
+
+    /**
+     * Get the init parameter names.
+     *
+     * @return the init parameter names.
+     */
+    public Enumeration<String> getInitParameterNames();
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    public ServletContext getServletContext();
+
+    /**
+     * Get the servlet name.
+     *
+     * @return the servlet name.
+     */
+    public String getServletName();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletContainerInitializer.java b/servlet4/api/src/main/java/javax/servlet/ServletContainerInitializer.java
new file mode 100644
index 00000000..9dbb51a9
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletContainerInitializer.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.Set;
+
+/**
+ * The ServletContainerInitializer API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletContainerInitializer {
+
+    /**
+     * Notify the initializer upon startup.
+     *
+     * @param classes the classes to inspect.
+     * @param servletContext the servlet context.
+     * @throws ServletException when a servlet error occurs.
+     */
+    public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletContext.java b/servlet4/api/src/main/java/javax/servlet/ServletContext.java
new file mode 100644
index 00000000..681971d8
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletContext.java
@@ -0,0 +1,521 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Enumeration;
+import java.util.EventListener;
+import java.util.Map;
+import java.util.Set;
+import javax.servlet.descriptor.JspConfigDescriptor;
+
+/**
+ * The servlet context API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletContext {
+
+    /**
+     * Defines the ORDERED_LIBS constant.
+     */
+    public static final String ORDERED_LIBS = "javax.servlet.context.orderedLibs";
+
+    /**
+     * Defines the TEMPDIR constant.
+     */
+    public static final String TEMPDIR = "javax.servlet.context.tempdir";
+
+    /**
+     * Add the filter.
+     *
+     * @param filterName the filter name.
+     * @param className the class name.
+     * @return the dynamic filter registration.
+     */
+    FilterRegistration.Dynamic addFilter(String filterName, String className);
+
+    /**
+     * Add the filter.
+     *
+     * @param filterName the filter name.
+     * @param filter the filter.
+     * @return the dynamic filter registration.
+     */
+    FilterRegistration.Dynamic addFilter(String filterName, Filter filter);
+
+    /**
+     * Add the filter.
+     *
+     * @param filterName the filter name.
+     * @param filterClass the filter class.
+     * @return the dynamic filter registration.
+     */
+    FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass);
+    
+    /**
+     * Add a JSP file.
+     * 
+     * @param servletName the name of the servlet to be used.
+     * @param jspFile the path of the JSP file.
+     * @return the dynamic servlet registration.
+     */
+    ServletRegistration.Dynamic addJspFile(String servletName, String jspFile);
+
+    /**
+     * Add the listener.
+     *
+     * @param className the class name.
+     */
+    void addListener(String className);
+
+    /**
+     * Add the listener.
+     *
+     * @param <T> the type.
+     * @param listener the listener.
+     */
+    <T extends EventListener> void addListener(T listener);
+
+    /**
+     * Add the listener.
+     *
+     * @param listenerClass the listener class.
+     */
+    void addListener(Class<? extends EventListener> listenerClass);
+
+    /**
+     * Add the servlet.
+     *
+     * @param servletName the servlet name.
+     * @param className the class name.
+     * @return the servlet dynamic registration.
+     */
+    ServletRegistration.Dynamic addServlet(String servletName, String className);
+
+    /**
+     * Add the servlet.
+     *
+     * @param servletName the servlet name.
+     * @param servlet the servlet.
+     * @return the dynamic servlet registration.
+     */
+    ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet);
+
+    /**
+     * Add the servlet.
+     *
+     * @param servletName the servlet name.
+     * @param servletClass the servlet class.
+     * @return the dynamic servlet registration.
+     */
+    ServletRegistration.Dynamic addServlet(String servletName, Class<? extends Servlet> servletClass);
+
+    /**
+     * Create the filter.
+     *
+     * @param <T> the filter type.
+     * @param clazz the class.
+     * @return the filter.
+     * @throws ServletException when a servlet error occurs.
+     */
+    <T extends Filter> T createFilter(Class<T> clazz) throws ServletException;
+
+    /**
+     * Create the listener.
+     *
+     * @param <T> the listener type.
+     * @param clazz the class.
+     * @return the listener.
+     * @throws ServletException when a servlet error occurs.
+     */
+    <T extends EventListener> T createListener(Class<T> clazz) throws ServletException;
+
+    /**
+     * Create the servlet.
+     *
+     * @param <T> the servlet type.
+     * @param clazz the class.
+     * @return the created servlet.
+     * @throws ServletException when a servlet error occurs.
+     */
+    <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException;
+
+    /**
+     * Declare the roles.
+     *
+     * @param roles the roles.
+     */
+    void declareRoles(String... roles);
+
+    /**
+     * Get the attribute.
+     *
+     * @param name the name.
+     * @return the value, or null.
+     */
+    Object getAttribute(String name);
+
+    /**
+     * Get the attribute names.
+     *
+     * @return the attribute names.
+     */
+    Enumeration<String> getAttributeNames();
+
+    /**
+     * Get the class loader.
+     *
+     * @return the class loader.
+     */
+    ClassLoader getClassLoader();
+
+    /**
+     * Get the servlet context for the given path.
+     *
+     * @param path the path.
+     * @return the servlet context, or null if not found (or not supported).
+     */
+    ServletContext getContext(String path);
+
+    /**
+     * Get the context path.
+     *
+     * @return the context path.
+     */
+    String getContextPath();
+
+    /**
+     * Get the default session tracking modes.
+     *
+     * @return the default session tracking modes.
+     */
+    Set<SessionTrackingMode> getDefaultSessionTrackingModes();
+
+    /**
+     * Get the effective major version.
+     *
+     * @return the effective major version.
+     */
+    int getEffectiveMajorVersion();
+
+    /**
+     * Get the effective minor version.
+     *
+     * @return the effective minor version.
+     */
+    int getEffectiveMinorVersion();
+
+    /**
+     * Get the effective session tracking modes.
+     *
+     * @return the effective session tracking modes.
+     */
+    Set<SessionTrackingMode> getEffectiveSessionTrackingModes();
+
+    /**
+     * Get the filter registration.
+     *
+     * @param filterName the filter name.
+     * @return the
+     */
+    FilterRegistration getFilterRegistration(String filterName);
+
+    /**
+     * Get the filter registrations.
+     *
+     * @return the filter registrations.
+     *
+     */
+    Map<String, ? extends FilterRegistration> getFilterRegistrations();
+
+    /**
+     * Get the init parameter.
+     *
+     * @param name the name.
+     * @return the value, or null if not found.
+     */
+    String getInitParameter(String name);
+
+    /**
+     * Get the init parameter names.
+     *
+     * @return the init parameter names.
+     */
+    Enumeration<String> getInitParameterNames();
+
+    /**
+     * Get the JSP config descriptor.
+     *
+     * @return the JSP config descriptor.
+     */
+    JspConfigDescriptor getJspConfigDescriptor();
+
+    /**
+     * Get the major version.
+     *
+     * @return the major version.
+     */
+    int getMajorVersion();
+
+    /**
+     * Get the mime type.
+     *
+     * @param filename the filename.
+     * @return the mime type, or null.
+     */
+    String getMimeType(String filename);
+
+    /**
+     * Get the minor version.
+     *
+     * @return the minor version.
+     */
+    int getMinorVersion();
+
+    /**
+     * Get the named dispatcher.
+     *
+     * @param name the name.
+     * @return the request dispatcher, or null if not found.
+     */
+    RequestDispatcher getNamedDispatcher(String name);
+
+    /**
+     * Get the real path.
+     *
+     * @param path the path.
+     * @return the real path.
+     */
+    String getRealPath(String path);
+    
+    /**
+     * Get the default request character encoding.
+     * 
+     * @return the default request character encoding.
+     */
+    String getRequestCharacterEncoding();
+
+    /**
+     * Get the request dispatcher.
+     *
+     * @param path the path.
+     * @return the request dispatcher, or null.
+     */
+    RequestDispatcher getRequestDispatcher(String path);
+    
+    /**
+     * Get the default response character encoding.
+     * 
+     * @return the default response character encoding.
+     */
+    String getResponseCharacterEncoding();
+    
+    /**
+     * Get the resource.
+     *
+     * @param path the path.
+     * @return the URL, or null if not found.
+     * @throws MalformedURLException when the path is malformed.
+     */
+    URL getResource(String path) throws MalformedURLException;
+
+    /**
+     * Get the resource as a stream.
+     *
+     * @param path the path.
+     * @return the input stream, or null.
+     */
+    InputStream getResourceAsStream(String path);
+
+    /**
+     * Get the resource paths for the given path.
+     *
+     * @param path the path.
+     * @return the resource paths.
+     */
+    Set<String> getResourcePaths(String path);
+
+    /**
+     * Get the server info.
+     *
+     * @return the server info.
+     */
+    String getServerInfo();
+
+    /**
+     * Get the servlet.
+     *
+     * @param name the name.
+     * @return null
+     * @throws ServletException when a servlet error occurs.
+     * @deprecated
+     */
+    @Deprecated
+    Servlet getServlet(String name) throws ServletException;
+
+    /**
+     * Get the servlet context name.
+     *
+     * @return the servlet context name.
+     */
+    String getServletContextName();
+
+    /**
+     * Get the servlet names.
+     *
+     * @return an empty enumeration.
+     * @deprecated
+     */
+    @Deprecated
+    Enumeration<String> getServletNames();
+
+    /**
+     * Get the servlet registration.
+     *
+     * @param servletName the servlet name.
+     * @return the servlet registration, or null if not found.
+     */
+    ServletRegistration getServletRegistration(String servletName);
+
+    /**
+     * Get the servlet registrations.
+     *
+     * @return the servlet registrations.
+     */
+    Map<String, ? extends ServletRegistration> getServletRegistrations();
+
+    /**
+     * Get the servlets.
+     *
+     * @return an empty enumeration.
+     * @deprecated
+     */
+    @Deprecated
+    Enumeration<Servlet> getServlets();
+
+    /**
+     * Get the session cookie config.
+     *
+     * @return the session cookie config.
+     */
+    SessionCookieConfig getSessionCookieConfig();
+    
+    /**
+     * Get the default session timeout.
+     * 
+     * @return the default session timeout.
+     */
+    int getSessionTimeout();
+
+    /**
+     * Get the virtual server name.
+     *
+     * @return the virtual server name.
+     */
+    String getVirtualServerName();
+
+    /**
+     * Log the specified message.
+     *
+     * @param message the message.
+     */
+    void log(String message);
+
+    /**
+     * Log the exception and message.
+     *
+     * @param exception the exception.
+     * @param message the message.
+     * @deprecated
+     */
+    @Deprecated
+    void log(Exception exception, String message);
+
+    /**
+     * Log the message and throwable.
+     *
+     * @param message the message.
+     * @param throwable the throwable.
+     */
+    void log(String message, Throwable throwable);
+
+    /**
+     * Remove the attribute.
+     *
+     * @param name the name.
+     */
+    void removeAttribute(String name);
+
+    /**
+     * Set the attribute.
+     *
+     * @param name the name.
+     * @param object the object value.
+     */
+    void setAttribute(String name, Object object);
+
+    /**
+     * Set the init parameter.
+     *
+     * @param name the name.
+     * @param value the value.
+     * @return true if it was set, false otherwise.
+     */
+    boolean setInitParameter(String name, String value);
+    
+    /**
+     * Set the default request character encoding.
+     * 
+     * @param requestCharacterEncoding the default request character encoding.
+     */
+    void setRequestCharacterEncoding(String requestCharacterEncoding);
+    
+    /**
+     * Set the default response character encoding.
+     * 
+     * @param responseCharacterEncoding the default response character encoding.
+     */
+    void setResponseCharacterEncoding(String responseCharacterEncoding);
+    
+    /**
+     * Set the default session timeout.
+     * 
+     * @param sessionTimeout the default session timeout.
+     */
+    void setSessionTimeout(int sessionTimeout);
+
+    /**
+     * Set the session tracking modes.
+     *
+     * @param sessionTrackingModes the session tracking modes.
+     */
+    void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletContextAttributeEvent.java b/servlet4/api/src/main/java/javax/servlet/ServletContextAttributeEvent.java
new file mode 100644
index 00000000..b9091129
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletContextAttributeEvent.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The ServletContextAttributeEvent API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class ServletContextAttributeEvent extends ServletContextEvent {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = 3444099886820575682L;
+    
+    /**
+     * Stores the name.
+     */
+    private final String name;
+
+    /**
+     * Stores the value.
+     */
+    private final Object value;
+
+    /**
+     * Constructor.
+     *
+     * @param servletContext the servlet context.
+     * @param name the name.
+     * @param value the value.
+     */
+    public ServletContextAttributeEvent(ServletContext servletContext, String name, Object value) {
+        super(servletContext);
+        this.name = name;
+        this.value = value;
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return this.name;
+    }
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    public Object getValue() {
+        return this.value;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletContextAttributeListener.java b/servlet4/api/src/main/java/javax/servlet/ServletContextAttributeListener.java
new file mode 100644
index 00000000..fbdd0c23
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletContextAttributeListener.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.EventListener;
+
+/**
+ * The ServletContextAttributeListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletContextAttributeListener extends EventListener {
+
+    /**
+     * Handle the attribute added event.
+     *
+     * @param event the event.
+     */
+    default void attributeAdded(ServletContextAttributeEvent event) {
+    }
+
+    /**
+     * Handle the attribute removed event.
+     *
+     * @param event the event.
+     */
+    default void attributeRemoved(ServletContextAttributeEvent event) {
+    }
+
+    /**
+     * Handle the attribute replaced event.
+     *
+     * @param event the event.
+     */
+    default void attributeReplaced(ServletContextAttributeEvent event) {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletContextEvent.java b/servlet4/api/src/main/java/javax/servlet/ServletContextEvent.java
new file mode 100644
index 00000000..bc146de3
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletContextEvent.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.EventObject;
+
+/**
+ * The ServletContextEvent API.
+ */
+public class ServletContextEvent extends EventObject {
+    
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = -7501701636134222423L;
+
+    /**
+     * Constructor.
+     *
+     * @param servletContext the servlet context.
+     */
+    public ServletContextEvent(ServletContext servletContext) {
+        super(servletContext);
+    }
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    public ServletContext getServletContext() {
+        return (ServletContext) super.getSource();
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletContextListener.java b/servlet4/api/src/main/java/javax/servlet/ServletContextListener.java
new file mode 100644
index 00000000..925b2898
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletContextListener.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.EventListener;
+
+/**
+ * The ServletContextListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletContextListener extends EventListener {
+
+    /**
+     * Handle the context destroyed event.
+     *
+     * @param event the event.
+     */
+    default void contextDestroyed(ServletContextEvent event) {
+    }
+
+    /**
+     * Handle the context initialized event.
+     *
+     * @param event the event.
+     */
+    default void contextInitialized(ServletContextEvent event) {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletException.java b/servlet4/api/src/main/java/javax/servlet/ServletException.java
new file mode 100644
index 00000000..cf7e6227
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletException.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The ServletException API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class ServletException extends Exception {
+
+    /**
+     * Stores the cause.
+     */
+    private Throwable rootCause;
+
+    /**
+     * Constructor.
+     */
+    public ServletException() {
+        super();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param message the message.
+     */
+    public ServletException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param message the message.
+     * @param rootCause the root cause.
+     */
+    public ServletException(String message, Throwable rootCause) {
+        super(message, rootCause);
+        this.rootCause = rootCause;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param rootCause the root cause.
+     */
+    public ServletException(Throwable rootCause) {
+        super(rootCause);
+        this.rootCause = rootCause;
+    }
+
+    /**
+     * Get the root cause.
+     *
+     * @return the root cause.
+     */
+    public Throwable getRootCause() {
+        return rootCause;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletInputStream.java b/servlet4/api/src/main/java/javax/servlet/ServletInputStream.java
new file mode 100644
index 00000000..da40f4ff
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletInputStream.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * The ServletInputStream API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public abstract class ServletInputStream extends InputStream {
+
+    /**
+     * Constructor.
+     */
+    protected ServletInputStream() {
+    }
+
+    /**
+     * Is the stream at the end.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public abstract boolean isFinished();
+
+    /**
+     * Is the stream ready for reading.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public abstract boolean isReady();
+
+    /**
+     * Read a line.
+     *
+     * @param buffer the buffer.
+     * @param offset the offset.
+     * @param length the length.
+     * @return the number of bytes read.
+     * @throws IOException when an I/O error occurs.
+     */
+    public int readLine(byte[] buffer, int offset, int length) throws IOException {
+        int result = 0;
+        if (length > 0) {
+            int count = 0;
+            int read = read();
+            while (read != -1) {
+                buffer[offset++] = (byte) read;
+                count++;
+                if (read == '\n' || count == length) {
+                    break;
+                }
+                read = read();
+            }
+            result = count > 0 ? count : -1;
+        }
+        return result;
+    }
+
+    /**
+     * Set the read listener.
+     *
+     * @param readListener the read listener.
+     */
+    public abstract void setReadListener(ReadListener readListener);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletOutputStream.java b/servlet4/api/src/main/java/javax/servlet/ServletOutputStream.java
new file mode 100644
index 00000000..1936659a
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletOutputStream.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * The ServletOutputStream API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public abstract class ServletOutputStream extends OutputStream {
+
+    /**
+     * Constructor.
+     */
+    protected ServletOutputStream() {
+    }
+
+    /**
+     * Is ready for output.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public abstract boolean isReady();
+
+    /**
+     * Print a string.
+     *
+     * @param string the string.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void print(String string) throws IOException {
+        if (string == null) {
+            string = "null";
+        }
+        int len = string.length();
+        for (int i = 0; i < len; i++) {
+            char c = string.charAt(i);
+            write(c);
+        }
+    }
+
+    /**
+     * Print a boolean.
+     *
+     * @param bool the boolean.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void print(boolean bool) throws IOException {
+        String msg;
+        if (bool) {
+            msg = "true";
+        } else {
+            msg = "false";
+        }
+        print(msg);
+    }
+
+    /**
+     * Print a character.
+     *
+     * @param character the character.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void print(char character) throws IOException {
+        print(String.valueOf(character));
+    }
+
+    /**
+     * Print an integer.
+     *
+     * @param integer the integer.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void print(int integer) throws IOException {
+        print(String.valueOf(integer));
+    }
+
+    /**
+     * Print the long.
+     *
+     * @param l the long.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void print(long l) throws IOException {
+        print(String.valueOf(l));
+    }
+
+    /**
+     * Print the float.
+     *
+     * @param f the float.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void print(float f) throws IOException {
+        print(String.valueOf(f));
+    }
+
+    /**
+     * Print the double.
+     *
+     * @param d the double.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void print(double d) throws IOException {
+        print(String.valueOf(d));
+    }
+
+    /**
+     * Print a carriage return and line feed.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    public void println() throws IOException {
+        print("\r\n");
+    }
+
+    /**
+     * Print string with linefeed.
+     *
+     * @param string the string.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void println(String string) throws IOException {
+        print(string);
+        println();
+    }
+
+    /**
+     * Print boolean with linefeed.
+     *
+     * @param bool the boolean.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void println(boolean bool) throws IOException {
+        print(bool);
+        println();
+    }
+
+    /**
+     * Print character with linefeed.
+     *
+     * @param character the character.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void println(char character) throws IOException {
+        print(character);
+        println();
+    }
+
+    /**
+     * Print integer with linefeed.
+     *
+     * @param integer the integer.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void println(int integer) throws IOException {
+        print(integer);
+        println();
+    }
+
+    /**
+     * Print long with linefeed.
+     *
+     * @param l the long.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void println(long l) throws IOException {
+        print(l);
+        println();
+    }
+
+    /**
+     * Print float with linefeed.
+     *
+     * @param f the float.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void println(float f) throws IOException {
+        print(f);
+        println();
+    }
+
+    /**
+     * Print double with linefeed.
+     *
+     * @param d the double.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void println(double d) throws IOException {
+        print(d);
+        println();
+    }
+
+    /**
+     * Set the write listener.
+     *
+     * @param writeListener the write listener.
+     */
+    public abstract void setWriteListener(WriteListener writeListener);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletRegistration.java b/servlet4/api/src/main/java/javax/servlet/ServletRegistration.java
new file mode 100644
index 00000000..69f7a6db
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletRegistration.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * The ServletRegistration API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletRegistration extends Registration {
+
+    /**
+     * Add a mapping.
+     *
+     * @param urlPatterns the URL patterns.
+     * @return the patterns that were already mapped before.
+     */
+    public Set<String> addMapping(String... urlPatterns);
+
+    /**
+     * Get the mappings.
+     *
+     * @return the mappings.
+     */
+    public Collection<String> getMappings();
+
+    /**
+     * Get the run as role.
+     *
+     * @return the run as role.
+     */
+    public String getRunAsRole();
+
+    /**
+     * The ServletRegistration.Dynamic API.
+     */
+    interface Dynamic extends ServletRegistration, Registration.Dynamic {
+
+        /**
+         * Set the load on startup.
+         *
+         * @param loadOnStartup the load on startup.
+         */
+        public void setLoadOnStartup(int loadOnStartup);
+
+        /**
+         * Set the servlet security.
+         *
+         * @param constraint the constraint.
+         * @return the already mapped URL patterns.
+         */
+        public Set<String> setServletSecurity(ServletSecurityElement constraint);
+
+        /**
+         * Set the multipart config element.
+         *
+         * @param multipartConfig the multipart config element.
+         */
+        public void setMultipartConfig(MultipartConfigElement multipartConfig);
+
+        /**
+         * Set the run as role.
+         *
+         * @param role the role.
+         */
+        public void setRunAsRole(String role);
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletRequest.java b/servlet4/api/src/main/java/javax/servlet/ServletRequest.java
new file mode 100644
index 00000000..6bed26b1
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletRequest.java
@@ -0,0 +1,316 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.util.Enumeration;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * The ServletRequest API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletRequest {
+
+    /**
+     * Get the async context.
+     *
+     * @return the async context.
+     */
+    public AsyncContext getAsyncContext();
+
+    /**
+     * Get the attribute.
+     *
+     * @param name the name.
+     * @return the value, or null if not found.
+     */
+    public Object getAttribute(String name);
+
+    /**
+     * Get the attribute names.
+     *
+     * @return the attribute names.
+     */
+    public Enumeration<String> getAttributeNames();
+
+    /**
+     * Get the character encoding.
+     *
+     * @return the character encoding.
+     */
+    public String getCharacterEncoding();
+
+    /**
+     * Get the content length.
+     *
+     * @return the content length, or -1 if not known.
+     */
+    public int getContentLength();
+
+    /**
+     * Get the content length.
+     *
+     * @return the content length, or -1 if not known.
+     */
+    public long getContentLengthLong();
+
+    /**
+     * Get the content type.
+     *
+     * @return the content type.
+     */
+    public String getContentType();
+
+    /**
+     * Get the dispatcher type.
+     *
+     * @return the dispatcher type.
+     */
+    public DispatcherType getDispatcherType();
+
+    /**
+     * Get the input stream.
+     *
+     * @return the input stream.
+     * @throws IOException when an I/O error occurs.
+     */
+    public ServletInputStream getInputStream() throws IOException;
+
+    /**
+     * Get the local address.
+     *
+     * @return the local address.
+     */
+    public String getLocalAddr();
+
+    /**
+     * Get the local name.
+     *
+     * @return the local name.
+     */
+    public String getLocalName();
+
+    /**
+     * Get the local port.
+     *
+     * @return the local port.
+     */
+    public int getLocalPort();
+
+    /**
+     * Get the locale.
+     *
+     * @return the locale.
+     */
+    public Locale getLocale();
+
+    /**
+     * Get the locales.
+     *
+     * @return the locales.
+     */
+    public Enumeration<Locale> getLocales();
+
+    /**
+     * Get the parameter.
+     *
+     * @param name the name.
+     * @return the value or null if not found.
+     */
+    public String getParameter(String name);
+
+    /**
+     * Get the parameter map.
+     *
+     * @return the parameter map.
+     */
+    public Map<String, String[]> getParameterMap();
+
+    /**
+     * Get the parameter names.
+     *
+     * @return the parameter names.
+     */
+    public Enumeration<String> getParameterNames();
+
+    /**
+     * Get the parameter values.
+     *
+     * @param name the name.
+     * @return the values.
+     */
+    public String[] getParameterValues(String name);
+
+    /**
+     * Get the protocol.
+     *
+     * @return the protocol.
+     */
+    public String getProtocol();
+
+    /**
+     * Get the reader.
+     *
+     * @return the reader.
+     * @throws IOException when an I/O error occurs.
+     */
+    public BufferedReader getReader() throws IOException;
+
+    /**
+     * Get the real path.
+     *
+     * @param path the path.
+     * @return the real path.
+     * @deprecated
+     */
+    public String getRealPath(String path);
+
+    /**
+     * Get the remote address.
+     *
+     * @return the remote address.
+     */
+    public String getRemoteAddr();
+
+    /**
+     * Get the remote host.
+     *
+     * @return the remote host.
+     */
+    public String getRemoteHost();
+
+    /**
+     * Get the remote port.
+     *
+     * @return the remote port.
+     */
+    public int getRemotePort();
+
+    /**
+     * Get the request dispatcher.
+     *
+     * @param path the path.
+     * @return the request dispatcher.
+     */
+    public RequestDispatcher getRequestDispatcher(String path);
+
+    /**
+     * Get the scheme.
+     *
+     * @return the scheme.
+     */
+    public String getScheme();
+
+    /**
+     * Get the server name.
+     *
+     * @return the server name.
+     */
+    public String getServerName();
+
+    /**
+     * Get the server port.
+     *
+     * @return the server port.
+     */
+    public int getServerPort();
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    public ServletContext getServletContext();
+
+    /**
+     * Is async started.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isAsyncStarted();
+
+    /**
+     * Is async supported.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isAsyncSupported();
+
+    /**
+     * Is secure.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isSecure();
+
+    /**
+     * Remove the attribute.
+     *
+     * @param name the name.
+     */
+    public void removeAttribute(String name);
+
+    /**
+     * Set the attribute.
+     *
+     * @param name the name.
+     * @param object the object value.
+     */
+    public void setAttribute(String name, Object object);
+
+    /**
+     * Set the character encoding.
+     *
+     * @param characterEncoding the character encoding.
+     * @throws UnsupportedEncodingException when the encoding is NOT supported.
+     */
+    public void setCharacterEncoding(String characterEncoding) throws UnsupportedEncodingException;
+
+    /**
+     * Start async processing.
+     *
+     * @return the async context.
+     * @throws IllegalStateException when not able to start async processing.
+     */
+    public AsyncContext startAsync() throws IllegalStateException;
+
+    /**
+     * Start async processing.
+     *
+     * @param servletRequest the servlet request.
+     * @param servletResponse the servlet response.
+     * @return the async context.
+     * @throws IllegalStateException when not able to start async processing.
+     */
+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) throws IllegalStateException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletRequestAttributeEvent.java b/servlet4/api/src/main/java/javax/servlet/ServletRequestAttributeEvent.java
new file mode 100644
index 00000000..4b173be0
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletRequestAttributeEvent.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The ServletRequestAttributeEvent API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class ServletRequestAttributeEvent extends ServletRequestEvent {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = -1466635426192317793L;
+
+    /**
+     * Stores the name.
+     */
+    private final String name;
+
+    /**
+     * Stores the value.
+     */
+    private final Object value;
+
+    /**
+     * Constructor.
+     *
+     * @param servletContext the servlet context.
+     * @param request the request.
+     * @param name the name.
+     * @param value the value.
+     */
+    public ServletRequestAttributeEvent(ServletContext servletContext, ServletRequest request, String name, Object value) {
+        super(servletContext, request);
+        this.name = name;
+        this.value = value;
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    public Object getValue() {
+        return this.value;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletRequestAttributeListener.java b/servlet4/api/src/main/java/javax/servlet/ServletRequestAttributeListener.java
new file mode 100644
index 00000000..993a5ac6
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletRequestAttributeListener.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.EventListener;
+
+/**
+ * The ServletRequestAttributeListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletRequestAttributeListener extends EventListener {
+
+    /**
+     * Handle the attribute added event.
+     *
+     * @param event the event.
+     */
+    default void attributeAdded(ServletRequestAttributeEvent event) {
+    }
+
+    /**
+     * Handle the attribute removed event.
+     *
+     * @param event the event.
+     */
+    default void attributeRemoved(ServletRequestAttributeEvent event) {
+    }
+
+    /**
+     * Handle the attribute replaced event.
+     *
+     * @param event the event.
+     */
+    default void attributeReplaced(ServletRequestAttributeEvent event) {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletRequestEvent.java b/servlet4/api/src/main/java/javax/servlet/ServletRequestEvent.java
new file mode 100644
index 00000000..0f0edfce
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletRequestEvent.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The ServletRequestEvent API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class ServletRequestEvent extends java.util.EventObject {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = -7467864054698729101L;
+
+    /**
+     * Stores the request.
+     */
+    private final ServletRequest servletRequest;
+
+    /**
+     * Constructor.
+     *
+     * @param servletContext the servlet context.
+     * @param servletRequest the servlet request.
+     */
+    public ServletRequestEvent(ServletContext servletContext, ServletRequest servletRequest) {
+        super(servletContext);
+        this.servletRequest = servletRequest;
+    }
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    public ServletContext getServletContext() {
+        return (ServletContext) super.getSource();
+    }
+
+    /**
+     * Get the servlet request.
+     *
+     * @return the servlet request.
+     */
+    public ServletRequest getServletRequest() {
+        return this.servletRequest;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletRequestListener.java b/servlet4/api/src/main/java/javax/servlet/ServletRequestListener.java
new file mode 100644
index 00000000..b7a4944d
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletRequestListener.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.EventListener;
+
+/**
+ * The ServletRequestListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletRequestListener extends EventListener {
+
+    /**
+     * Handle the request destroyed event.
+     *
+     * @param event the event.
+     */
+    default void requestDestroyed(ServletRequestEvent event) {
+    }
+
+    /**
+     * Handle the request initialized event.
+     *
+     * @param event the event.
+     */
+    default void requestInitialized(ServletRequestEvent event) {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletRequestWrapper.java b/servlet4/api/src/main/java/javax/servlet/ServletRequestWrapper.java
new file mode 100644
index 00000000..d12a3d92
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletRequestWrapper.java
@@ -0,0 +1,495 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.util.Enumeration;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * The ServletRequestWrapper API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class ServletRequestWrapper implements ServletRequest {
+
+    /**
+     * Stores the wrapped request.
+     */
+    private ServletRequest wrapped;
+
+    /**
+     * Constructor.
+     *
+     * @param wrapped the wrapped request.
+     */
+    public ServletRequestWrapper(ServletRequest wrapped) {
+        this.wrapped = wrapped;
+    }
+
+    /**
+     * Get the async context.
+     *
+     * @return the async context.
+     */
+    @Override
+    public AsyncContext getAsyncContext() {
+        return wrapped.getAsyncContext();
+    }
+
+    /**
+     * Get the attribute.
+     *
+     * @param name the name.
+     * @return the value.
+     */
+    @Override
+    public Object getAttribute(String name) {
+        return wrapped.getAttribute(name);
+    }
+
+    /**
+     * Get the attribute names.
+     *
+     * @return the attribute names.
+     */
+    @Override
+    public Enumeration<String> getAttributeNames() {
+        return wrapped.getAttributeNames();
+    }
+
+    /**
+     * Get the character encoding.
+     *
+     * @return the character encoding.
+     */
+    @Override
+    public String getCharacterEncoding() {
+        return wrapped.getCharacterEncoding();
+    }
+
+    /**
+     * Get the content length.
+     *
+     * @return the content length.
+     */
+    @Override
+    public int getContentLength() {
+        return wrapped.getContentLength();
+    }
+
+    /**
+     * Get the content length.
+     *
+     * @return the content length.
+     */
+    @Override
+    public long getContentLengthLong() {
+        return wrapped.getContentLengthLong();
+    }
+
+    /**
+     * Get the content type.
+     *
+     * @return the content type.
+     */
+    @Override
+    public String getContentType() {
+        return wrapped.getContentType();
+    }
+
+    /**
+     * Get the dispatcher type.
+     */
+    @Override
+    public DispatcherType getDispatcherType() {
+        return wrapped.getDispatcherType();
+    }
+
+    /**
+     * Get the input stream.
+     *
+     * @return the input stream.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public ServletInputStream getInputStream() throws IOException {
+        return wrapped.getInputStream();
+    }
+
+    /**
+     * Get the local address.
+     *
+     * @return the local address.
+     */
+    @Override
+    public String getLocalAddr() {
+        return wrapped.getLocalAddr();
+    }
+
+    /**
+     * Get the local name.
+     *
+     * @return the local name.
+     */
+    @Override
+    public String getLocalName() {
+        return wrapped.getLocalName();
+    }
+
+    /**
+     * Get the local port.
+     *
+     * @return the local port.
+     */
+    @Override
+    public int getLocalPort() {
+        return wrapped.getLocalPort();
+    }
+
+    /**
+     * Get the locale.
+     *
+     * @return the locale.
+     */
+    @Override
+    public Locale getLocale() {
+        return wrapped.getLocale();
+    }
+
+    /**
+     * Get the locales.
+     *
+     * @return the locales.
+     */
+    @Override
+    public Enumeration<Locale> getLocales() {
+        return wrapped.getLocales();
+    }
+
+    /**
+     * Get the parameter.
+     *
+     * @param name the name.
+     * @return the value, or null if not found.
+     */
+    @Override
+    public String getParameter(String name) {
+        return wrapped.getParameter(name);
+    }
+
+    /**
+     * Get the parameter map.
+     *
+     * @return the parameter map.
+     */
+    @Override
+    public Map<String, String[]> getParameterMap() {
+        return wrapped.getParameterMap();
+    }
+
+    /**
+     * Get the parameter names.
+     *
+     * @return the parameter names.
+     */
+    @Override
+    public Enumeration<String> getParameterNames() {
+        return wrapped.getParameterNames();
+    }
+
+    /**
+     * Get the parameter values.
+     *
+     * @param name the name.
+     * @return the values.
+     */
+    @Override
+    public String[] getParameterValues(String name) {
+        return wrapped.getParameterValues(name);
+    }
+
+    /**
+     * Get the protocol.
+     *
+     * @return the protocol.
+     */
+    @Override
+    public String getProtocol() {
+        return wrapped.getProtocol();
+    }
+
+    /**
+     * Get the reader.
+     *
+     * @return the reader.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public BufferedReader getReader() throws IOException {
+        return wrapped.getReader();
+    }
+
+    /**
+     * Get the real path.
+     *
+     * @param path the path.
+     * @return the real path.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public String getRealPath(String path) {
+        return wrapped.getRealPath(path);
+    }
+
+    /**
+     * Get the remote address.
+     *
+     * @return the remote address.
+     */
+    @Override
+    public String getRemoteAddr() {
+        return wrapped.getRemoteAddr();
+    }
+
+    /**
+     * Get the remote host.
+     *
+     * @return the remote host.
+     */
+    @Override
+    public String getRemoteHost() {
+        return wrapped.getRemoteHost();
+    }
+
+    /**
+     * Get the remote port.
+     *
+     * @return the remote port.
+     */
+    @Override
+    public int getRemotePort() {
+        return wrapped.getRemotePort();
+    }
+
+    /**
+     * Get the wrapped request.
+     *
+     * @return the wrapped request.
+     */
+    public ServletRequest getRequest() {
+        return wrapped;
+    }
+
+    /**
+     * Get the request dispatcher.
+     *
+     * @param path the path.
+     * @return the request dispatcher.
+     */
+    @Override
+    public RequestDispatcher getRequestDispatcher(String path) {
+        return wrapped.getRequestDispatcher(path);
+    }
+
+    /**
+     * Get the scheme.
+     *
+     * @return the scheme.
+     */
+    @Override
+    public String getScheme() {
+        return wrapped.getScheme();
+    }
+
+    /**
+     * Get the server name.
+     *
+     * @return the server name.
+     */
+    @Override
+    public String getServerName() {
+        return wrapped.getServerName();
+    }
+
+    /**
+     * Get the server port.
+     *
+     * @return the server port.
+     */
+    @Override
+    public int getServerPort() {
+        return wrapped.getServerPort();
+    }
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    @Override
+    public ServletContext getServletContext() {
+        return wrapped.getServletContext();
+    }
+
+    /**
+     * Is async started.
+     *
+     * @return true if async started, false otherwise.
+     */
+    @Override
+    public boolean isAsyncStarted() {
+        return wrapped.isAsyncStarted();
+    }
+
+    /**
+     * Is async supported.
+     *
+     * @return true if async is supported, false otherwise.
+     */
+    @Override
+    public boolean isAsyncSupported() {
+        return wrapped.isAsyncSupported();
+    }
+
+    /**
+     * Is secure.
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isSecure() {
+        return wrapped.isSecure();
+    }
+
+    /**
+     * Is this a wrapper for the given request.
+     *
+     * @param wrapped the wrapped request.
+     * @return true if it is, false otherwise.
+     */
+    public boolean isWrapperFor(ServletRequest wrapped) {
+        if (this.wrapped == wrapped) {
+            return true;
+        } else if (this.wrapped instanceof ServletRequestWrapper) {
+            return ((ServletRequestWrapper) this.wrapped).isWrapperFor(wrapped);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Are we a wrapper for the given type.
+     *
+     * @param wrappedType the wrapped type.
+     * @return true if we are, false otherwise.
+     */
+    public boolean isWrapperFor(Class<?> wrappedType) {
+        if (!ServletRequest.class.isAssignableFrom(wrappedType)) {
+            throw new IllegalArgumentException("Given class "
+                    + wrappedType.getName() + " not a subinterface of "
+                    + ServletRequest.class.getName());
+        }
+        if (wrappedType.isAssignableFrom(wrapped.getClass())) {
+            return true;
+        } else if (wrapped instanceof ServletRequestWrapper) {
+            return ((ServletRequestWrapper) wrapped).isWrapperFor(wrappedType);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Remove the attribute.
+     *
+     * @param name the name.
+     */
+    @Override
+    public void removeAttribute(String name) {
+        wrapped.removeAttribute(name);
+    }
+
+    /**
+     * Set the attribute.
+     *
+     * @param name the name.
+     * @param object the object value.
+     */
+    @Override
+    public void setAttribute(String name, Object object) {
+        wrapped.setAttribute(name, object);
+    }
+
+    /**
+     * Set the character encoding.
+     *
+     * @param characterEncoding the character encoding.
+     * @throws UnsupportedEncodingException when trying to set an unsupported
+     * character encoding.
+     */
+    @Override
+    public void setCharacterEncoding(String characterEncoding) throws UnsupportedEncodingException {
+        wrapped.setCharacterEncoding(characterEncoding);
+    }
+
+    /**
+     * Set the wrapped request.
+     *
+     * @param wrapped the wrapped request.
+     */
+    public void setRequest(ServletRequest wrapped) {
+        if (wrapped == null)
+            throw new IllegalArgumentException("Request cannot be null");
+        this.wrapped = wrapped;
+    }
+
+    /**
+     * Start async processing.
+     *
+     * @throws IllegalStateException when not allowed.
+     */
+    @Override
+    public AsyncContext startAsync() throws IllegalStateException {
+        return wrapped.startAsync();
+    }
+
+    /**
+     * Start async processing.
+     *
+     * @param servletRequest the servlet request.
+     * @param servletResponse the servlet response.
+     */
+    @Override
+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) throws IllegalStateException {
+        return wrapped.startAsync(servletRequest, servletResponse);
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletResponse.java b/servlet4/api/src/main/java/javax/servlet/ServletResponse.java
new file mode 100644
index 00000000..da1373e0
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletResponse.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Locale;
+
+/**
+ * The ServletResponse API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletResponse {
+
+    /**
+     * Flush the buffer.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    public void flushBuffer() throws IOException;
+
+    /**
+     * Get the buffer size.
+     *
+     * @return the buffer size.
+     */
+    public int getBufferSize();
+
+    /**
+     * Get the character encoding.
+     *
+     * @return the character encoding.
+     */
+    public String getCharacterEncoding();
+
+    /**
+     * Get the content type.
+     *
+     * @return the content type.
+     */
+    public String getContentType();
+
+    /**
+     * Get the locale.
+     *
+     * @return the locale.
+     */
+    public Locale getLocale();
+
+    /**
+     * Get the output stream.
+     *
+     * @return the output stream.
+     * @throws IOException when an I/O error occurs.
+     */
+    public ServletOutputStream getOutputStream() throws IOException;
+
+    /**
+     * Get the writer.
+     *
+     * @return the writer.
+     * @throws IOException when an I/O error occurs.
+     */
+    public PrintWriter getWriter() throws IOException;
+
+    /**
+     * Is committed.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isCommitted();
+
+    /**
+     * Reset.
+     */
+    public void reset();
+
+    /**
+     * Reset the buffer.
+     */
+    public void resetBuffer();
+
+    /**
+     * Set the buffer size.
+     *
+     * @param bufferSize the buffer size.
+     */
+    public void setBufferSize(int bufferSize);
+
+    /**
+     * Set the character encoding.
+     *
+     * @param characterEncoding the character encoding.
+     */
+    public void setCharacterEncoding(String characterEncoding);
+
+    /**
+     * Set the content length.
+     *
+     * @param contentLength the content length.
+     */
+    public void setContentLength(int contentLength);
+
+    /**
+     * Set the content length.
+     *
+     * @param contentLength the content length.
+     */
+    public void setContentLengthLong(long contentLength);
+
+    /**
+     * Set the content type.
+     *
+     * @param contentType the content type.
+     */
+    public void setContentType(String contentType);
+
+    /**
+     * Set the locale.
+     *
+     * @param locale the locale.
+     */
+    public void setLocale(Locale locale);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletResponseWrapper.java b/servlet4/api/src/main/java/javax/servlet/ServletResponseWrapper.java
new file mode 100644
index 00000000..f99cdb49
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletResponseWrapper.java
@@ -0,0 +1,264 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Locale;
+
+/**
+ * The ServletResponseWrapper API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class ServletResponseWrapper implements ServletResponse {
+
+    /**
+     * Stores the wrapped response.
+     */
+    private ServletResponse wrapped;
+
+    /**
+     * Constructor.
+     *
+     * @param wrapped the wrapped response.
+     */
+    public ServletResponseWrapper(ServletResponse wrapped) {
+        this.wrapped = wrapped;
+    }
+
+    /**
+     * Flush the buffer.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public void flushBuffer() throws IOException {
+        wrapped.flushBuffer();
+    }
+
+    /**
+     * Get the buffer size.
+     *
+     * @return the buffer size.
+     */
+    @Override
+    public int getBufferSize() {
+        return wrapped.getBufferSize();
+    }
+
+    /**
+     * Get the character encoding.
+     *
+     * @return the character encoding.
+     */
+    @Override
+    public String getCharacterEncoding() {
+        return wrapped.getCharacterEncoding();
+    }
+
+    /**
+     * Get the content type.
+     *
+     * @return the content type.
+     */
+    @Override
+    public String getContentType() {
+        return this.wrapped.getContentType();
+    }
+
+    /**
+     * Get the locale.
+     *
+     * @return the locale.
+     */
+    @Override
+    public Locale getLocale() {
+        return wrapped.getLocale();
+    }
+
+    /**
+     * Get the output stream.
+     *
+     * @return the output stream.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public ServletOutputStream getOutputStream() throws IOException {
+        return wrapped.getOutputStream();
+    }
+
+    /**
+     * Get the wrapped response.
+     *
+     * @return the wrapped response.
+     */
+    public ServletResponse getResponse() {
+        return wrapped;
+    }
+
+    /**
+     * Get the writer.
+     *
+     * @return the writer.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public PrintWriter getWriter() throws IOException {
+        return wrapped.getWriter();
+    }
+
+    /**
+     * Is committed.
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isCommitted() {
+        return wrapped.isCommitted();
+    }
+
+    /**
+     * Is wrapper for.
+     *
+     * @param wrapped the wrapped response.
+     * @return true if we wrap it, false otherwise.
+     */
+    public boolean isWrapperFor(ServletResponse wrapped) {
+        if (this.wrapped == wrapped) {
+            return true;
+        } else if (this.wrapped instanceof ServletResponseWrapper) {
+            return ((ServletResponseWrapper) this.wrapped).isWrapperFor(wrapped);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Is wrapper for.
+     *
+     * @param wrappedType the wrapped type.
+     * @return true if we wrap it, false otherwise.
+     */
+    public boolean isWrapperFor(Class<?> wrappedType) {
+        if (wrappedType.isAssignableFrom(wrapped.getClass())) {
+            return true;
+        } else if (wrapped instanceof ServletResponseWrapper) {
+            return ((ServletResponseWrapper) wrapped).isWrapperFor(wrappedType);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Reset.
+     */
+    @Override
+    public void reset() {
+        wrapped.reset();
+    }
+
+    /**
+     * Reset the buffer.
+     */
+    @Override
+    public void resetBuffer() {
+        wrapped.resetBuffer();
+    }
+
+    /**
+     * Set the buffer size.
+     *
+     * @param bufferSize the buffer size.
+     */
+    @Override
+    public void setBufferSize(int bufferSize) {
+        wrapped.setBufferSize(bufferSize);
+    }
+
+    /**
+     * Set the character encoding.
+     *
+     * @param characterEncoding the character encoding.
+     */
+    @Override
+    public void setCharacterEncoding(String characterEncoding) {
+        wrapped.setCharacterEncoding(characterEncoding);
+    }
+
+    /**
+     * Set the content length.
+     *
+     * @param contentLength the content length.
+     */
+    @Override
+    public void setContentLength(int contentLength) {
+        this.wrapped.setContentLength(contentLength);
+    }
+
+    /**
+     * Set the content length.
+     *
+     * @param contentLength the content length.
+     */
+    @Override
+    public void setContentLengthLong(long contentLength) {
+        wrapped.setContentLengthLong(contentLength);
+    }
+
+    /**
+     * Set the content type.
+     *
+     * @param contentType the content type.
+     */
+    @Override
+    public void setContentType(String contentType) {
+        wrapped.setContentType(contentType);
+    }
+
+    /**
+     * Set the locale.
+     *
+     * @param locale the locale.
+     */
+    @Override
+    public void setLocale(Locale locale) {
+        wrapped.setLocale(locale);
+    }
+
+    /**
+     * Set the wrapped response.
+     *
+     * @param wrapped the wrapped response.
+     */
+    public void setResponse(ServletResponse wrapped) {
+        if (wrapped == null)
+            throw new IllegalArgumentException("Response cannot be null");
+        this.wrapped = wrapped;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/ServletSecurityElement.java b/servlet4/api/src/main/java/javax/servlet/ServletSecurityElement.java
new file mode 100644
index 00000000..d8b64a82
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/ServletSecurityElement.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import javax.servlet.annotation.HttpMethodConstraint;
+import javax.servlet.annotation.ServletSecurity;
+
+/**
+ * The ServletSecurityElement API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class ServletSecurityElement extends HttpConstraintElement {
+
+    /**
+     * Stores the method constraints.
+     */
+    private final Collection<HttpMethodConstraintElement> methodConstraints;
+
+    /**
+     * Stores the method names.
+     */
+    private final Collection<String> methodNames;
+
+    /**
+     * Constructor.
+     */
+    public ServletSecurityElement() {
+        super();
+        methodConstraints = new HashSet<>();
+        methodNames = Collections.emptySet();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param constraint the constraint.
+     */
+    public ServletSecurityElement(HttpConstraintElement constraint) {
+        super(constraint.getEmptyRoleSemantic(), constraint.getTransportGuarantee(), constraint.getRolesAllowed());
+        methodConstraints = new HashSet<>();
+        methodNames = Collections.emptySet();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param methodConstraints the method constraints.
+     */
+    public ServletSecurityElement(Collection<HttpMethodConstraintElement> methodConstraints) {
+        this.methodConstraints = methodConstraints;
+        this.methodNames = collectMethodNames(this.methodConstraints);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param constraint the constraint.
+     * @param methodConstraints the method constraints.
+     */
+    public ServletSecurityElement(HttpConstraintElement constraint, Collection<HttpMethodConstraintElement> methodConstraints) {
+        super(constraint.getEmptyRoleSemantic(), constraint.getTransportGuarantee(), constraint.getRolesAllowed());
+        this.methodConstraints = methodConstraints;
+        methodNames = collectMethodNames(this.methodConstraints);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param annotation the annotation.
+     */
+    public ServletSecurityElement(ServletSecurity annotation) {
+        super(annotation.value().value(), annotation.value().transportGuarantee(), annotation.value().rolesAllowed());
+        this.methodConstraints = new HashSet<>();
+        for (HttpMethodConstraint constraint : annotation.httpMethodConstraints()) {
+            this.methodConstraints.add(new HttpMethodConstraintElement(constraint.value(),
+                    new HttpConstraintElement(constraint.emptyRoleSemantic(),
+                            constraint.transportGuarantee(),
+                            constraint.rolesAllowed())));
+        }
+        methodNames = collectMethodNames(methodConstraints);
+    }
+
+    /**
+     * Collect the method names.
+     *
+     * @param methodConstraints the method constraints.
+     * @return the method names.
+     */
+    private Collection<String> collectMethodNames(Collection<HttpMethodConstraintElement> methodConstraints) {
+        Collection<String> result = new HashSet<>();
+        for (HttpMethodConstraintElement methodConstraint : methodConstraints) {
+            String methodName = methodConstraint.getMethodName();
+            if (!result.add(methodName)) {
+                throw new IllegalArgumentException("Duplicate HTTP method name: " + methodName);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Get the HTTP method constraints.
+     *
+     * @return the HTTP method constraints.
+     */
+    public Collection<HttpMethodConstraintElement> getHttpMethodConstraints() {
+        return Collections.unmodifiableCollection(methodConstraints);
+    }
+
+    /**
+     * Get the method names.
+     *
+     * @return the method names.
+     */
+    public Collection<String> getMethodNames() {
+        return Collections.unmodifiableCollection(methodNames);
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/SessionCookieConfig.java b/servlet4/api/src/main/java/javax/servlet/SessionCookieConfig.java
new file mode 100644
index 00000000..1ad5def4
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/SessionCookieConfig.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The SessionCookieConfig API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface SessionCookieConfig {
+
+    /**
+     * Get the comment.
+     *
+     * @return the comment.
+     */
+    public String getComment();
+
+    /**
+     * Get the domain.
+     *
+     * @return the domain.
+     */
+    public String getDomain();
+
+    /**
+     * Get the max age.
+     *
+     * @return the max age.
+     */
+    public int getMaxAge();
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName();
+
+    /**
+     * Get the path.
+     *
+     * @return the path.
+     */
+    public String getPath();
+
+    /**
+     * Is HTTP-only.
+     *
+     * @return true if it is HTTP-only, false otherwise.
+     */
+    public boolean isHttpOnly();
+
+    /**
+     * Is secure.
+     *
+     * @return true if it is secure, false otherwise.
+     */
+    public boolean isSecure();
+
+    /**
+     * Set the comment.
+     *
+     * @param comment the comment.
+     */
+    public void setComment(String comment);
+
+    /**
+     * Set the domain.
+     *
+     * @param domain the domain.
+     */
+    public void setDomain(String domain);
+
+    /**
+     * Set the HTTP-only flag.
+     *
+     * @param httpOnly the HTTP-only flag.
+     */
+    public void setHttpOnly(boolean httpOnly);
+
+    /**
+     * Set the max age.
+     *
+     * @param maxAge the max age.
+     */
+    public void setMaxAge(int maxAge);
+
+    /**
+     * Set the name.
+     *
+     * @param name the name.
+     */
+    public void setName(String name);
+
+    /**
+     * Set the path.
+     *
+     * @param path the path.
+     */
+    public void setPath(String path);
+
+    /**
+     * Set the secure flag.
+     *
+     * @param secure the secure flag.
+     */
+    public void setSecure(boolean secure);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/SessionTrackingMode.java b/servlet4/api/src/main/java/javax/servlet/SessionTrackingMode.java
new file mode 100644
index 00000000..c7198a24
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/SessionTrackingMode.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The SessionTrackingMode API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public enum SessionTrackingMode {
+    
+    /**
+     * The session tracking mode using a cookie.
+     */
+    COOKIE,
+    
+    /**
+     * The session tracking mode using the URL.
+     */
+    URL,
+    
+    /**
+     * The session tracking mode using SSL.
+     */
+    SSL
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/SingleThreadModel.java b/servlet4/api/src/main/java/javax/servlet/SingleThreadModel.java
new file mode 100644
index 00000000..123601b8
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/SingleThreadModel.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The SingleThreadModel API
+ * 
+ * @deprecated
+ */
+@Deprecated
+public interface SingleThreadModel {
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/UnavailableException.java b/servlet4/api/src/main/java/javax/servlet/UnavailableException.java
new file mode 100644
index 00000000..d2c03c65
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/UnavailableException.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+/**
+ * The UnavailableException API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class UnavailableException extends ServletException {
+
+    /**
+     * Stores the permanent flag.
+     */
+    private final boolean permanent;
+
+    /**
+     * Stores the number of seconds.
+     */
+    private final int unavailableSeconds;
+
+    /**
+     * Constructor.
+     *
+     * @param message the message.
+     */
+    public UnavailableException(String message) {
+        super(message);
+        this.permanent = true;
+        this.unavailableSeconds = -1;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param message the message.
+     * @param unavailableSeconds the unavailable seconds.
+     */
+    public UnavailableException(String message, int unavailableSeconds) {
+        super(message);
+        this.permanent = false;
+        this.unavailableSeconds = unavailableSeconds;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param servlet the servlet.
+     * @param message the message.
+     * @deprecated
+     */
+    @Deprecated
+    public UnavailableException(Servlet servlet, String message) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param unavailableSeconds the unavailable seconds.
+     * @param servlet the servlet.
+     * @param message the message.
+     * @deprecated
+     */
+    @Deprecated
+    public UnavailableException(int unavailableSeconds, Servlet servlet, String message) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Get the servlet.
+     *
+     * @return the servlet
+     * @deprecated
+     */
+    @Deprecated
+    public Servlet getServlet() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Get the unavailableSeconds.
+     *
+     * @return the unavailable seconds.
+     */
+    public int getUnavailableSeconds() {
+        return unavailableSeconds;
+    }
+
+    /**
+     * Is unavailability permanent.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isPermanent() {
+        return permanent;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/WriteListener.java b/servlet4/api/src/main/java/javax/servlet/WriteListener.java
new file mode 100644
index 00000000..0fd09aa7
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/WriteListener.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet;
+
+import java.io.IOException;
+import java.util.EventListener;
+
+/**
+ * The WriteListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WriteListener extends EventListener {
+
+    /**
+     * Called when an error is detected.
+     *
+     * @param throwable the throwable.
+     */
+    public void onError(final Throwable throwable);
+
+    /**
+     * Called when a write is possible.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    public void onWritePossible() throws IOException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/HandlesTypes.java b/servlet4/api/src/main/java/javax/servlet/annotation/HandlesTypes.java
new file mode 100644
index 00000000..dc80cd07
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/HandlesTypes.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The HandlesTypes API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface HandlesTypes {
+
+    /**
+     * Get the classes.
+     *
+     * @return the classes.
+     */
+    Class<?>[] value();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/HttpConstraint.java b/servlet4/api/src/main/java/javax/servlet/annotation/HttpConstraint.java
new file mode 100644
index 00000000..73e7fc82
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/HttpConstraint.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.servlet.annotation.ServletSecurity.EmptyRoleSemantic;
+import javax.servlet.annotation.ServletSecurity.TransportGuarantee;
+
+/**
+ * The HttpConstraint API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+public @interface HttpConstraint {
+
+    /**
+     * Get the roles allowed.
+     *
+     * @return the roles allowed.
+     */
+    String[] rolesAllowed() default {};
+
+    /**
+     * Get the TransportGuarantee.
+     *
+     * @return the TransportGuarantee.
+     */
+    TransportGuarantee transportGuarantee() default TransportGuarantee.NONE;
+
+    /**
+     * Get the EmptyRoleSemantic.
+     *
+     * @return the EmptyRoleSemantic.
+     */
+    EmptyRoleSemantic value() default EmptyRoleSemantic.PERMIT;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/HttpMethodConstraint.java b/servlet4/api/src/main/java/javax/servlet/annotation/HttpMethodConstraint.java
new file mode 100644
index 00000000..22c0aaaa
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/HttpMethodConstraint.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.servlet.annotation.ServletSecurity.EmptyRoleSemantic;
+import javax.servlet.annotation.ServletSecurity.TransportGuarantee;
+
+/**
+ * The HttpMethodConstraint API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+public @interface HttpMethodConstraint {
+
+    /**
+     * Get the EmptyRoleSemantic.
+     *
+     * @return the EmptyRoleSemantic.
+     */
+    EmptyRoleSemantic emptyRoleSemantic() default EmptyRoleSemantic.PERMIT;
+
+    /**
+     * Get the roles allowed.
+     *
+     * @return the roles allowed.
+     */
+    String[] rolesAllowed() default {};
+
+    /**
+     * Get the TransportGuarantee.
+     *
+     * @return the TransportGuarantee.
+     */
+    TransportGuarantee transportGuarantee() default TransportGuarantee.NONE;
+
+    /**
+     * Get the method name.
+     *
+     * @return the method name.
+     */
+    String value();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/MultipartConfig.java b/servlet4/api/src/main/java/javax/servlet/annotation/MultipartConfig.java
new file mode 100644
index 00000000..9b55763a
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/MultipartConfig.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The MultipartConfig API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface MultipartConfig {
+
+    /**
+     * Get the file size threshold.
+     *
+     * @return the file size threshold.
+     */
+    int fileSizeThreshold() default 0;
+
+    /**
+     * Get the storage location.
+     *
+     * @return the storage location.
+     */
+    String location() default "";
+
+    /**
+     * Get the maximum file size.
+     *
+     * @return the maximum file size, or -1 for unlimited.
+     */
+    long maxFileSize() default -1L;
+
+    /**
+     * Get the maximum POST body request size.
+     *
+     * @return the maximum POST body request size.
+     */
+    long maxRequestSize() default -1L;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/ServletSecurity.java b/servlet4/api/src/main/java/javax/servlet/annotation/ServletSecurity.java
new file mode 100644
index 00000000..e68ca1a4
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/ServletSecurity.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The ServletSecurity API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Inherited
+@Documented
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ServletSecurity {
+
+    /**
+     * Get the HTTP method constraints.
+     *
+     * @return the HTTP method constraints.
+     */
+    HttpMethodConstraint[] httpMethodConstraints() default {};
+
+    /**
+     * Get the HTTP constraint.
+     *
+     * @return the HTTP constraint.
+     */
+    HttpConstraint value() default @HttpConstraint;
+
+    /**
+     * The EmptyRoleSemantic API.
+     */
+    enum EmptyRoleSemantic {
+        /**
+         * Permit access for EmptyRole.
+         */
+        PERMIT,
+        /**
+         * Deny access for EmptyRole.
+         */
+        DENY
+    }
+
+    /**
+     * The TransportGuarantee API.
+     */
+    enum TransportGuarantee {
+        /**
+         * Transport is NOT encrypted.
+         */
+        NONE,
+        /**
+         * Transport is encrypted.
+         */
+        CONFIDENTIAL
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/WebFilter.java b/servlet4/api/src/main/java/javax/servlet/annotation/WebFilter.java
new file mode 100644
index 00000000..60fc410e
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/WebFilter.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import javax.servlet.DispatcherType;
+
+/**
+ * The WebFilter API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface WebFilter {
+
+    /**
+     * Get the async supported flag.
+     *
+     * @return the async supported flag.
+     */
+    boolean asyncSupported() default false;
+
+    /**
+     * Get the description.
+     *
+     * @return the description.
+     */
+    String description() default "";
+
+    /**
+     * Get the dispatcher types.
+     *
+     * @return the dispatcher type.s
+     */
+    DispatcherType[] dispatcherTypes() default {DispatcherType.REQUEST};
+
+    /**
+     * Get the display name.
+     *
+     * @return the display name.
+     */
+    String displayName() default "";
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    String filterName() default "";
+
+    /**
+     * Get the init parameters.
+     *
+     * @return the init parameters.
+     */
+    WebInitParam[] initParams() default {};
+
+    /**
+     * Get the large icon.
+     *
+     * @return the large icon.
+     */
+    String largeIcon() default "";
+
+    /**
+     * Get the servlet names.
+     *
+     * @return the servlet names.
+     */
+    String[] servletNames() default {};
+
+    /**
+     * Get the small icon.
+     *
+     * @return the small icon.
+     */
+    String smallIcon() default "";
+
+    /**
+     * Get the URL patterns.
+     *
+     * @return the URL patterns.
+     */
+    String[] urlPatterns() default {};
+
+    /**
+     * Get the URL patterns.
+     *
+     * @return the URL patterns.
+     */
+    String[] value() default {};
+
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/WebInitParam.java b/servlet4/api/src/main/java/javax/servlet/annotation/WebInitParam.java
new file mode 100644
index 00000000..316eb800
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/WebInitParam.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The WebInitParam API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface WebInitParam {
+
+    /**
+     * Get the description.
+     *
+     * @return the description.
+     */
+    String description() default "";
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    String name();
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    String value();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/WebListener.java b/servlet4/api/src/main/java/javax/servlet/annotation/WebListener.java
new file mode 100644
index 00000000..05bbca49
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/WebListener.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The WebListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface WebListener {
+
+    /**
+     * Get the description.
+     *
+     * @return the description.
+     */
+    String value() default "";
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/WebServlet.java b/servlet4/api/src/main/java/javax/servlet/annotation/WebServlet.java
new file mode 100644
index 00000000..1a79c2ac
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/WebServlet.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.annotation;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * The WebServlet API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@Target({ElementType.TYPE})
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface WebServlet {
+
+    /**
+     * Get asyns supported flag.
+     *
+     * @return the async supported flag.
+     */
+    boolean asyncSupported() default false;
+
+    /**
+     * Get the description.
+     *
+     * @return the description.
+     */
+    String description() default "";
+
+    /**
+     * Get the display name.
+     *
+     * @return the display name.
+     */
+    String displayName() default "";
+
+    /**
+     * Get the init parameters.
+     *
+     * @return the init parameters.
+     */
+    WebInitParam[] initParams() default {};
+
+    /**
+     * Get the large icon.
+     *
+     * @return the large icon.
+     */
+    String largeIcon() default "";
+
+    /**
+     * Get the load on startup order.
+     *
+     * @return the load on startup order.
+     */
+    int loadOnStartup() default -1;
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    String name() default "";
+
+    /**
+     * Get the small icon.
+     *
+     * @return the small icon.
+     */
+    String smallIcon() default "";
+
+    /**
+     * Get the URL patterns.
+     *
+     * @return the URL patterns.
+     */
+    String[] urlPatterns() default {};
+
+    /**
+     * Get the URL patterns.
+     *
+     * @return the URL patterns.
+     */
+    String[] value() default {};
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/annotation/package-info.java b/servlet4/api/src/main/java/javax/servlet/annotation/package-info.java
new file mode 100644
index 00000000..31b6d64c
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/annotation/package-info.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/**
+ * <p>
+ * The javax.servlet.annotation package delivers the annotation of the Servlet
+ * API.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+package javax.servlet.annotation;
diff --git a/servlet4/api/src/main/java/javax/servlet/descriptor/JspConfigDescriptor.java b/servlet4/api/src/main/java/javax/servlet/descriptor/JspConfigDescriptor.java
new file mode 100644
index 00000000..2ada8e31
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/descriptor/JspConfigDescriptor.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.descriptor;
+
+import java.util.Collection;
+
+/**
+ * The JspConfigDescriptor API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface JspConfigDescriptor {
+
+    /**
+     * Get the JSP property groups.
+     *
+     * @return the JSP property groups.
+     */
+    public Collection<JspPropertyGroupDescriptor> getJspPropertyGroups();
+
+    /**
+     * Get the taglibs.
+     *
+     * @return the taglibs.
+     */
+    public Collection<TaglibDescriptor> getTaglibs();
+
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/descriptor/JspPropertyGroupDescriptor.java b/servlet4/api/src/main/java/javax/servlet/descriptor/JspPropertyGroupDescriptor.java
new file mode 100644
index 00000000..a3425334
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/descriptor/JspPropertyGroupDescriptor.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.descriptor;
+
+import java.util.Collection;
+
+/**
+ * The JspPropertyGroupDescriptor API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface JspPropertyGroupDescriptor {
+
+    /**
+     * Get the default buffer size.
+     *
+     * @return the default buffer size.
+     */
+    public String getBuffer();
+
+    /**
+     * Get the default content type type.
+     *
+     * @return the default content type, or null if not specified.
+     */
+    public String getDefaultContentType();
+
+    /**
+     * Get deferred-syntax-allowed-as-literal config.
+     *
+     * @return the deferred-syntax-allowed-as-literal config.
+     */
+    public String getDeferredSyntaxAllowedAsLiteral();
+
+    /**
+     * Get the EL ignored config.
+     *
+     * @return the EL ignored config.
+     */
+    public String getElIgnored();
+
+    /**
+     * Get the error-on-undeclared-namespace config.
+     *
+     * @return the error-on-undeclared-namespace config.
+     */
+    public String getErrorOnUndeclaredNamespace();
+
+    /**
+     * Get the include-codes config.
+     *
+     * @return the include-codes config.
+     */
+    public Collection<String> getIncludeCodas();
+
+    /**
+     * Get the include-prelude config.
+     *
+     * @return the include-prelude config.
+     */
+    public Collection<String> getIncludePreludes();
+
+    /**
+     * Get the is-xml config.
+     *
+     * @return the is-xml config.
+     */
+    public String getIsXml();
+
+    /**
+     * Get the scripting invalid config.
+     *
+     * @return the scripting invalid config.
+     */
+    public String getScriptingInvalid();
+
+    /**
+     * Get the page encoding.
+     *
+     * @return the page encoding.
+     */
+    public String getPageEncoding();
+
+    /**
+     * Get the trim-directive-whitespaces config.
+     *
+     * @return the trim-directive-whitespaces config.
+     */
+    public String getTrimDirectiveWhitespaces();
+
+    /**
+     * Get the URL patterns.
+     *
+     * @return the URL patterns.
+     */
+    public Collection<String> getUrlPatterns();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/descriptor/TaglibDescriptor.java b/servlet4/api/src/main/java/javax/servlet/descriptor/TaglibDescriptor.java
new file mode 100644
index 00000000..28c79c99
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/descriptor/TaglibDescriptor.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.descriptor;
+
+/**
+ * The TagLibDescriptor API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface TaglibDescriptor {
+
+    /**
+     * Get the taglib location.
+     *
+     * @return the taglib location.
+     */
+    public String getTaglibLocation();
+
+    /**
+     * Get the taglib URI.
+     *
+     * @return the taglib URI.
+     */
+    public String getTaglibURI();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/descriptor/package-info.java b/servlet4/api/src/main/java/javax/servlet/descriptor/package-info.java
new file mode 100644
index 00000000..63adc995
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/descriptor/package-info.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/**
+ * <p>
+ * The javax.servlet.descriptor package delivers the descriptors for JSP.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+package javax.servlet.descriptor;
diff --git a/servlet4/api/src/main/java/javax/servlet/http/Cookie.java b/servlet4/api/src/main/java/javax/servlet/http/Cookie.java
new file mode 100644
index 00000000..70cc9c95
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/Cookie.java
@@ -0,0 +1,264 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.Serializable;
+
+/**
+ * The Cookie API.
+ */
+public class Cookie implements Cloneable, Serializable {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = -4779842497728237253L;
+
+    /**
+     * Stores the comment.
+     */
+    private String comment;
+
+    /**
+     * Stores the domain.
+     */
+    private String domain;
+
+    /**
+     * Stores the HTTP only flag.
+     */
+    private boolean httpOnly;
+
+    /**
+     * Stores the max age.
+     */
+    private int maxAge;
+
+    /**
+     * Stores the name.
+     */
+    private String name;
+
+    /**
+     * Stores the path.
+     */
+    private String path;
+
+    /**
+     * Stores the secure flag.
+     */
+    private boolean secure;
+
+    /**
+     * Stores the value.
+     */
+    private String value;
+
+    /**
+     * Stores the version.
+     */
+    private int version;
+
+    /**
+     * Constructor.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    public Cookie(String name, String value) {
+        this.name = name;
+        this.value = value;
+    }
+
+    /**
+     * Clones the cookie.
+     *
+     * @return the clone.
+     */
+    @Override
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException cnse) {
+            throw new RuntimeException(cnse);
+        }
+    }
+
+    /**
+     * Get the comment.
+     *
+     * @return the comment.
+     */
+    public String getComment() {
+        return comment;
+    }
+
+    /**
+     * Get the domain.
+     *
+     * @return the domain.
+     */
+    public String getDomain() {
+        return domain;
+    }
+
+    /**
+     * Get the max age.
+     *
+     * @return the max age.
+     */
+    public int getMaxAge() {
+        return maxAge;
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the path.
+     *
+     * @return the path.
+     */
+    public String getPath() {
+        return path;
+    }
+
+    /**
+     * Get the secure flag.
+     *
+     * @return the secure flag.
+     */
+    public boolean getSecure() {
+        return secure;
+    }
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    public String getValue() {
+        return value;
+    }
+
+    /**
+     * Get the version.
+     *
+     * @return the version.
+     */
+    public int getVersion() {
+        return version;
+    }
+
+    /**
+     * Is HTTP only.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isHttpOnly() {
+        return httpOnly;
+    }
+
+    /**
+     * Set the comment.
+     *
+     * @param comment the comment.
+     */
+    public void setComment(String comment) {
+        this.comment = comment;
+    }
+
+    /**
+     * Set the domain.
+     *
+     * @param domain the domain.
+     */
+    public void setDomain(String domain) {
+        this.domain = domain;
+    }
+
+    /**
+     * Set the HTTP only flag.
+     *
+     * @param httpOnly the HTTP only flag.
+     */
+    public void setHttpOnly(boolean httpOnly) {
+        this.httpOnly = httpOnly;
+    }
+
+    /**
+     * Set the max age.
+     *
+     * @param maxAge the max age.
+     */
+    public void setMaxAge(int maxAge) {
+        this.maxAge = maxAge;
+    }
+
+    /**
+     * Set the path.
+     *
+     * @param path the path.
+     */
+    public void setPath(String path) {
+        this.path = path;
+    }
+
+    /**
+     * Set the secure flag.
+     *
+     * @param secure the secure flag.
+     */
+    public void setSecure(boolean secure) {
+        this.secure = secure;
+    }
+
+    /**
+     * Set the value.
+     *
+     * @param value the value.
+     */
+    public void setValue(String value) {
+        this.value = value;
+    }
+
+    /**
+     * Set the version.
+     *
+     * @param version the version.
+     */
+    public void setVersion(int version) {
+        this.version = version;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpFilter.java b/servlet4/api/src/main/java/javax/servlet/http/HttpFilter.java
new file mode 100644
index 00000000..4998f102
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpFilter.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.IOException;
+import javax.servlet.FilterChain;
+import javax.servlet.GenericFilter;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * A HTTP filter.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public abstract class HttpFilter extends GenericFilter {
+
+    /**
+     * Process the filter.
+     * 
+     * @param request the request.
+     * @param response the response
+     * @param chain the filter chain
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
+            throws IOException, ServletException {
+        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {
+            HttpServletRequest httpServletRequest = (HttpServletRequest) request;
+            HttpServletResponse httpServletResponse = (HttpServletResponse) response;
+            this.doFilter(httpServletRequest, httpServletResponse, chain);
+        } else {
+            throw new ServletException("not a HTTP request or a HTTP response");
+        }
+
+    }
+
+    /**
+     * Process the filter.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @param chain the chain.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
+            throws IOException, ServletException {
+        chain.doFilter(request, response);
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpServlet.java b/servlet4/api/src/main/java/javax/servlet/http/HttpServlet.java
new file mode 100644
index 00000000..e238caa5
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpServlet.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.IOException;
+import javax.servlet.GenericServlet;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * The HttpServlet API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public abstract class HttpServlet extends GenericServlet {
+
+    /**
+     * Constructor.
+     */
+    public HttpServlet() {
+    }
+
+    /**
+     * Get the last modified header.
+     *
+     * @param request the request.
+     * @return the last modified, or -1 if not known.
+     */
+    protected long getLastModified(HttpServletRequest request) {
+        return -1;
+    }
+
+    /**
+     * Handle a DELETE request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+    }
+
+    /**
+     * Handle a GET request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+    }
+
+    /**
+     * Handle a HEAD request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    protected void doHead(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+    }
+
+    /**
+     * Handle a POST request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+    }
+
+    /**
+     * Handle a PUT request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+    }
+
+    /**
+     * Handle an OPTIONS request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    protected void doOptions(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+    }
+
+    /**
+     * Handle a TRACE request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    protected void doTrace(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+    }
+
+    /**
+     * Process the HTTP request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+        String method = request.getMethod();
+        switch (method) {
+            case "GET":
+                doGet(request, response);
+                break;
+            case "HEAD":
+                doHead(request, response);
+                break;
+            case "POST":
+                doPost(request, response);
+                break;
+            case "PUT":
+                doPut(request, response);
+                break;
+            case "DELETE":
+                doDelete(request, response);
+                break;
+            case "OPTIONS":
+                doOptions(request, response);
+                break;
+            case "TRACE":
+                doTrace(request, response);
+                break;
+            default:
+                response.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, "HTTP method not implemented");
+        }
+    }
+
+    /**
+     * Process the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void service(ServletRequest request, ServletResponse response) throws IOException, ServletException {
+        try {
+            service((HttpServletRequest) request, (HttpServletResponse) response);
+        } catch (ClassCastException cce) {
+            throw new ServletException("Either request or response is not HTTP based");
+        }
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpServletMapping.java b/servlet4/api/src/main/java/javax/servlet/http/HttpServletMapping.java
new file mode 100644
index 00000000..d737950d
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpServletMapping.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+/**
+ * The HTTP servlet mapping.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpServletMapping {
+   
+    /**
+     * Get the mapping match.
+     * 
+     * @return the mapping match.
+     */
+    MappingMatch getMappingMatch();
+    
+    /**
+     * Get the match value.
+     * 
+     * @return the match value.
+     */
+    String getMatchValue();
+    
+    /**
+     * Get the pattern.
+     * 
+     * @return the pattern.
+     */
+    String getPattern();
+    
+    /**
+     * Get the servlet name.
+     * 
+     * @return the servlet name.
+     */
+    String getServletName();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpServletRequest.java b/servlet4/api/src/main/java/javax/servlet/http/HttpServletRequest.java
new file mode 100644
index 00000000..ea463f78
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpServletRequest.java
@@ -0,0 +1,368 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.IOException;
+import java.security.Principal;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.Map;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+
+/**
+ * The HttpServletRequest API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpServletRequest extends ServletRequest {
+
+    /**
+     * Defines the BASIC_AUTH constant.
+     */
+    public static final String BASIC_AUTH = "BASIC";
+
+    /**
+     * Defines the CLIENT_CERT constant.
+     */
+    public static final String CLIENT_CERT_AUTH = "CLIENT_CERT";
+
+    /**
+     * Defines the DIGEST constant.
+     */
+    public static final String DIGEST_AUTH = "DIGEST";
+
+    /**
+     * Defines the FORM constant.
+     */
+    public static final String FORM_AUTH = "FORM";
+
+    /**
+     * Authenticate the request.
+     *
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     * @return true if authenticated, false otherwise.
+     */
+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException;
+
+    /**
+     * Change the session id.
+     *
+     * @return the new session id.
+     */
+    public String changeSessionId();
+
+    /**
+     * Get the auth type.
+     *
+     * @return the auth type.
+     */
+    public String getAuthType();
+
+    /**
+     * Get the context path.
+     *
+     * @return the context path.
+     */
+    public String getContextPath();
+
+    /**
+     * Get the cookies.
+     *
+     * @return the cookies, or null if none.
+     */
+    public Cookie[] getCookies();
+
+    /**
+     * Get the date header.
+     *
+     * @param name the name.
+     * @return the date, or -1 if not found.
+     */
+    public long getDateHeader(String name);
+
+    /**
+     * Get the header.
+     *
+     * @param name the name.
+     * @return the header, or null if not found.
+     */
+    public String getHeader(String name);
+
+    /**
+     * Get the headers.
+     *
+     * @param name the name.
+     * @return the headers.
+     */
+    public Enumeration<String> getHeaders(String name);
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    public Enumeration<String> getHeaderNames();
+
+    /**
+     * Get the HTTP servlet mapping.
+     *
+     * @return the HTTP servlet mapping.
+     */
+    default HttpServletMapping getHttpServletMapping() {
+        return new HttpServletMapping() {
+            @Override
+            public String getMatchValue() {
+                return "";
+            }
+
+            @Override
+            public String getPattern() {
+                return "";
+            }
+
+            @Override
+            public String getServletName() {
+                return "";
+            }
+
+            @Override
+            public MappingMatch getMappingMatch() {
+                return null;
+            }
+        };
+    }
+
+    /**
+     * Get the int header.
+     *
+     * @param name the name.
+     * @return the header, or -1 if not found.
+     */
+    public int getIntHeader(String name);
+
+    /**
+     * Get the HTTP method.
+     *
+     * @return the HTTP method.
+     */
+    public String getMethod();
+
+    /**
+     * Get the part.
+     *
+     * @param name the name.
+     * @return the part, or null if not found.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    public Part getPart(String name) throws IOException, ServletException;
+
+    /**
+     * Get the parts.
+     *
+     * @return the parts.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    public Collection<Part> getParts() throws IOException, ServletException;
+
+    /**
+     * Get the path info.
+     *
+     * @return the path info.
+     */
+    public String getPathInfo();
+
+    /**
+     * Get the path translated.
+     *
+     * @return the path translated.
+     */
+    public String getPathTranslated();
+
+    /**
+     * Get the query string.
+     *
+     * @return the query string, or null if not found.
+     */
+    public String getQueryString();
+
+    /**
+     * Get the remote user.
+     *
+     * @return the remote user, or null if not found.
+     */
+    public String getRemoteUser();
+
+    /**
+     * Get the request URI.
+     *
+     * @return the request URI.
+     */
+    public String getRequestURI();
+
+    /**
+     * Get the request URL.
+     *
+     * @return the request URL.
+     */
+    public StringBuffer getRequestURL();
+
+    /**
+     * Get the requested session id.
+     *
+     * @return the requested session id.
+     */
+    public String getRequestedSessionId();
+
+    /**
+     * Get the servlet path.
+     *
+     * @return the servlet path.
+     */
+    public String getServletPath();
+
+    /**
+     * Get the HTTP session.
+     *
+     * @param create the create flag.
+     * @return the HTTP session, or null if not found and create flag is false.
+     */
+    public HttpSession getSession(boolean create);
+
+    /**
+     * Get the HTTP session.
+     *
+     * @return the HTTP session.
+     */
+    public HttpSession getSession();
+
+    /**
+     * Get the trailer fields.
+     *
+     * @return the trailer fields.
+     */
+    default Map<String, String> getTrailerFields() {
+        return Collections.emptyMap();
+    }
+
+    /**
+     * Get the user principal.
+     *
+     * @return the user principal.
+     */
+    public Principal getUserPrincipal();
+
+    /**
+     * Is the requested session id from a cookie.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isRequestedSessionIdFromCookie();
+
+    /**
+     * Is the requested session id from a URL.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isRequestedSessionIdFromURL();
+
+    /**
+     * Is the requested session id from a URL.
+     *
+     * @return true if it is, false otherwise.
+     * @deprecated
+     */
+    @Deprecated
+    public boolean isRequestedSessionIdFromUrl();
+
+    /**
+     * Is the requested session id valid.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isRequestedSessionIdValid();
+
+    /**
+     * Is trailer fields ready.
+     *
+     * @return true if fields are ready, false otherwise.
+     */
+    default boolean isTrailerFieldsReady() {
+        return true;
+    }
+
+    /**
+     * Is the user in the specified role.
+     *
+     * @param role the role.
+     * @return true if the user is in the specified role, false otherwise.
+     */
+    public boolean isUserInRole(String role);
+
+    /**
+     * Login.
+     *
+     * @param username the username.
+     * @param password the password.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    public void login(String username, String password) throws ServletException;
+
+    /**
+     * Logout.
+     *
+     * @throws ServletException when a Servlet error occurs.
+     */
+    public void logout() throws ServletException;
+
+    /**
+     * Create a new push builder.
+     * 
+     * @return the push builder.
+     */
+    default PushBuilder newPushBuilder() {
+        return null;
+    }
+
+    /**
+     * Upgrade the request.
+     *
+     * @param <T> the type of HTTP upgrade handler.
+     * @param handlerClass the handler class.
+     * @return the HTTP upgrade handler.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     *
+     */
+    public <T extends HttpUpgradeHandler> T upgrade(Class<T> handlerClass) throws IOException, ServletException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpServletRequestWrapper.java b/servlet4/api/src/main/java/javax/servlet/http/HttpServletRequestWrapper.java
new file mode 100644
index 00000000..0a499118
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpServletRequestWrapper.java
@@ -0,0 +1,401 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.IOException;
+import java.security.Principal;
+import java.util.Collection;
+import java.util.Enumeration;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequestWrapper;
+
+/**
+ * The HttpServletRequestWrapper API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest {
+
+    /**
+     * Constructor.
+     *
+     * @param request the wrapped request.
+     */
+    public HttpServletRequestWrapper(HttpServletRequest request) {
+        super(request);
+    }
+
+    /**
+     * Authenticate the request.
+     *
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {
+        return getWrapped().authenticate(response);
+    }
+
+    /**
+     * Change the session id.
+     *
+     * @return the new session id.
+     */
+    @Override
+    public String changeSessionId() {
+        return getWrapped().changeSessionId();
+    }
+
+    /**
+     * Get the auth type.
+     *
+     * @return the auth type.
+     */
+    @Override
+    public String getAuthType() {
+        return getWrapped().getAuthType();
+    }
+
+    /**
+     * Get the context path.
+     *
+     * @return the context path.
+     */
+    @Override
+    public String getContextPath() {
+        return getWrapped().getContextPath();
+    }
+
+    /**
+     * Get the cookies.
+     *
+     * @return the cookies, or null if none.
+     */
+    @Override
+    public Cookie[] getCookies() {
+        return getWrapped().getCookies();
+    }
+
+    /**
+     * Get the date header.
+     *
+     * @param name the name.
+     * @return the date, or -1 if not found.
+     */
+    @Override
+    public long getDateHeader(String name) {
+        return getWrapped().getDateHeader(name);
+    }
+
+    /**
+     * Get the header.
+     *
+     * @param name the name.
+     * @return the value, or null if not found.
+     */
+    @Override
+    public String getHeader(String name) {
+        return getWrapped().getHeader(name);
+    }
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    @Override
+    public Enumeration<String> getHeaderNames() {
+        return getWrapped().getHeaderNames();
+    }
+
+    /**
+     * Get the headers.
+     *
+     * @param name the name.
+     * @return the values.
+     */
+    @Override
+    public Enumeration<String> getHeaders(String name) {
+        return getWrapped().getHeaders(name);
+    }
+
+    /**
+     * Get the int header.
+     *
+     * @param name the name.
+     * @return the int, or -1 if not found.
+     */
+    @Override
+    public int getIntHeader(String name) {
+        return getWrapped().getIntHeader(name);
+    }
+
+    /**
+     * Get the method.
+     *
+     * @return the method.
+     */
+    @Override
+    public String getMethod() {
+        return getWrapped().getMethod();
+    }
+
+    /**
+     * Get the part.
+     *
+     * @param name the name.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public Part getPart(String name) throws IOException, ServletException {
+        return getWrapped().getPart(name);
+    }
+
+    /**
+     * Get the parts.
+     *
+     * @return the parts.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public Collection<Part> getParts() throws IOException, ServletException {
+        return getWrapped().getParts();
+    }
+
+    /**
+     * Get the path info.
+     *
+     * @return the path info.
+     */
+    @Override
+    public String getPathInfo() {
+        return getWrapped().getPathInfo();
+    }
+
+    /**
+     * Get the path translated.
+     *
+     * @return the path translated.
+     */
+    @Override
+    public String getPathTranslated() {
+        return getWrapped().getPathTranslated();
+    }
+
+    /**
+     * Get the query string.
+     *
+     * @return the query string.
+     */
+    @Override
+    public String getQueryString() {
+        return getWrapped().getQueryString();
+    }
+
+    /**
+     * Get the remote user.
+     *
+     * @return the remote user.
+     */
+    @Override
+    public String getRemoteUser() {
+        return getWrapped().getRemoteUser();
+    }
+
+    /**
+     * Get the request URI.
+     *
+     * @return the request URI.
+     */
+    @Override
+    public String getRequestURI() {
+        return getWrapped().getRequestURI();
+    }
+
+    /**
+     * Get the request URL.
+     *
+     * @return the request URL.
+     */
+    @Override
+    public StringBuffer getRequestURL() {
+        return getWrapped().getRequestURL();
+    }
+
+    /**
+     * Get the requested session id.
+     *
+     * @return the requested session id.
+     */
+    @Override
+    public String getRequestedSessionId() {
+        return getWrapped().getRequestedSessionId();
+    }
+
+    /**
+     * Get the servlet path.
+     *
+     * @return the servlet path.
+     */
+    @Override
+    public String getServletPath() {
+        return getWrapped().getServletPath();
+    }
+
+    /**
+     * Get the HTTP session.
+     *
+     * @return the HTTP session.
+     */
+    @Override
+    public HttpSession getSession() {
+        return getWrapped().getSession();
+    }
+
+    /**
+     * Get the HTTP session.
+     *
+     * @param create the create flag.
+     * @return the HTTP session, or null if not able to create.
+     */
+    @Override
+    public HttpSession getSession(boolean create) {
+        return getWrapped().getSession(create);
+    }
+
+    /**
+     * Get the user principal.
+     *
+     * @return the user principal.
+     */
+    @Override
+    public Principal getUserPrincipal() {
+        return getWrapped().getUserPrincipal();
+    }
+
+    /**
+     * Get the wrapped request.
+     *
+     * @return the wrapped request.
+     */
+    private HttpServletRequest getWrapped() {
+        return (HttpServletRequest) super.getRequest();
+    }
+
+    /**
+     * Is the requested session id from a cookie.
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isRequestedSessionIdFromCookie() {
+        return getWrapped().isRequestedSessionIdFromCookie();
+    }
+
+    /**
+     * Is the requested session id from a URL.
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isRequestedSessionIdFromURL() {
+        return getWrapped().isRequestedSessionIdFromURL();
+    }
+
+    /**
+     * Is the requested session if from a URL.
+     *
+     * @return true if it is, false otherwise.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public boolean isRequestedSessionIdFromUrl() {
+        return getWrapped().isRequestedSessionIdFromUrl();
+    }
+
+    /**
+     * Is the requested session id valid.
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isRequestedSessionIdValid() {
+        return getWrapped().isRequestedSessionIdValid();
+    }
+
+    /**
+     * Is the user in the role.
+     *
+     * @param role the role.
+     * @return true if the user is, false otherwise.
+     */
+    @Override
+    public boolean isUserInRole(String role) {
+        return getWrapped().isUserInRole(role);
+    }
+
+    /**
+     * Login.
+     *
+     * @param username the username.
+     * @param password the password.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void login(String username, String password) throws ServletException {
+        getWrapped().login(username, password);
+    }
+
+    /**
+     * Logout.
+     *
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void logout() throws ServletException {
+        getWrapped().logout();
+    }
+
+    /**
+     * Upgrade the request.
+     *
+     * @param <T> the type of HTTP upgrade handler class.
+     * @param handlerClass the handler class.
+     * @return the HTTP upgrade handler.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public <T extends HttpUpgradeHandler> T upgrade(Class<T> handlerClass) throws IOException, ServletException {
+        return getWrapped().upgrade(handlerClass);
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpServletResponse.java b/servlet4/api/src/main/java/javax/servlet/http/HttpServletResponse.java
new file mode 100644
index 00000000..e35fe472
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpServletResponse.java
@@ -0,0 +1,435 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Map;
+import java.util.function.Supplier;
+import javax.servlet.ServletResponse;
+
+/**
+ * The HttpServletResponse API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpServletResponse extends ServletResponse {
+
+    /**
+     * Defines the 100 status code.
+     */
+    public static final int SC_CONTINUE = 100;
+
+    /**
+     * Defines the 101 status code.
+     */
+    public static final int SC_SWITCHING_PROTOCOLS = 101;
+
+    /**
+     * Defines the 200 status code.
+     */
+    public static final int SC_OK = 200;
+
+    /**
+     * Defines the 201 status code.
+     */
+    public static final int SC_CREATED = 201;
+
+    /**
+     * Defines the 202 status code.
+     */
+    public static final int SC_ACCEPTED = 202;
+
+    /**
+     * Defines the 203 status code.
+     */
+    public static final int SC_NON_AUTHORITATIVE_INFORMATION = 203;
+
+    /**
+     * Defines the 204 status code.
+     */
+    public static final int SC_NO_CONTENT = 204;
+
+    /**
+     * Defines the 205 status code.
+     */
+    public static final int SC_RESET_CONTENT = 205;
+
+    /**
+     * Defines the 206 status code.
+     */
+    public static final int SC_PARTIAL_CONTENT = 206;
+
+    /**
+     * Defines the 300 status code.
+     */
+    public static final int SC_MULTIPLE_CHOICES = 300;
+
+    /**
+     * Defines the 301 status code.
+     */
+    public static final int SC_MOVED_PERMANENTLY = 301;
+
+    /**
+     * Defines the 302 status code.
+     */
+    public static final int SC_MOVED_TEMPORARILY = 302;
+
+    /**
+     * Defines the 302 status code (recommended variant).
+     */
+    public static final int SC_FOUND = 302;
+
+    /**
+     * Defines the 303 status code.
+     */
+    public static final int SC_SEE_OTHER = 303;
+
+    /**
+     * Defines the 305 status code.
+     */
+    public static final int SC_NOT_MODIFIED = 304;
+
+    /**
+     * Defines the 305 status code.
+     */
+    public static final int SC_USE_PROXY = 305;
+
+    /**
+     * Defines the 307 status code.
+     */
+    public static final int SC_TEMPORARY_REDIRECT = 307;
+
+    /**
+     * Defines the 400 status code.
+     */
+    public static final int SC_BAD_REQUEST = 400;
+
+    /**
+     * Defines the 401 status code.
+     */
+    public static final int SC_UNAUTHORIZED = 401;
+
+    /**
+     * Defines the 402 status code.
+     */
+    public static final int SC_PAYMENT_REQUIRED = 402;
+
+    /**
+     * Defines the 403 status code.
+     */
+    public static final int SC_FORBIDDEN = 403;
+
+    /**
+     * Defines the 404 status code.
+     */
+    public static final int SC_NOT_FOUND = 404;
+
+    /**
+     * Defines the 405 status code.
+     */
+    public static final int SC_METHOD_NOT_ALLOWED = 405;
+
+    /**
+     * Defines the 406 status code.
+     */
+    public static final int SC_NOT_ACCEPTABLE = 406;
+
+    /**
+     * Defines the 407 status code.
+     */
+    public static final int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
+
+    /**
+     * Defines the 408 status code.
+     */
+    public static final int SC_REQUEST_TIMEOUT = 408;
+
+    /**
+     * Defines the 409 status code.
+     */
+    public static final int SC_CONFLICT = 409;
+
+    /**
+     * Defines the 410 status code.
+     */
+    public static final int SC_GONE = 410;
+
+    /**
+     * Defines the 411 status code.
+     */
+    public static final int SC_LENGTH_REQUIRED = 411;
+
+    /**
+     * Defines the 412 status code.
+     */
+    public static final int SC_PRECONDITION_FAILED = 412;
+
+    /**
+     * Defines the 413 status code.
+     */
+    public static final int SC_REQUEST_ENTITY_TOO_LARGE = 413;
+
+    /**
+     * Defines the 414 status code.
+     */
+    public static final int SC_REQUEST_URI_TOO_LONG = 414;
+
+    /**
+     * Defines the 415 status code.
+     */
+    public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;
+
+    /**
+     * Defines the 416 status code.
+     */
+    public static final int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
+
+    /**
+     * Defines the 417 status code.
+     */
+    public static final int SC_EXPECTATION_FAILED = 417;
+
+    /**
+     * Defines the 500 status code.
+     */
+    public static final int SC_INTERNAL_SERVER_ERROR = 500;
+
+    /**
+     * Defines the 501 status code.
+     */
+    public static final int SC_NOT_IMPLEMENTED = 501;
+
+    /**
+     * Defines the 502 status code.
+     */
+    public static final int SC_BAD_GATEWAY = 502;
+
+    /**
+     * Defines the 503 status code.
+     */
+    public static final int SC_SERVICE_UNAVAILABLE = 503;
+
+    /**
+     * Defines the 504 status code.
+     */
+    public static final int SC_GATEWAY_TIMEOUT = 504;
+
+    /**
+     * Defines the 505 status code.
+     */
+    public static final int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
+
+    /**
+     * Adds the cookie.
+     *
+     * @param cookie the cookie.
+     */
+    public void addCookie(Cookie cookie);
+
+    /**
+     * Add the date header.
+     *
+     * @param name the name.
+     * @param date the date.
+     */
+    public void addDateHeader(String name, long date);
+
+    /**
+     * Add the header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    public void addHeader(String name, String value);
+
+    /**
+     * Add the intheader.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    public void addIntHeader(String name, int value);
+
+    /**
+     * Contains the header.
+     *
+     * @param name the name.
+     * @return true if it contains the given header, false otherwise.
+     */
+    public boolean containsHeader(String name);
+
+    /**
+     * Encode the redirect URL.
+     *
+     * @param url the redirect URL.
+     * @return the encoded redirect URL.
+     */
+    public String encodeRedirectURL(String url);
+
+    /**
+     * Encode the redirect URL.
+     *
+     * @param url the redirect URL.
+     * @return the encoded redirect URL.
+     * @deprecated
+     */
+    @Deprecated
+    public String encodeRedirectUrl(String url);
+
+    /**
+     * Encode the URL.
+     *
+     * @param url the URL.
+     * @return the encoded URL.
+     */
+    public String encodeURL(String url);
+
+    /**
+     * Encode the URL.
+     *
+     * @param url the URL.
+     * @return the encoded URL.
+     * @deprecated
+     */
+    @Deprecated
+    public String encodeUrl(String url);
+
+    /**
+     * Get the header.
+     *
+     * @param name the name.
+     * @return the value, or null if not found.
+     */
+    public String getHeader(String name);
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    public Collection<String> getHeaderNames();
+
+    /**
+     * Get the headers.
+     *
+     * @param name the name.
+     * @return the headers.
+     */
+    public Collection<String> getHeaders(String name);
+
+    /**
+     * Get the status.
+     *
+     * @return the status.
+     */
+    public int getStatus();
+    
+    /**
+     * Get the supplier of trailer fields.
+     * 
+     * @return the supplier of trailer fields.
+     */
+    default Supplier<Map<String, String>> getTrailerFields() {
+        return null;
+    }
+
+    /**
+     * Send the error.
+     *
+     * @param status the status code.
+     * @param message the message.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void sendError(int status, String message) throws IOException;
+
+    /**
+     * Sends the error.
+     *
+     * @param status the status code.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void sendError(int status) throws IOException;
+
+    /**
+     * Send a redirect.
+     *
+     * @param location the location.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void sendRedirect(String location) throws IOException;
+
+    /**
+     * Set the date header.
+     *
+     * @param name the name.
+     * @param date the date.
+     */
+    public void setDateHeader(String name, long date);
+
+    /**
+     * Set the header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    public void setHeader(String name, String value);
+
+    /**
+     * Set the int header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    public void setIntHeader(String name, int value);
+
+    /**
+     * Set the status.
+     *
+     * @param status the status.
+     */
+    public void setStatus(int status);
+
+    /**
+     * Set the status.
+     *
+     * @param status the status.
+     * @param message the message.
+     * @deprecated 
+     */
+    @Deprecated
+    public void setStatus(int status, String message);
+   
+    /**
+     * Set the trailer fields supplier.
+     * 
+     * @param supplier the trailer fields supplier.
+     */
+    default void setTrailerFields(Supplier<Map<String, String>> supplier) { 
+    } 
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpServletResponseWrapper.java b/servlet4/api/src/main/java/javax/servlet/http/HttpServletResponseWrapper.java
new file mode 100644
index 00000000..3e7c970a
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpServletResponseWrapper.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.IOException;
+import java.util.Collection;
+import javax.servlet.ServletResponseWrapper;
+
+/**
+ * The HttpServletResponseWrapper API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class HttpServletResponseWrapper extends ServletResponseWrapper implements HttpServletResponse {
+
+    /**
+     * Constructor.
+     *
+     * @param response the HTTP servlet response.
+     */
+    public HttpServletResponseWrapper(HttpServletResponse response) {
+        super(response);
+    }
+
+    /**
+     * Add the cookie.
+     *
+     * @param cookie the cookie.
+     */
+    @Override
+    public void addCookie(Cookie cookie) {
+        getWrapped().addCookie(cookie);
+    }
+
+    /**
+     * Add the date header.
+     *
+     * @param name the name.
+     * @param date the date.
+     */
+    @Override
+    public void addDateHeader(String name, long date) {
+        getWrapped().addDateHeader(name, date);
+    }
+
+    /**
+     * Add the header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    @Override
+    public void addHeader(String name, String value) {
+        getWrapped().addHeader(name, value);
+    }
+
+    /**
+     * Add the int header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    @Override
+    public void addIntHeader(String name, int value) {
+        getWrapped().addIntHeader(name, value);
+    }
+
+    /**
+     * Contains the header.
+     *
+     * @param name the name.
+     * @return true if it contains the given header, false otherwise.
+     */
+    @Override
+    public boolean containsHeader(String name) {
+        return getWrapped().containsHeader(name);
+    }
+
+    /**
+     * Encode the redirect URL.
+     *
+     * @param url the redirect URL.
+     * @return the encoded redirect URL.
+     */
+    @Override
+    public String encodeRedirectURL(String url) {
+        return getWrapped().encodeRedirectURL(url);
+    }
+
+    /**
+     * Encode the redirect URL.
+     *
+     * @param url the redirect URL.
+     * @return the encoded redirect URL.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public String encodeRedirectUrl(String url) {
+        return getWrapped().encodeRedirectUrl(url);
+    }
+
+    /**
+     * Encode the URL.
+     *
+     * @param url the URL.
+     * @return the encoded URL.
+     */
+    @Override
+    public String encodeURL(String url) {
+        return getWrapped().encodeURL(url);
+    }
+
+    /**
+     * Encode the URL.
+     *
+     * @param url the URL.
+     * @return the encoded URL.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public String encodeUrl(String url) {
+        return getWrapped().encodeUrl(url);
+    }
+
+    /**
+     * Get the header.
+     *
+     * @param name the name.
+     * @return the header, or null if not found.
+     */
+    @Override
+    public String getHeader(String name) {
+        return getWrapped().getHeader(name);
+    }
+
+    /**
+     * Get the headers.
+     *
+     * @param name the name.
+     * @return the headers.
+     */
+    @Override
+    public Collection<String> getHeaders(String name) {
+        return getWrapped().getHeaders(name);
+    }
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    @Override
+    public Collection<String> getHeaderNames() {
+        return getWrapped().getHeaderNames();
+    }
+
+    /**
+     * Get the status.
+     *
+     * @return the status.
+     */
+    @Override
+    public int getStatus() {
+        return getWrapped().getStatus();
+    }
+
+    /**
+     * Get the wrapped response.
+     *
+     * @return the wrapped response.
+     */
+    private HttpServletResponse getWrapped() {
+        return (HttpServletResponse) super.getResponse();
+    }
+
+    /**
+     * Send an error.
+     *
+     * @param status the status code.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public void sendError(int status) throws IOException {
+        getWrapped().sendError(status);
+    }
+
+    /**
+     * Send an error.
+     *
+     * @param status the status code.
+     * @param message the message.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public void sendError(int status, String message) throws IOException {
+        getWrapped().sendError(status, message);
+    }
+
+    /**
+     * Send a redirect.
+     *
+     * @param location the location.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public void sendRedirect(String location) throws IOException {
+        getWrapped().sendRedirect(location);
+    }
+
+    /**
+     * Set the date header.
+     *
+     * @param name the name.
+     * @param date the date.
+     */
+    @Override
+    public void setDateHeader(String name, long date) {
+        getWrapped().setDateHeader(name, date);
+    }
+
+    /**
+     * Set the header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    @Override
+    public void setHeader(String name, String value) {
+        getWrapped().setHeader(name, value);
+    }
+
+    /**
+     * Set the int header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    @Override
+    public void setIntHeader(String name, int value) {
+        getWrapped().setIntHeader(name, value);
+    }
+
+    /**
+     * Set the status.
+     *
+     * @param status the status.
+     */
+    @Override
+    public void setStatus(int status) {
+        getWrapped().setStatus(status);
+    }
+
+    /**
+     * Set the status.
+     *
+     * @param status the status code.
+     * @param message the status message.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public void setStatus(int status, String message) {
+        getWrapped().setStatus(status, message);
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSession.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSession.java
new file mode 100644
index 00000000..2c773cb8
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSession.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.Enumeration;
+import javax.servlet.ServletContext;
+
+/**
+ * The HttpSession API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpSession {
+
+    /**
+     * Get the attribute.
+     *
+     * @param name the name.
+     * @return the value, or null if not found.
+     */
+    public Object getAttribute(String name);
+
+    /**
+     * Get the attribute names.
+     *
+     * @return the attribute names.
+     */
+    public Enumeration<String> getAttributeNames();
+
+    /**
+     * Get the creation time.
+     *
+     * @return the creation time.
+     */
+    public long getCreationTime();
+
+    /**
+     * Get the id.
+     *
+     * @return the id.
+     */
+    public String getId();
+
+    /**
+     * Get the last accessed time.
+     *
+     * @return the last accessed time.
+     */
+    public long getLastAccessedTime();
+
+    /**
+     * Get the max inactive interval.
+     *
+     * @return the max inactive interval.
+     */
+    public int getMaxInactiveInterval();
+
+    /**
+     * Get the Servlet context.
+     *
+     * @return the Servlet context.
+     */
+    public ServletContext getServletContext();
+
+    /**
+     * Get the HTTP session context.
+     *
+     * @return the HTTP session context.
+     * @deprecated
+     */
+    @Deprecated
+    public HttpSessionContext getSessionContext();
+
+    /**
+     * Get the value.
+     *
+     * @param name the name.
+     * @return the value.
+     * @deprecated
+     */
+    @Deprecated
+    public Object getValue(String name);
+
+    /**
+     * Get the value names.
+     *
+     * @return the value names.
+     * @deprecated
+     */
+    @Deprecated
+    public String[] getValueNames();
+
+    /**
+     * Invalidate the HTTP session.
+     */
+    public void invalidate();
+
+    /**
+     * Is the HTTP session new.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isNew();
+
+    /**
+     * Put the value.
+     *
+     * @param name the name.
+     * @param value the value.
+     * @deprecated
+     */
+    @Deprecated
+    public void putValue(String name, Object value);
+
+    /**
+     * Remove the attribute.
+     *
+     * @param name the name.
+     */
+    public void removeAttribute(String name);
+
+    /**
+     * Remove the value.
+     *
+     * @param name the name.
+     * @deprecated
+     */
+    @Deprecated
+    public void removeValue(String name);
+
+    /**
+     * Set the attribute.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    public void setAttribute(String name, Object value);
+
+    /**
+     * Set the max inactive interval.
+     *
+     * @param interval the max inactive interval.
+     */
+    public void setMaxInactiveInterval(int interval);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSessionActivationListener.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionActivationListener.java
new file mode 100644
index 00000000..25b5a8d7
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionActivationListener.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.EventListener;
+
+/**
+ * The HttpSessionActivationListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpSessionActivationListener extends EventListener {
+
+    /**
+     * Handle the session will passivate event.
+     *
+     * @param event the HTTP session event.
+     */
+    default void sessionWillPassivate(HttpSessionEvent event) {
+    }
+
+    /**
+     * Handle the session did activate event.
+     *
+     * @param event the HTTP session event.
+     */
+    default void sessionDidActivate(HttpSessionEvent event) {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSessionAttributeListener.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionAttributeListener.java
new file mode 100644
index 00000000..753fb1be
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionAttributeListener.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.EventListener;
+
+/**
+ * The HttpSessionAttributeListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpSessionAttributeListener extends EventListener {
+
+    /**
+     * Handle the attribute added event.
+     *
+     * @param event the HTTP session binding event.
+     */
+    default void attributeAdded(HttpSessionBindingEvent event) {
+    }
+
+    /**
+     * Handle the attribute removed event.
+     *
+     * @param event the HTTP session binding event.
+     */
+    default void attributeRemoved(HttpSessionBindingEvent event) {
+    }
+
+    /**
+     * Handle the attribute replaced event.
+     *
+     * @param event the HTTP session binding event.
+     */
+    default void attributeReplaced(HttpSessionBindingEvent event) {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSessionBindingEvent.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionBindingEvent.java
new file mode 100644
index 00000000..f3eced2e
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionBindingEvent.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+/**
+ * The HttpSessionBindingEvent API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class HttpSessionBindingEvent extends HttpSessionEvent {
+
+    /**
+     * Stores the name.
+     */
+    private String name;
+
+    /**
+     * Stores the value.
+     */
+    private Object value;
+
+    /**
+     * Constructor.
+     *
+     * @param session the HTTP session.
+     * @param name the name.
+     */
+    public HttpSessionBindingEvent(HttpSession session, String name) {
+        super(session);
+        this.name = name;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param session the HTTP session.
+     * @param name the name.
+     * @param value the value.
+     */
+    public HttpSessionBindingEvent(HttpSession session, String name, Object value) {
+        super(session);
+        this.name = name;
+        this.value = value;
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the HTTP session.
+     *
+     * @return the HTTP session.
+     */
+    @Override
+    public HttpSession getSession() {
+        return super.getSession();
+    }
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    public Object getValue() {
+        return this.value;
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSessionBindingListener.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionBindingListener.java
new file mode 100644
index 00000000..fd702012
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionBindingListener.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.EventListener;
+
+/**
+ * The HttpSessionBindingListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpSessionBindingListener extends EventListener {
+
+    /**
+     * Handle the value bound event.
+     *
+     * @param event the HTTP session binding event.
+     */
+    default void valueBound(HttpSessionBindingEvent event) {
+    }
+
+    /**
+     * Handle the value unbound event.
+     *
+     * @param event the HTTP session binding event.
+     */
+    default void valueUnbound(HttpSessionBindingEvent event) {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSessionContext.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionContext.java
new file mode 100644
index 00000000..944d2670
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionContext.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.Enumeration;
+
+/**
+ * The HttpSessionContext API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ * @deprecated
+ */
+@Deprecated
+public interface HttpSessionContext {
+
+    /**
+     * Get the HTTP session.
+     *
+     * @param sessionId the HTTP session id.
+     * @return the HTTP session.
+     * @deprecated
+     */
+    @Deprecated
+    public HttpSession getSession(String sessionId);
+
+    /**
+     * Get the HTTP session ids.
+     *
+     * @return the HTTP session ids.
+     * @deprecated
+     */
+    @Deprecated
+    public Enumeration<String> getIds();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSessionEvent.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionEvent.java
new file mode 100644
index 00000000..6d3d34a7
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionEvent.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.EventObject;
+
+/**
+ * The HttpSessionEvent API.
+ */
+public class HttpSessionEvent extends EventObject {
+    
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = -7622791603672342895L;
+
+    /**
+     * Constructor.
+     *
+     * @param session the HTTP session.
+     */
+    public HttpSessionEvent(HttpSession session) {
+        super(session);
+    }
+
+    /**
+     * Get the HTTP session.
+     *
+     * @return the HTTP session.
+     */
+    public HttpSession getSession() {
+        return (HttpSession) super.getSource();
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSessionIdListener.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionIdListener.java
new file mode 100644
index 00000000..59398a72
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionIdListener.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.EventListener;
+
+/**
+ * The HttpSessionIdListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpSessionIdListener extends EventListener {
+
+    /**
+     * Handle the session id change event.
+     *
+     * @param event the HTTP session event.
+     * @param oldSessionId the old HTTP session id.
+     */
+    public void sessionIdChanged(HttpSessionEvent event, String oldSessionId);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpSessionListener.java b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionListener.java
new file mode 100644
index 00000000..fd2199f5
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpSessionListener.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.EventListener;
+
+/**
+ * The HttpSessionListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpSessionListener extends EventListener {
+
+    /**
+     * Handle the HTTP session created event.
+     *
+     * @param httpSessionEvent the HTTP session event.
+     */
+    default void sessionCreated(HttpSessionEvent httpSessionEvent) {
+    }
+
+    /**
+     * Handle the HTTP session destroyed event.
+     *
+     * @param httpSessionEvent the HTTP session event.
+     */
+    default void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpUpgradeHandler.java b/servlet4/api/src/main/java/javax/servlet/http/HttpUpgradeHandler.java
new file mode 100644
index 00000000..87fe51a6
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpUpgradeHandler.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+/**
+ * The HttpUpgradeHandler API.
+ */
+public interface HttpUpgradeHandler {
+
+    /**
+     * Initialize the upgrade.
+     *
+     * @param webConnection the web connection.
+     */
+    public void init(WebConnection webConnection);
+
+    /**
+     * Destroy the upgrade.
+     */
+    public void destroy();
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/HttpUtils.java b/servlet4/api/src/main/java/javax/servlet/http/HttpUtils.java
new file mode 100644
index 00000000..bc0ac23f
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/HttpUtils.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.Hashtable;
+import javax.servlet.ServletInputStream;
+
+/**
+ * The HttpUtils API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ * @deprecated
+ */
+@Deprecated
+public class HttpUtils {
+
+    /**
+     * Constructor.
+     */
+    public HttpUtils() {
+    }
+
+    /**
+     * Get the request URL.
+     *
+     * @param request the request.
+     * @return the request URL.
+     */
+    public static StringBuffer getRequestURL(HttpServletRequest request) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Parse the POST data.
+     *
+     * @param length the length.
+     * @param inputStream the input stream.
+     * @return the hash table populated with key/value pairs.
+     */
+    public static Hashtable<String, String[]> parsePostData(int length, ServletInputStream inputStream) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Parse the query string.
+     *
+     * @param queryString the query string.
+     * @return the hash table populated with key/value pairs.
+     */
+    public static Hashtable<String, String[]> parseQueryString(String queryString) {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/MappingMatch.java b/servlet4/api/src/main/java/javax/servlet/http/MappingMatch.java
new file mode 100644
index 00000000..eb9a8a7e
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/MappingMatch.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+/**
+ * The mapping match.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public enum MappingMatch {
+    
+    /**
+     * The context root constant.
+     */
+    CONTEXT_ROOT,
+    
+    /**
+     * The default constant.
+     */
+    DEFAULT,
+    
+    /**
+     * The exact constant.
+     */
+    EXACT,
+    
+    /**
+     * The extension constant.
+     */
+    EXTENSION,
+    
+    /**
+     * The path constant.
+     */
+    PATH
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/Part.java b/servlet4/api/src/main/java/javax/servlet/http/Part.java
new file mode 100644
index 00000000..8184e145
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/Part.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collection;
+
+/**
+ * The Part API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface Part {
+
+    /**
+     * Delete the part.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    public void delete() throws IOException;
+
+    /**
+     * Get the content type.
+     *
+     * @return the content type.
+     */
+    public String getContentType();
+
+    /**
+     * Get the header.
+     *
+     * @param name the name.
+     * @return the header, or null.
+     */
+    public String getHeader(String name);
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    public Collection<String> getHeaderNames();
+
+    /**
+     * Get the headers.
+     *
+     * @param name the name.
+     * @return the headers.
+     */
+    public Collection<String> getHeaders(String name);
+
+    /**
+     * Get the input stream.
+     *
+     * @return the input stream.
+     * @throws IOException when an I/O error occurs.
+     */
+    public InputStream getInputStream() throws IOException;
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName();
+
+    /**
+     * Get the size.
+     *
+     * @return the size.
+     */
+    public long getSize();
+
+    /**
+     * Get the submitted filename.
+     *
+     * @return the submitted filename.
+     */
+    public String getSubmittedFileName();
+
+    /**
+     * Write to the given filename.
+     *
+     * @param filename the filename.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void write(String filename) throws IOException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/PushBuilder.java b/servlet4/api/src/main/java/javax/servlet/http/PushBuilder.java
new file mode 100644
index 00000000..79f639bf
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/PushBuilder.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.util.Set;
+
+/**
+ * The push builder API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface PushBuilder {
+
+    /**
+     * Add the header.
+     *
+     * @param name the name.
+     * @param value the value.
+     * @return the push builder.
+     */
+    PushBuilder addHeader(String name, String value);
+
+    /**
+     * Get the header.
+     *
+     * @param name the name.
+     * @return the value.
+     */
+    String getHeader(String name);
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    Set<String> getHeaderNames();
+
+    /**
+     * Get the HTTP method.
+     *
+     * @return the HTTP method.
+     */
+    String getMethod();
+
+    /**
+     * Get the path.
+     * 
+     * @return the path.
+     */
+    String getPath();
+
+    /**
+     * Get the query string.
+     *
+     * @return the query string.
+     */
+    String getQueryString();
+
+    /**
+     * Get the session id.
+     *
+     * @return the session id.
+     */
+    String getSessionId();
+
+    /**
+     * Set the HTTP method.
+     *
+     * @param method the method.
+     * @return the push builder.
+     */
+    PushBuilder method(String method);
+
+    /**
+     * Set the path.
+     *
+     * @param path the path.
+     * @return the push builder.
+     */
+    PushBuilder path(String path);
+
+    /**
+     * Push.
+     */
+    void push();
+
+    /**
+     * Set the query string.
+     *
+     * @param queryString the query string.
+     * @return the push builder.
+     */
+    PushBuilder queryString(String queryString);
+
+    /**
+     * Remove the header.
+     *
+     * @param name the name.
+     * @return the push builder.
+     */
+    PushBuilder removeHeader(String name);
+
+    /**
+     * Set the session id.
+     *
+     * @param sessionId the session id.
+     * @return the push builder.
+     */
+    PushBuilder sessionId(String sessionId);
+
+    /**
+     * Set the header.
+     *
+     * @param name the name.
+     * @param value the value.
+     * @return the push builder.
+     */
+    PushBuilder setHeader(String name, String value);
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/WebConnection.java b/servlet4/api/src/main/java/javax/servlet/http/WebConnection.java
new file mode 100644
index 00000000..a61a1a8a
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/WebConnection.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package javax.servlet.http;
+
+import java.io.IOException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletOutputStream;
+
+/**
+ * The WebConnection API.
+ */
+public interface WebConnection extends AutoCloseable {
+
+    /**
+     * Get the input stream.
+     *
+     * @return the input stream.
+     * @throws IOException when an I/O error occurs.
+     */
+    ServletInputStream getInputStream() throws IOException;
+
+    /**
+     * Get the output stream.
+     *
+     * @return the output stream.
+     * @throws IOException when an I/O error occurs.
+     */
+    ServletOutputStream getOutputStream() throws IOException;
+}
diff --git a/servlet4/api/src/main/java/javax/servlet/http/package-info.java b/servlet4/api/src/main/java/javax/servlet/http/package-info.java
new file mode 100644
index 00000000..b2b5c587
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/http/package-info.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/**
+ * <p>
+ * The javax.servlet.http package delivers the HTTP part of the Servlet API.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+package javax.servlet.http;
diff --git a/servlet4/api/src/main/java/javax/servlet/package-info.java b/servlet4/api/src/main/java/javax/servlet/package-info.java
new file mode 100644
index 00000000..596c1710
--- /dev/null
+++ b/servlet4/api/src/main/java/javax/servlet/package-info.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/**
+ * <p>
+ * The javax.servlet package delivers the Core Servlet API classes.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+package javax.servlet;
diff --git a/servlet4/api/src/main/java/module-info.java b/servlet4/api/src/main/java/module-info.java
new file mode 100644
index 00000000..305e1648
--- /dev/null
+++ b/servlet4/api/src/main/java/module-info.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+module cloud.piranha.servlet4.api {
+    
+    exports javax.servlet;
+    exports javax.servlet.annotation;
+    exports javax.servlet.descriptor;
+    exports javax.servlet.http;
+    opens javax.servlet;
+    opens javax.servlet.annotation;
+    opens javax.servlet.descriptor;
+    opens javax.servlet.http;
+}
diff --git a/servlet4/impl/pom.xml b/servlet4/impl/pom.xml
new file mode 100644
index 00000000..ae16baa2
--- /dev/null
+++ b/servlet4/impl/pom.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha.servlet4</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>piranha-servlet4-impl</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Piranha Servlet 4 - Implementation</name>
+
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>cloud.piranha</groupId>
+                <artifactId>bom</artifactId>
+                <version>${project.version}</version>
+                <type>pom</type>
+                <scope>import</scope>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+    <dependencies>
+        <dependency>
+            <groupId>cloud.piranha.naming</groupId>
+            <artifactId>piranha-naming-impl</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.policy</groupId>
+            <artifactId>piranha-policy-impl</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.resource</groupId>
+            <artifactId>piranha-resource</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-webapp</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.http</groupId>
+            <artifactId>piranha-http-impl</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/AsyncHttpDispatchWrapper.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/AsyncHttpDispatchWrapper.java
new file mode 100644
index 00000000..8b5a340f
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/AsyncHttpDispatchWrapper.java
@@ -0,0 +1,351 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static java.util.Collections.enumeration;
+import static java.util.Collections.list;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Objects.requireNonNull;
+import static javax.servlet.DispatcherType.ASYNC;
+
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+
+import javax.servlet.AsyncContext;
+import javax.servlet.DispatcherType;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
+
+import cloud.piranha.servlet4.webapp.AttributeManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationRequest;
+
+/**
+ * The async HTTP dispatch wrapper.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class AsyncHttpDispatchWrapper extends HttpServletRequestWrapper implements WebApplicationRequest {
+
+    /**
+     * Stores the servlet path.
+     */
+    private String servletPath;
+    
+    /**
+     * Stores the path info.
+     */
+    private String pathInfo;
+    
+    /**
+     * Stores the request URI.
+     */
+    private String requestURI;
+    
+    /**
+     * Stores the query string.
+     */
+    private String queryString;
+
+    /**
+     * Stores the async context.
+     */
+    private AsyncContext asyncContext;
+    
+    /**
+     * Stores the async started flag.
+     */
+    private boolean asyncStarted; // Note that asyncStarted is per async cycle, and resets when the request is dispatched
+
+    /**
+     * Stores the attribute manager.
+     */
+    private AttributeManager attributeManager = new DefaultAttributeManager();
+
+    /**
+     * Stores the wrapper attributes.
+     */
+    private List<String> wrapperAttributes = new ArrayList<>();
+    
+    /**
+     * Stores the wrapper parameters.
+     */
+    private Map<String, String[]> wrapperParameters = new HashMap<>();
+
+    /**
+     * Constructor.
+     * 
+     * @param request the HTTP servlet request.
+     */
+    public AsyncHttpDispatchWrapper(HttpServletRequest request) {
+        super(request);
+        wrapperAttributes.add("piranha.response");
+    }
+
+    @Override
+    public HttpServletRequest getRequest() {
+        return (HttpServletRequest) super.getRequest();
+    }
+
+    @Override
+    public DispatcherType getDispatcherType() {
+        return ASYNC;
+    }
+
+    @Override
+    public String getServletPath() {
+        return servletPath;
+    }
+
+    @Override
+    public String getPathInfo() {
+        return pathInfo;
+    }
+
+    /**
+     * Set the path info.
+     * 
+     * @param pathInfo the path info.
+     */
+    public void setPathInfo(String pathInfo) {
+        this.pathInfo = pathInfo;
+    }
+
+    @Override
+    public String getRequestURI() {
+        return requestURI;
+    }
+
+    /**
+     * Set the request URI.
+     * 
+     * @param requestURI the request URI.
+     */
+    public void setRequestURI(String requestURI) {
+        this.requestURI = requestURI;
+    }
+
+    @Override
+    public String getQueryString() {
+        return queryString;
+    }
+
+    @Override
+    public AsyncContext startAsync() throws IllegalStateException {
+        return startAsync(this, requireNonNull((ServletResponse) getAttribute("piranha.response")));
+    }
+
+    @Override
+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) throws IllegalStateException {
+        if (asyncContext != null) {
+            throw new IllegalStateException("Async cycle has already been started");
+        }
+
+        servletRequest.setAttribute("CALLED_FROM_ASYNC_WRAPPER", "true");
+        asyncContext = super.startAsync(servletRequest, servletResponse);
+        asyncStarted = true;
+
+        return asyncContext;
+    }
+
+    @Override
+    public boolean isAsyncStarted() {
+        return asyncStarted;
+    }
+
+    @Override
+    public Enumeration<String> getAttributeNames() {
+        HashSet<String> attributeNames = new HashSet<>();
+        attributeNames.addAll(list(super.getAttributeNames()));
+        attributeNames.addAll(wrapperAttributes);
+
+        return enumeration(attributeNames);
+    }
+
+    @Override
+    public Object getAttribute(String name) {
+        if (wrapperAttributes.contains(name)) {
+            return attributeManager.getAttribute(name);
+        }
+
+        return super.getAttribute(name);
+    }
+
+    @Override
+    public void setAttribute(String name, Object object) {
+        if (wrapperAttributes.contains(name)) {
+            attributeManager.setAttribute(name, object);
+        } else {
+            super.setAttribute(name, object);
+        }
+    }
+
+    @Override
+    public void removeAttribute(String name) {
+        if (wrapperAttributes.contains(name)) {
+            attributeManager.removeAttribute(name);
+        } else {
+            super.removeAttribute(name);
+        }
+    }
+
+    /**
+     * Get the parameter.
+     *
+     * @param name the name.
+     * @return the value.
+     */
+    @Override
+    public String getParameter(String name) {
+        if (getParameterValues(name) == null) {
+            return null;
+        }
+
+        return getParameterValues(name)[0];
+    }
+
+    /**
+     * Get the parameter map.
+     *
+     * @return the parameter map.
+     */
+    @Override
+    public Map<String, String[]> getParameterMap() {
+        Map<String, String[]> parameterMap = new HashMap<>();
+        parameterMap.putAll(super.getParameterMap());
+        parameterMap.putAll(wrapperParameters);
+
+        return unmodifiableMap(parameterMap);
+    }
+
+    /**
+     * Get the parameter names.
+     *
+     * @return the parameter names.
+     */
+    @Override
+    public Enumeration<String> getParameterNames() {
+        HashSet<String> parameterNames = new HashSet<>();
+        parameterNames.addAll(super.getParameterMap().keySet());
+        parameterNames.addAll(wrapperParameters.keySet());
+
+        return enumeration(parameterNames);
+    }
+
+    /**
+     * Get the parameter values.
+     *
+     * @param name the parameter name.
+     * @return the parameter values.
+     */
+    @Override
+    public String[] getParameterValues(String name) {
+        if (wrapperParameters.containsKey(name)) {
+            return wrapperParameters.get(name);
+        }
+
+        return super.getParameterValues(name);
+    }
+
+    /**
+     * Set the query string.
+     * 
+     * @param queryString the query string.
+     */
+    public void setQueryString(String queryString) {
+        this.queryString = queryString;
+    }
+
+    /**
+     * Set as a wrapper attribute.
+     * 
+     * @param name the name.
+     * @param value the value.
+     */
+    public void setAsWrapperAttribute(String name, Object value) {
+        attributeManager.setAttribute(name, value);
+    }
+
+    /**
+     * Get the wrapper attributes.
+     * 
+     * @return the wrapper attributes.
+     */
+    public List<String> getWrapperAttributes() {
+        return wrapperAttributes;
+    }
+
+    /**
+     * Get the wrapper parameters.
+     * 
+     * @return the wrapper parameters.
+     */
+    public Map<String, String[]> getWrapperParameters() {
+        return wrapperParameters;
+    }
+
+    @Override
+    public void setDispatcherType(DispatcherType dispatcherType) {
+
+    }
+
+    @Override
+    public String toString() {
+        return getRequestURIWithQueryString() + " " + super.toString();
+    }
+
+    /**
+     * Get the request URI with query string.
+     * 
+     * @return the request URI with query string.
+     */
+    public String getRequestURIWithQueryString() {
+        String requestURI = getRequestURI();
+        String queryString = getQueryString();
+        return queryString == null ? requestURI : requestURI + "?" + queryString;
+    }
+
+    @Override
+    public void setContextPath(String contextPath) {
+    }
+    
+    @Override
+    public void setServletPath(String servletPath) {
+        this.servletPath = servletPath;
+    }
+
+    @Override
+    public void setWebApplication(WebApplication webApplication) {
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/AsyncNonHttpDispatchWrapper.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/AsyncNonHttpDispatchWrapper.java
new file mode 100644
index 00000000..364848ba
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/AsyncNonHttpDispatchWrapper.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static javax.servlet.DispatcherType.ASYNC;
+
+import java.util.Map;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestWrapper;
+
+/**
+ * The async non-HTTP dispatch wrapper.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class AsyncNonHttpDispatchWrapper extends ServletRequestWrapper {
+
+    /**
+     * Stores the attributes.
+     */
+    private Map<String, Object> attributes;
+
+    /**
+     * Constructor.
+     *
+     * @param request the servlet request.
+     */
+    public AsyncNonHttpDispatchWrapper(ServletRequest request) {
+        super(request);
+    }
+
+    @Override
+    public DispatcherType getDispatcherType() {
+        return ASYNC;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAnnotationManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAnnotationManager.java
new file mode 100644
index 00000000..2d44c4a6
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAnnotationManager.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static java.util.Collections.emptyList;
+import static java.util.stream.Collectors.toList;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.AnnotatedElement;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Stream;
+
+import cloud.piranha.servlet4.webapp.AnnotationManager;
+
+/**
+ * The default AnnotationManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultAnnotationManager implements AnnotationManager {
+
+    /**
+     * The default AnnotationInfo.
+     * 
+     * @param <T> the type.
+     */
+    public static class DefaultAnnotationInfo<T> implements AnnotationInfo<T> {
+
+        /**
+         * Stores the instance.
+         */
+        private final T instance;
+        
+        /**
+         * Stores the target.
+         */
+        private final AnnotatedElement target;
+
+        /**
+         * Constructor.
+         * 
+         * @param instance the instance.
+         * @param target the target annotated element.
+         */
+        public DefaultAnnotationInfo(T instance, AnnotatedElement target) {
+            this.instance = instance;
+            this.target = target;
+        }
+
+        @Override
+        public T getInstance() {
+            return instance;
+        }
+
+        @Override
+        public AnnotatedElement getTarget() {
+            return target;
+        }
+    }
+
+    /**
+     * Stores the annotations.
+     */
+    private final Map<Class<?>, List<AnnotationInfo<?>>> annotations = new ConcurrentHashMap<>();
+    
+    /**
+     * Stores the instances.
+     */
+    private final Map<Class<?>, List<Class<?>>> instances = new ConcurrentHashMap<>();
+
+
+    @Override
+    public List<AnnotationInfo<?>> getAnnotations(Class<?>... annotationClasses) {
+        return
+            Arrays.stream(annotationClasses)
+                  .flatMap(this::getAnnotationStream)
+                  .collect(toList());
+    }
+
+    @Override
+    public <T> List<AnnotationInfo<T>> getAnnotations(Class<T> annotationClass) {
+        return
+            getAnnotationStream(annotationClass)
+                .collect(toList());
+    }
+
+    @Override
+    public List<Class<?>> getInstances(Class<?>... instanceClasses) {
+        return
+            Arrays.stream(instanceClasses)
+                  .flatMap(this::getInstanceStream)
+                  .collect(toList());
+    }
+
+    @Override
+    public <T> List<Class<T>> getInstances(Class<T> instanceClass) {
+        return
+            getInstanceStream(instanceClass)
+                .collect(toList());
+    }
+
+    /**
+     * Add the annotation.
+     * 
+     * @param annotationInfo the annotation info.
+     * @return the annotation manager.
+     */
+    public DefaultAnnotationManager addAnnotation(AnnotationInfo<?> annotationInfo) {
+        annotations.computeIfAbsent(
+            ((Annotation) annotationInfo.getInstance()).annotationType(),
+            e -> new ArrayList<>())
+                   .add(annotationInfo);
+
+        return this;
+    }
+
+    /**
+     * Add an instance.
+     * 
+     * @param instanceClass the instance class.
+     * @param implementingClass the implementing class.
+     * @return the annotation manager.
+     */
+    public DefaultAnnotationManager addInstance(Class<?> instanceClass, Class<?> implementingClass) {
+        instances.computeIfAbsent(
+            instanceClass,
+            e -> new ArrayList<>())
+                     .add(implementingClass);
+
+        return this;
+    }
+
+
+    // ### Private methods
+
+    @SuppressWarnings("unchecked")
+    private <T> Stream<AnnotationInfo<T>> getAnnotationStream(Class<T> annotationClass) {
+        return annotations.getOrDefault(annotationClass, emptyList())
+                          .stream()
+                          .map(e -> (AnnotationInfo<T>) e);
+    }
+
+    @SuppressWarnings("unchecked")
+    private <T> Stream<Class<T>> getInstanceStream(Class<T> instanceClass) {
+        return instances.getOrDefault(instanceClass, emptyList())
+                          .stream()
+                          .map(e -> (Class<T>) e);
+    }
+
+    // ### Not implemented
+
+    /**
+     * Get the annotated classes.
+     *
+     * @return the annotated classes.
+     */
+    @Override
+    public Set<Class<?>> getAnnotatedClasses() {
+        return new HashSet<>();
+    }
+
+
+    @Override
+    public <T> List<AnnotationInfo<T>> getAnnotationsByTarget(Class<T> annotationClass, AnnotatedElement type) {
+        return null;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncContext.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncContext.java
new file mode 100644
index 00000000..abb0c710
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncContext.java
@@ -0,0 +1,393 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.logging.Level.FINE;
+import static java.util.logging.Level.WARNING;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.logging.Logger;
+
+import javax.servlet.AsyncContext;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestWrapper;
+import javax.servlet.ServletResponse;
+import javax.servlet.ServletResponseWrapper;
+import javax.servlet.http.HttpServletRequest;
+
+import cloud.piranha.servlet4.webapp.AsyncManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationRequest;
+import cloud.piranha.servlet4.webapp.WebApplicationResponse;
+
+/**
+ * The default AsyncContext.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultAsyncContext implements AsyncContext {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(DefaultAsyncContext.class.getName());
+
+    /**
+     * Stores the listeners.
+     */
+    private final List<AsyncListener> listeners = new ArrayList<>();
+
+    /**
+     * The request that comes from a call to <code>request.startAsync()</code>
+     *
+     * <p>
+     * This is either the request the caller passed in when using
+     * <code>request.startAsync(someRequest, someResponse)</code> or it's the
+     * request object on which <code>startAsync</code> was called when using the
+     * zero argument version <code>request.startAsync()</code>.
+     *
+     * <p>
+     * In the latter case, the request is guaranteed to be the "original
+     * request", which is the request passed to the servlet that started the
+     * async cycle. In the former case it can either be the "original request",
+     * or it can be that request but wrapped by user code.
+     */
+    private final ServletRequest asyncStartRequest;
+
+    /**
+     * The response that comes from a call to <code>request.startAsync()</code>
+     *
+     * <p>
+     * This is either the response the caller passed in when using
+     * <code>request.startAsync(someRequest, someResponse)</code> or it's the
+     * response object associated with the request object on which
+     * <code>startAsync</code> was called when using the zero argument version
+     * <code>request.startAsync()</code>.
+     *
+     * <p>
+     * In the latter case, the response is guaranteed to be the "original
+     * response", which is the response passed to the servlet that started the
+     * async cycle. In the former case it can either be the "original response",
+     * or it can be that response but wrapped by user code.
+     */
+    private final ServletResponse asyncStartResponse;
+
+    /**
+     * "the request object passed to the first servlet object in the call chain
+     * that received the request from the client."
+     */
+    private final WebApplicationRequest originalRequest;
+
+    /**
+     * The response object passed to the first servlet object in the call chain
+     * that received the request from the client."
+     */
+    private final WebApplicationResponse originalResponse;
+
+    /**
+     * Stores the timeout.
+     */
+    private long timeout = Long.valueOf(System.getProperty("piranha.async.timeout", "30000")); // 30 seconds, as mandated by spec
+
+    /**
+     * Tracks whether dispatch() has already been called on this context or not.
+     */
+    private boolean dispatched;
+
+    /**
+     * Stores the scheduled thread pool executor.
+     */
+    private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
+
+    /**
+     * Constructor.
+     *
+     * @param asyncStartRequest the servlet asyncStartRequest.
+     * @param asyncStartResponse the servlet asyncStartResponse.
+     */
+    public DefaultAsyncContext(ServletRequest asyncStartRequest, ServletResponse asyncStartResponse) {
+        this.asyncStartRequest = requireNonNull(asyncStartRequest);
+        this.asyncStartResponse = requireNonNull(asyncStartResponse);
+
+        originalRequest = unwrapFully(asyncStartRequest);
+        originalResponse = unwrapFully(asyncStartResponse);
+
+        scheduledThreadPoolExecutor.schedule(this::onTimeOut, timeout, MILLISECONDS);
+    }
+
+    /**
+     * Add the listener.
+     *
+     * @param listener the listener.
+     * @see AsyncContext#addListener(javax.servlet.AsyncListener)
+     */
+    @Override
+    public void addListener(AsyncListener listener) {
+        this.listeners.add(listener);
+    }
+
+    /**
+     * Add the listener.
+     *
+     * @param listener the listener.
+     * @param request the servlet asyncStartRequest.
+     * @param response the servlet asyncStartResponse.
+     */
+    @Override
+    public void addListener(AsyncListener listener, ServletRequest request, ServletResponse response) {
+        this.listeners.add(listener);
+    }
+
+    /**
+     * Create the listener.
+     *
+     * @param <T> the class.
+     * @param type the type.
+     * @return the listener.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public <T extends AsyncListener> T createListener(Class<T> type) throws ServletException {
+        try {
+            return type.getConstructor().newInstance();
+        } catch (Throwable t) {
+            LOGGER.log(WARNING, t, () -> "Unable to create AsyncListener: " + type.getName());
+            throw new ServletException("Unable to create listener", t);
+        }
+    }
+
+    /**
+     * @see AsyncContext#dispatch()
+     */
+    @Override
+    public void dispatch() {
+        String path;
+        if (asyncStartRequest instanceof HttpServletRequest) {
+            HttpServletRequest httpServletRequest = (HttpServletRequest) asyncStartRequest;
+            path = httpServletRequest.getRequestURI().substring(httpServletRequest.getContextPath().length());
+        } else {
+            path = originalRequest.getRequestURI().substring(originalRequest.getContextPath().length());
+        }
+        dispatch(path);
+    }
+
+    /**
+     * @see AsyncContext#dispatch(java.lang.String)
+     */
+    @Override
+    public void dispatch(String path) {
+        dispatch(asyncStartRequest.getServletContext(), path);
+    }
+
+    /**
+     * Dispatch.
+     *
+     * @param servletContext the servlet context.
+     * @param path the path.
+     */
+    @Override
+    public void dispatch(ServletContext servletContext, String path) {
+        if (dispatched) {
+            throw new IllegalStateException("Dispatch already called on this async contexct");
+        }
+        dispatched = true;
+
+        WebApplication webApplication = (WebApplication) servletContext;
+        AsyncManager asyncManager = webApplication.getAsyncManager();
+        asyncManager.getDispatcher(webApplication, path, asyncStartRequest, asyncStartResponse)
+                .dispatch();
+    }
+
+    /**
+     * Complete the async context.
+     */
+    @Override
+    public void complete() {
+
+        scheduledThreadPoolExecutor.shutdownNow();
+
+        LOGGER.log(FINE, () -> "Completing async processing");
+
+        if (!listeners.isEmpty()) {
+            listeners.forEach(listener -> {
+                try {
+                    listener.onComplete(new AsyncEvent(this));
+                } catch (IOException ioe) {
+                    LOGGER.log(WARNING, ioe, () -> "IOException when calling onComplete on AsyncListener");
+                }
+            });
+        }
+
+        LOGGER.log(FINE, () -> "Flushing async asyncStartResponse buffer");
+
+        try {
+            asyncStartResponse.flushBuffer();
+        } catch (IOException ioe) {
+            LOGGER.log(WARNING, ioe, () -> "IOException when flushing async asyncStartResponse buffer");
+        }
+
+        originalResponse.closeAsyncResponse();
+    }
+
+    /**
+     * Process on timeout
+     */
+    public void onTimeOut() {
+        scheduledThreadPoolExecutor.shutdownNow();
+
+        if (!listeners.isEmpty()) {
+            listeners.forEach(listener -> {
+                try {
+                    listener.onTimeout(new AsyncEvent(this));
+                } catch (IOException ioe) {
+                    LOGGER.log(WARNING, ioe, () -> "IOException when calling onTimeout on AsyncListener");
+                }
+            });
+        }
+
+        LOGGER.log(FINE, () -> "Flushing async asyncStartResponse buffer");
+
+        if (!asyncStartResponse.isCommitted()) {
+            try {
+                asyncStartResponse.flushBuffer();
+            } catch (IOException ioe) {
+                LOGGER.log(WARNING, ioe, () -> "IOException when flushing async asyncStartResponse buffer");
+            }
+        }
+
+        originalResponse.closeAsyncResponse();
+    }
+
+    /**
+     * Get the asyncStartRequest.
+     *
+     * @return the asyncStartRequest.
+     * @see AsyncContext#getRequest()
+     */
+    @Override
+    public ServletRequest getRequest() {
+        return asyncStartRequest;
+    }
+
+    /**
+     * Get the asyncStartResponse.
+     *
+     * @return the asyncStartResponse.
+     * @see AsyncContext#getResponse()
+     */
+    @Override
+    public ServletResponse getResponse() {
+        return asyncStartResponse;
+    }
+
+    /**
+     * Get the timeout.
+     *
+     * @return the timeout.
+     * @see AsyncContext#getTimeout()
+     */
+    @Override
+    public long getTimeout() {
+        return timeout;
+    }
+
+    /**
+     * Do we have the original asyncStartRequest and asyncStartResponse?
+     *
+     * @return true if we do, false otherwise.
+     */
+    @Override
+    public boolean hasOriginalRequestAndResponse() {
+        return originalRequest == asyncStartRequest && originalResponse == asyncStartResponse;
+    }
+
+    /**
+     * Set the timeout.
+     *
+     * @param timeout the timeout.
+     */
+    @Override
+    public void setTimeout(long timeout) {
+        this.timeout = timeout;
+    }
+
+    /**
+     * Start the thread.
+     *
+     * @param runnable the runnable.
+     */
+    @Override
+    public void start(Runnable runnable) {
+        LOGGER.log(FINE, "Starting async context with: {0}", runnable);
+        Thread thread = new Thread(runnable);
+        thread.start();
+    }
+
+    /**
+     * Unwrap the servlet request.
+     *
+     * @param <T> the type.
+     * @param request the request to unwrap.
+     * @return the unwrapped request.
+     */
+    @SuppressWarnings("unchecked")
+    private <T extends ServletRequest> T unwrapFully(ServletRequest request) {
+        ServletRequest currentRequest = request;
+        while (currentRequest instanceof ServletRequestWrapper) {
+            ServletRequestWrapper wrapper = (ServletRequestWrapper) currentRequest;
+            currentRequest = wrapper.getRequest();
+        }
+        return (T) currentRequest;
+    }
+
+    /**
+     * Unwrap the servlet response.
+     *
+     * @param <T> the type.
+     * @param response the response to unwrap.
+     * @return the unwrapped response.
+     */
+    @SuppressWarnings("unchecked")
+    private <T extends ServletResponse> T unwrapFully(ServletResponse response) {
+        ServletResponse currentResponse = response;
+        while (currentResponse instanceof ServletResponseWrapper) {
+            ServletResponseWrapper wrapper = (ServletResponseWrapper) currentResponse;
+            currentResponse = wrapper.getResponse();
+        }
+        return (T) currentResponse;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncDispatcher.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncDispatcher.java
new file mode 100644
index 00000000..ec4f3797
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncDispatcher.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import javax.servlet.AsyncContext;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+
+import cloud.piranha.servlet4.webapp.AsyncDispatcher;
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The default AsyncDispatcher.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultAsyncDispatcher implements AsyncDispatcher {
+
+    /**
+     * Stores the web application.
+     */
+    private final WebApplication webApplication;
+    
+    /**
+     * Stores the path.
+     */
+    private final String path;
+    
+    /**
+     * Stores the async start request.
+     */
+    private final ServletRequest asyncStartRequest;
+    
+    /**
+     * Stores the async start response.
+     */
+    private final ServletResponse asyncStartResponse;
+
+
+    /**
+     * Constructor.
+     *
+     * @param webApplication the web application.
+     * @param path the path.
+     * @param asyncStartRequest the request.
+     * @param asyncStartResponse the asyncStartResponse.
+     */
+    public DefaultAsyncDispatcher(WebApplication webApplication, String path, ServletRequest asyncStartRequest, ServletResponse asyncStartResponse) {
+        this.webApplication = webApplication;
+        this.path = path;
+        this.asyncStartRequest = asyncStartRequest;
+        this.asyncStartResponse = asyncStartResponse;
+    }
+
+    @Override
+    public void dispatch() {
+        AsyncContext asyncContext = asyncStartRequest.getAsyncContext();
+        RequestDispatcher requestDispatcher = webApplication.getRequestDispatcher(path);
+
+        new Thread(() -> {
+            Thread.currentThread().setContextClassLoader(webApplication.getClassLoader());
+
+            ServletRequest dispatchedRequest = addAsyncWrapper(asyncStartRequest);
+            try {
+                requestDispatcher.forward(dispatchedRequest, asyncStartResponse);
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+
+            if (!dispatchedRequest.isAsyncStarted()) {
+                asyncContext.complete();
+            }
+
+        }).start();
+    }
+
+    private ServletRequest addAsyncWrapper(ServletRequest request) {
+        if (request instanceof HttpServletRequest) {
+            return new AsyncHttpDispatchWrapper((HttpServletRequest) request);
+        }
+
+        return new AsyncNonHttpDispatchWrapper(request);
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncManager.java
new file mode 100644
index 00000000..c0cc167f
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAsyncManager.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+import cloud.piranha.servlet4.webapp.AsyncDispatcher;
+import cloud.piranha.servlet4.webapp.AsyncManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The default AsyncManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultAsyncManager implements AsyncManager {
+    @Override
+    public AsyncDispatcher getDispatcher(WebApplication webApplication, String path, ServletRequest asyncStartRequest, ServletResponse asyncStartResponse) {
+        return new DefaultAsyncDispatcher(webApplication, path, asyncStartRequest, asyncStartResponse);
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAttributeManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAttributeManager.java
new file mode 100644
index 00000000..c0182f5e
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAttributeManager.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import cloud.piranha.servlet4.webapp.AttributeManager;
+
+/**
+ * The default AttributeManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultAttributeManager implements AttributeManager {
+
+    /**
+     * Stores the attributes.
+     */
+    protected Map<String, Object> attributes;
+
+    /**
+     * Constructor.
+     */
+    public DefaultAttributeManager() {
+        attributes = new ConcurrentHashMap<>();
+    }
+
+    @Override
+    public Object getAttribute(String name) {
+        return attributes.get(name);
+    }
+
+    @Override
+    public Enumeration<String> getAttributeNames() {
+        return Collections.enumeration(attributes.keySet());
+    }
+
+    @Override
+    public void removeAttribute(String name) {
+        attributes.remove(name);
+    }
+
+    @Override
+    public void setAttribute(String name, Object value) {
+        if (value != null) {
+            attributes.put(name, value);
+        } else {
+            attributes.remove(name);
+        }
+    }
+    
+    @Override
+    public boolean containsAttribute(String name) {
+        return attributes.containsKey(name);
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAuthenticatedIdentity.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAuthenticatedIdentity.java
new file mode 100644
index 00000000..68cd490c
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultAuthenticatedIdentity.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static java.util.Collections.unmodifiableSet;
+
+import java.security.Principal;
+import java.util.HashSet;
+import java.util.Set;
+
+import javax.security.auth.Subject;
+
+import cloud.piranha.servlet4.webapp.AuthenticatedIdentity;
+
+/**
+ * Default implementation of AuthenticatedIdentity.
+ *
+ * <p>
+ * This implementation is an immutable structure, with a facility to store it in
+ * TLS. It's the responsibility of the context, e.g. the HTTP request handler,
+ * to remove the identity from TLS at the end of the context (e.g. end of the
+ * HTTP request), or at any other appropriate time (e.g. when logging out
+ * mid-request).
+ *
+ *
+ * @author Arjan Tijms
+ *
+ */
+public class DefaultAuthenticatedIdentity implements AuthenticatedIdentity {
+
+    /**
+     * Stores the current identity.
+     */
+    private static InheritableThreadLocal<AuthenticatedIdentity> currentIdentity = new InheritableThreadLocal<>();
+    
+    /**
+     * Stores the current subject.
+     */
+    private static InheritableThreadLocal<Subject> currentSubject = new InheritableThreadLocal<>();
+
+    /**
+     * Stores the caller principal.
+     */
+    private Principal callerPrincipal;
+    
+    /**
+     * Stores the groups.
+     */
+    private Set<String> groups = new HashSet<>();
+
+    /**
+     * Constructor.
+     * 
+     * @param callerPrincipal the caller principal.
+     * @param groups the groups.
+     */
+    public DefaultAuthenticatedIdentity(Principal callerPrincipal, Set<String> groups) {
+        this.callerPrincipal = callerPrincipal;
+        this.groups = unmodifiableSet(groups);
+    }
+
+    /**
+     * Set the current identity.
+     * 
+     * @param callerPrincipal the caller principal.
+     * @param groups the groups.
+     */
+    public static void setCurrentIdentity(Principal callerPrincipal, Set<String> groups) {
+        setCurrentIdentity(new DefaultAuthenticatedIdentity(callerPrincipal, groups));
+    }
+
+    /**
+     * Set the current identity.
+     * 
+     * @param identity the identity.
+     */
+    public static void setCurrentIdentity(AuthenticatedIdentity identity) {
+        Subject subject = new Subject();
+        subject.getPrincipals().add(identity);
+
+        currentIdentity.set(identity);
+        currentSubject.set(subject);
+    }
+
+    /**
+     * Get the current subject.
+     * 
+     * @return the current subject.
+     */
+    public static Subject getCurrentSubject() {
+        return currentSubject.get();
+    }
+
+    /**
+     * Get the current identity.
+     * 
+     * @return the current identity.
+     */
+    public static AuthenticatedIdentity getCurrentIdentity() {
+        return currentIdentity.get();
+    }
+
+    /**
+     * Clear identity and subject.
+     */
+    public static void clear() {
+        currentIdentity.remove();
+        currentSubject.remove();
+    }
+
+    @Override
+    public Principal getCallerPrincipal() {
+        return callerPrincipal;
+    }
+
+    @Override
+    public Set<String> getGroups() {
+        return groups;
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultCurrentRequestHolder.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultCurrentRequestHolder.java
new file mode 100644
index 00000000..8115324d
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultCurrentRequestHolder.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import javax.servlet.http.HttpServletRequest;
+
+import cloud.piranha.servlet4.webapp.CurrentRequestHolder;
+
+/**
+ * Default implementation of the CurrentRequestHolder interface.
+ *
+ * @author Arjan Tijms
+ *
+ */
+public class DefaultCurrentRequestHolder implements CurrentRequestHolder {
+
+    /**
+     * Stores the HTTP servlet request.
+     */
+    private HttpServletRequest request;
+
+    /**
+     * Constructor.
+     * 
+     * @param request the HTTP servlet request.
+     */
+    public DefaultCurrentRequestHolder(HttpServletRequest request) {
+        this.request = request;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T extends HttpServletRequest> T getRequest() {
+        return (T) request;
+    }
+
+    @Override
+    public void setRequest(HttpServletRequest request) {
+        this.request = request;
+    }
+
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultErrorPageManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultErrorPageManager.java
new file mode 100644
index 00000000..f982ec95
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultErrorPageManager.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletResponse;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ *
+ * @author Arjan Tijms
+ */
+public class DefaultErrorPageManager {
+
+    /**
+     * Stores the error pages by code.
+     */
+    private final Map<Integer, String> errorPagesByCode = new HashMap<>();
+    
+    /**
+     * Stores the error pages by exception.
+     */
+    private final Map<String, String> errorPagesByException = new HashMap<>();
+
+    /**
+     * Get the error pages by code.
+     * 
+     * @return the error pages by code map.
+     */
+    public Map<Integer, String> getErrorPagesByCode() {
+        return errorPagesByCode;
+    }
+
+    /**
+     * Get the error pages by exception.
+     * 
+     * @return the error pages by exception map.
+     */
+    public Map<String, String> getErrorPagesByException() {
+        return errorPagesByException;
+    }
+
+    /**
+     * Get the error page.
+     * 
+     * @param exception the exception.
+     * @param httpResponse the HTTP servlet response.
+     * @return the error page.
+     */
+    public String getErrorPage(Throwable exception, HttpServletResponse httpResponse) {
+        if (exception != null) {
+            Class<?> rootException = exception.getClass();
+            String page = null;
+            while (rootException != null && page == null) {
+                page = errorPagesByException.get(rootException.getName());
+                rootException = rootException.getSuperclass();
+            }
+
+            if (page == null && exception instanceof ServletException) {
+                page = getErrorPage(((ServletException) exception).getRootCause(), httpResponse);
+            }
+
+            return page;
+        }
+
+
+        if (httpResponse.getStatus() >= 400) {
+            return errorPagesByCode.get(httpResponse.getStatus());
+        }
+
+        // No error
+        return null;
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterChain.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterChain.java
new file mode 100644
index 00000000..a85ccd99
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterChain.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
+
+import java.io.IOException;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.UnavailableException;
+import javax.servlet.http.HttpServletResponse;
+
+import cloud.piranha.servlet4.webapp.ServletInvocation;
+
+/**
+ * The default FilterChain.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultFilterChain implements FilterChain {
+
+    /**
+     * Stores the filter.
+     */
+    private Filter filter;
+
+    /**
+     * Stores the next filter chain.
+     */
+    private FilterChain nextFilterChain;
+
+    /**
+     *
+     */
+    private ServletInvocation servletInvocation;
+
+    /**
+     * Stores the servlet.
+     */
+    private Servlet servlet;
+
+    /**
+     * Constructor.
+     */
+    public DefaultFilterChain() {
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param servletInvocation the servlet invocation.
+     * @param servlet the servlet.
+     */
+    public DefaultFilterChain(ServletInvocation servletInvocation, Servlet servlet) {
+        this.servletInvocation = servletInvocation;
+        this.servlet = servlet;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param filter the filter.
+     * @param nextFilterChain the next filter chain.
+     */
+    public DefaultFilterChain(Filter filter, FilterChain nextFilterChain) {
+        this.filter = filter;
+        this.nextFilterChain = nextFilterChain;
+    }
+
+    /**
+     * Process the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {
+        if (filter != null) {
+            filter.doFilter(request, response, nextFilterChain);
+        } else if (servlet != null) {
+            request.setAttribute(DefaultServletEnvironment.class.getName(), servlet.getServletConfig());
+            try {
+                servlet.service(request, response);
+            } finally {
+                request.removeAttribute(DefaultServletEnvironment.class.getName());
+            }
+        } else if (servletInvocation != null && servletInvocation.isServletUnavailable()) {
+            // We've reached the servlet, but the servlet is not available (for instance because
+            // the init method failed)
+            Exception exception;
+            Throwable throwable = servletInvocation.getServletEnvironment().getUnavailableException();
+            if (throwable instanceof Exception) {
+                exception = (Exception) throwable;
+            } else {
+                exception = new UnavailableException("");
+                exception.initCause(throwable);
+            }
+
+            if (response instanceof HttpServletResponse) {
+                ((HttpServletResponse) response).setStatus(500);
+            }
+
+            request.setAttribute("piranha.request.exception", exception);
+            throw new ServletException(exception);
+
+        } else if (response instanceof HttpServletResponse) {
+            ((HttpServletResponse) response).sendError(SC_NOT_FOUND);
+        }
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterEnvironment.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterEnvironment.java
new file mode 100644
index 00000000..47512488
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterEnvironment.java
@@ -0,0 +1,381 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Stream;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.Filter;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+
+import cloud.piranha.servlet4.webapp.FilterEnvironment;
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The default FilterEnvironment.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultFilterEnvironment implements FilterEnvironment {
+
+    /**
+     * Stores the async supported flag.
+     */
+    private boolean asyncSupported;
+
+    /**
+     * Stores the class name.
+     */
+    private String className;
+
+    /**
+     * Stores the filter.
+     */
+    private Filter filter;
+    /**
+     * Stores the filter name.
+     */
+    private String filterName;
+    /**
+     * Stores the init parameters.
+     */
+    private HashMap<String, String> initParameters;
+
+    /**
+     * Stores the servlet mame mappings.
+     */
+    private ConcurrentHashMap<String, String> servletNameMappings;
+
+    /**
+     * Stores the status.
+     */
+    private int status;
+
+    /**
+     * Stores the url pattern mappings.
+     */
+    private ConcurrentHashMap<String, String> urlPatternMappings;
+
+    /**
+     * Stores the web application.
+     */
+    private WebApplication webApplication;
+
+    /**
+     * Constructor.
+     */
+    public DefaultFilterEnvironment() {
+        initParameters = new HashMap<>();
+        servletNameMappings = new ConcurrentHashMap<>();
+        urlPatternMappings = new ConcurrentHashMap<>();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param webApp the web application.
+     * @param filterName the filter name.
+     * @param filter the filter.
+     */
+    public DefaultFilterEnvironment(WebApplication webApp, String filterName, Filter filter) {
+        this();
+        this.webApplication = webApp;
+        this.filterName = filterName;
+        this.filter = filter;
+        this.className = filter.getClass().getName();
+    }
+
+    /**
+     * Add the mappings for the servlet names.
+     *
+     * @param dispatcherTypes the dispatcher types.
+     * @param isMatchAfter is a matcher after.
+     * @param servletNames the servlet names.
+     */
+    @Override
+    public void addMappingForServletNames(EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter, String... servletNames) {
+        String[] names = Stream.of(servletNames).map(s -> "servlet:// " + s).toArray(String[]::new);
+        webApplication.addFilterMapping(dispatcherTypes, filterName, isMatchAfter, names);
+        Arrays.stream(servletNames).forEach(x -> servletNameMappings.put(x, filterName));
+    }
+
+    /**
+     * Add the mappings.
+     *
+     * @param dispatcherTypes the dispatcher types.
+     * @param isMatchAfter true to call the filter this mapping applies to after declared ones, false to call it before declared ones.
+     * @param urlPatterns the url patterns.
+     */
+    @Override
+    public void addMappingForUrlPatterns(EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter, String... urlPatterns) {
+        webApplication.addFilterMapping(dispatcherTypes, filterName, isMatchAfter, urlPatterns);
+        Arrays.stream(urlPatterns).forEach(x -> urlPatternMappings.put(x, filterName));
+    }
+
+    /**
+     * Get the class name.
+     *
+     * @return the class name.
+     */
+    @Override
+    public String getClassName() {
+        return className;
+    }
+
+    /**
+     * Get the filter.
+     *
+     * @return the filter.
+     */
+    @Override
+    public Filter getFilter() {
+        return filter;
+    }
+
+    /**
+     * Get the filter name.
+     *
+     * @return the filter name.
+     */
+    @Override
+    public String getFilterName() {
+        return filterName;
+    }
+
+    /**
+     * Get the init parameter.
+     *
+     * @param name the name
+     * @return the value.
+     */
+    @Override
+    public String getInitParameter(String name) {
+        return initParameters.get(name);
+    }
+
+    /**
+     * Get the init parameter names.
+     *
+     * @return the enumeration.
+     */
+    @Override
+    public Enumeration<String> getInitParameterNames() {
+        return Collections.enumeration(initParameters.keySet());
+    }
+
+    /**
+     * Get the init parameters.
+     *
+     * @return the init parameters.
+     */
+    @Override
+    public Map<String, String> getInitParameters() {
+        return initParameters;
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    @Override
+    public String getName() {
+        return filterName;
+    }
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    @Override
+    public ServletContext getServletContext() {
+        return this.webApplication;
+    }
+
+    /**
+     * Get the servlet name mappings.
+     *
+     * @return the servlet name mappings.
+     */
+    @Override
+    public Collection<String> getServletNameMappings() {
+        return Collections.unmodifiableCollection(servletNameMappings.keySet());
+    }
+
+    /**
+     * Get the URL pattern mappings.
+     *
+     * @return the URL pattern mappings.
+     */
+    @Override
+    public Collection<String> getUrlPatternMappings() {
+        return Collections.unmodifiableCollection(urlPatternMappings.keySet());
+    }
+
+    /**
+     * Get the web application.
+     *
+     * @return the web application.
+     */
+    @Override
+    public WebApplication getWebApplication() {
+        return webApplication;
+    }
+
+    /**
+     * Initialize the filter.
+     *
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public void initialize() throws ServletException {
+        if (filter == null) {
+            try {
+                Class<? extends Filter> clazz = webApplication.getClassLoader().loadClass(className).asSubclass(Filter.class);
+                filter = webApplication.createFilter(clazz);
+            } catch (Throwable throwable) {
+                throw new ServletException("Unable to initialize the filter", throwable);
+            }
+        }
+    }
+
+    /**
+     * Set async supported.
+     *
+     * @param asyncSupported the async supported flag.
+     */
+    @Override
+    public void setAsyncSupported(boolean asyncSupported) {
+        this.asyncSupported = asyncSupported;
+    }
+
+    /**
+     * Set the class name.
+     *
+     * @param className the class name.
+     */
+    @Override
+    public void setClassName(String className) {
+        this.className = className;
+    }
+
+    /**
+     * Set the filter name.
+     *
+     * @param filterName the filter name.
+     */
+    @Override
+    public void setFilterName(String filterName) {
+        this.filterName = filterName;
+    }
+
+    /**
+     * Set the init parameter.
+     *
+     * @param name the parameter name.
+     * @param value the parameter value.
+     * @return if the init parameter was set.
+     */
+    @Override
+    public boolean setInitParameter(String name, String value) {
+        boolean result = false;
+        if (!initParameters.containsKey(name)) {
+            initParameters.put(name, value);
+            result = true;
+        }
+        return result;
+    }
+
+    /**
+     * Set the init parameters.
+     *
+     * @param initParameters the init parameters
+     * @return the set of conflicting parameter names.
+     */
+    @Override
+    public Set<String> setInitParameters(Map<String, String> initParameters) {
+        HashSet<String> conflicting = new HashSet<>();
+        if (initParameters != null) {
+            initParameters.entrySet().forEach(entry -> {
+                String name = entry.getKey();
+                String value = entry.getValue();
+                if (name == null) {
+                    throw new IllegalArgumentException("A null name is not allowed");
+                }
+                if (value == null) {
+                    throw new IllegalArgumentException("A null value is not allowed");
+                }
+                if (!setInitParameter(name, value)) {
+                    conflicting.add(name);
+                }
+            });
+        }
+        return conflicting;
+    }
+
+    /**
+     * Set status.
+     *
+     * @param status the status.
+     */
+    @Override
+    public void setStatus(int status) {
+        this.status = status;
+    }
+
+    @Override
+    public void setWebApplication(WebApplication webApplication) {
+        this.webApplication = webApplication;
+    }
+
+    @Override
+    public boolean isAsyncSupported() {
+        return asyncSupported;
+    }
+
+    @Override
+    public String toString() {
+        return
+            (className != null? className : "") + " " +
+            (!urlPatternMappings.isEmpty()? urlPatternMappings : "") +
+            (!servletNameMappings.isEmpty()? servletNameMappings : "") + " " +
+            super.toString();
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterMapping.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterMapping.java
new file mode 100644
index 00000000..a110be9a
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultFilterMapping.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static javax.servlet.DispatcherType.REQUEST;
+
+import java.util.Objects;
+
+import javax.servlet.DispatcherType;
+
+import cloud.piranha.servlet4.webapp.FilterMapping;
+
+/**
+ * The default FilterMapping.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultFilterMapping implements FilterMapping {
+
+    /**
+     * Stores the dispatcher type.
+     */
+    private final DispatcherType dispatcherType;
+
+    /**
+     * Stores the filter name.
+     */
+    private final String filterName;
+
+    /**
+     * Stores the URL pattern.
+     */
+    private final String urlPattern;
+
+
+    /**
+     * Constructor.
+     *
+     * @param filterName the filter name.
+     * @param urlPattern the URL pattern.
+     */
+    public DefaultFilterMapping(String filterName, String urlPattern) {
+        this(REQUEST, filterName, urlPattern);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param dispatcherType the dispatcher type.
+     * @param filterName the filter name.
+     * @param urlPattern the URL pattern.
+     */
+    public DefaultFilterMapping(DispatcherType dispatcherType, String filterName, String urlPattern) {
+        this.dispatcherType = dispatcherType;
+        this.filterName = filterName;
+        this.urlPattern = urlPattern;
+    }
+
+    /**
+     * Equals.
+     *
+     * @param object the object to compare against.
+     * @return true if equal, false otherwise.
+     */
+    @Override
+    public boolean equals(Object object) {
+        if (object instanceof DefaultFilterMapping == false) {
+            return false;
+        }
+
+        boolean result = false;
+        DefaultFilterMapping mapping = (DefaultFilterMapping) object;
+        if (mapping.filterName.equals(filterName)
+                && mapping.urlPattern.equals(urlPattern)
+                && mapping.dispatcherType.equals(dispatcherType)
+                ) {
+            result = true;
+        }
+
+        return result;
+    }
+
+    /**
+     * Get the dispatcher type.
+     *
+     * @return the dispatcher type.
+     */
+    @Override
+    public DispatcherType getDispatcherType() {
+        return dispatcherType;
+    }
+
+    /**
+     * Get the filter name.
+     *
+     * @return the filter name.
+     */
+    @Override
+    public String getFilterName() {
+        return filterName;
+    }
+
+    /**
+     * Get the URL pattern.
+     *
+     * @return the URL pattern.
+     */
+    @Override
+    public String getUrlPattern() {
+        return urlPattern;
+    }
+
+    /**
+     * Hash code.
+     *
+     * @return the hash code.
+     */
+    @Override
+    public int hashCode() {
+        int hash = 7;
+        hash = 83 * hash + Objects.hashCode(this.filterName);
+        hash = 83 * hash + Objects.hashCode(this.urlPattern);
+        return hash;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpHeader.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpHeader.java
new file mode 100644
index 00000000..dbd6b041
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpHeader.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+
+import cloud.piranha.servlet4.webapp.HttpHeader;
+
+/**
+ * The default HttpHeader.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultHttpHeader implements HttpHeader {
+
+    /**
+     * Stores the name.
+     */
+    private final String name;
+    /**
+     * Stores the values.
+     */
+    private final ArrayList<String> values = new ArrayList<>();
+
+    /**
+     * Constructor.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    public DefaultHttpHeader(String name, String value) {
+        this.name = name;
+        values.add(value);
+    }
+
+    /**
+     * Add the value.
+     *
+     * @param value the value to add.
+     */
+    @Override
+    public void addValue(String value) {
+        values.add(value);
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    @Override
+    public String getName() {
+        return this.name;
+    }
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    @Override
+    public String getValue() {
+        return values.get(0);
+    }
+
+    /**
+     * Get the values.
+     *
+     * @return the values.
+     */
+    @Override
+    public Enumeration<String> getValues() {
+        return Collections.enumeration(values);
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpHeaderManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpHeaderManager.java
new file mode 100644
index 00000000..34786ebf
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpHeaderManager.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+
+import cloud.piranha.servlet4.webapp.HttpHeaderManager;
+
+/**
+ * The default HttpHeaderManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultHttpHeaderManager implements HttpHeaderManager {
+
+    /**
+     * Stores the headers.
+     */
+    protected final HashMap<String, DefaultHttpHeader> headers;
+
+    /**
+     * Stores the Locale.
+     */
+    private Locale locale;
+
+    /**
+     * Constructor.
+     */
+    public DefaultHttpHeaderManager() {
+        headers = new HashMap<>();
+        locale = new Locale("en", "US", "ISO-8859-1");
+    }
+
+    /**
+     * Add the header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    @Override
+    public void addHeader(String name, String value) {
+        if (headers.containsKey(name.toUpperCase(locale))) {
+            headers.get(name.toUpperCase(locale)).addValue(value);
+        } else {
+            DefaultHttpHeader header = new DefaultHttpHeader(name, value);
+            headers.put(name.toUpperCase(locale), header);
+        }
+    }
+
+    /**
+     * Contains the given header.
+     *
+     * @param name the header name.
+     * @return true if there, false otherwise.
+     */
+    @Override
+    public boolean containsHeader(String name) {
+        return headers.containsKey(name.toUpperCase(locale));
+    }
+
+    /**
+     * Get the date header.
+     *
+     * @param name the header name.
+     * @return the date header.
+     */
+    @Override
+    public long getDateHeader(String name) throws IllegalArgumentException {
+        long result = -1;
+        if (headers.containsKey(name.toUpperCase(locale))) {
+            DefaultHttpHeader header = headers.get(name.toUpperCase(locale));
+            try {
+                String value = header.getValue();
+                SimpleDateFormat format = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz");
+                result = format.parse(value).getTime();
+            } catch (ParseException exception) {
+                throw new IllegalArgumentException(
+                        "Cannot convert header to a date", exception);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Get the header.
+     *
+     * @param name the header name.
+     * @return the header value.
+     */
+    @Override
+    public String getHeader(String name) {
+        String result = null;
+        if (headers.containsKey(name.toUpperCase(locale))) {
+            result = headers.get(name.toUpperCase(locale)).getValue();
+        }
+        return result;
+    }
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    @Override
+    public Enumeration<String> getHeaderNames() {
+        List<String> names = new ArrayList<>();
+        Iterator<DefaultHttpHeader> iterator = headers.values().iterator();
+        while (iterator.hasNext()) {
+            DefaultHttpHeader header = iterator.next();
+            names.add(header.getName());
+        }
+        return Collections.enumeration(names);
+    }
+
+    /**
+     * Get the headers.
+     *
+     * @param name the header name.
+     * @return the header values.
+     */
+    @Override
+    public Enumeration<String> getHeaders(String name) {
+        Enumeration<String> result = Collections.enumeration(Collections.emptyList());
+        if (headers.containsKey(name.toUpperCase(locale))) {
+            result = headers.get(name.toUpperCase(locale)).getValues();
+        }
+        return result;
+    }
+
+    /**
+     * Get the int header.
+     *
+     * @param name the header name.
+     * @return the int header.
+     */
+    @Override
+    public int getIntHeader(String name) throws NumberFormatException {
+        int result = -1;
+        if (headers.containsKey(name.toUpperCase(locale))) {
+            DefaultHttpHeader header = headers.get(name.toUpperCase(locale));
+            try {
+                result = Integer.parseInt(header.getValue());
+            } catch (NumberFormatException exception) {
+                throw new NumberFormatException(
+                        "Cannot convert header to an int");
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Set the header.
+     *
+     * @param name the name.
+     * @param value the value (string).
+     */
+    @Override
+    public void setHeader(String name, String value) {
+        DefaultHttpHeader header = new DefaultHttpHeader(name, value);
+        headers.put(name.toUpperCase(locale), header);
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpRequestManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpRequestManager.java
new file mode 100644
index 00000000..59dfb823
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpRequestManager.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.ArrayList;
+import java.util.EventListener;
+import java.util.List;
+
+import javax.servlet.ServletRequestAttributeEvent;
+import javax.servlet.ServletRequestAttributeListener;
+import javax.servlet.http.HttpServletRequest;
+
+import cloud.piranha.servlet4.webapp.HttpRequestManager;
+
+/**
+ *
+ * @author Arjan Tijms
+ *
+ */
+public class DefaultHttpRequestManager implements HttpRequestManager {
+
+    /**
+     * Stores the session listeners.
+     */
+    private final List<ServletRequestAttributeListener> attributeListeners = new ArrayList<>();
+
+    @Override
+    public <T extends EventListener> void addListener(T listener) {
+        if (listener instanceof ServletRequestAttributeListener) {
+            attributeListeners.add((ServletRequestAttributeListener) listener);
+        }
+    }
+
+    @Override
+    public void attributeAdded(HttpServletRequest request, String name, Object value) {
+        attributeListeners.stream().forEach(listener -> listener.attributeAdded(new ServletRequestAttributeEvent(request.getServletContext(), request, name, value)));
+    }
+
+    @Override
+    public void attributeRemoved(HttpServletRequest request, String name, Object value) {
+        attributeListeners.stream().forEach(listener -> listener.attributeRemoved(new ServletRequestAttributeEvent(request.getServletContext(), request, name, value)));
+    }
+
+    @Override
+    public void attributeReplaced(HttpServletRequest request, String name, Object value) {
+        attributeListeners.stream().forEach(listener -> listener.attributeReplaced(new ServletRequestAttributeEvent(request.getServletContext(), request, name, value)));
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpSession.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpSession.java
new file mode 100644
index 00000000..4e583046
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpSession.java
@@ -0,0 +1,374 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.UUID;
+
+import javax.servlet.ServletContext;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionContext;
+
+import cloud.piranha.servlet4.webapp.HttpSessionManager;
+
+/**
+ * The default HttpSession.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+@SuppressWarnings("deprecation")
+public class DefaultHttpSession implements HttpSession {
+
+    /**
+     * Stores the attributes.
+     */
+    private HashMap<String, Object> attributes = new HashMap<>();
+
+    /**
+     * Stores the creation time.
+     */
+    private long creationTime;
+
+    /**
+     * Stores the session id.
+     */
+    private String id;
+
+    /**
+     * Stores the last accessed time.
+     */
+    private long lastAccessedTime;
+
+    /**
+     * Stores the max inactive interval.
+     */
+    private int maxInactiveInterval;
+
+    /**
+     * Stores if the session is new.
+     */
+    private boolean newFlag;
+
+    /**
+     * Stores the servlet context.
+     */
+    private ServletContext servletContext;
+
+    /**
+     * Stores the HTTP session manager.
+     */
+    private HttpSessionManager sessionManager;
+
+    /**
+     * Stores the valid flag.
+     */
+    private boolean valid;
+
+    /**
+     * Constructor.
+     *
+     * @param servletContext the servlet context.
+     */
+    public DefaultHttpSession(ServletContext servletContext) {
+        this.id = UUID.randomUUID().toString();
+        this.servletContext = servletContext;
+        this.creationTime = System.currentTimeMillis();
+        this.lastAccessedTime = System.currentTimeMillis();
+        this.valid = true;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param servletContext the servlet context.
+     * @param id the id.
+     * @param newFlag the new flag.
+     */
+    public DefaultHttpSession(ServletContext servletContext, String id, boolean newFlag) {
+        this.id = id;
+        this.servletContext = servletContext;
+        this.newFlag = newFlag;
+        this.creationTime = System.currentTimeMillis();
+        this.lastAccessedTime = System.currentTimeMillis();
+        this.valid = true;
+    }
+
+    /**
+     * Get the attribute value.
+     *
+     * @param name the attribute name.
+     * @return the attribute value.
+     * @see HttpSession#getAttribute(java.lang.String)
+     */
+    @Override
+    public Object getAttribute(String name) {
+        verifyValid("getAttribute");
+        return this.attributes.get(name);
+    }
+
+    /**
+     * Get the attribute names.
+     *
+     * @return the attribute names.
+     * @see HttpSession#getAttributeNames()
+     */
+    @Override
+    public Enumeration<String> getAttributeNames() {
+        verifyValid("getAttributeNames");
+        return Collections.enumeration(attributes.keySet());
+    }
+
+    /**
+     * Get the creation time.
+     *
+     * @return the creation time.
+     * @see HttpSession#getCreationTime()
+     */
+    @Override
+    public long getCreationTime() {
+        verifyValid("getCreationTime");
+        return this.creationTime;
+    }
+
+    /**
+     * Get the id.
+     *
+     * @return the id.
+     * @see HttpSession#getId()
+     */
+    @Override
+    public String getId() {
+        return this.id;
+    }
+
+    /**
+     * Get the last accessed time.
+     *
+     * @return the last accessed time.
+     * @see HttpSession#getLastAccessedTime()
+     */
+    @Override
+    public long getLastAccessedTime() {
+        verifyValid("getLastAccessedTime");
+        return this.lastAccessedTime;
+    }
+
+    /**
+     * Get the maximum inactive interval.
+     *
+     * @return the maximum inactive interval.
+     * @see HttpSession#getMaxInactiveInterval()
+     */
+    @Override
+    public int getMaxInactiveInterval() {
+        return this.maxInactiveInterval;
+    }
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     * @see HttpSession#getServletContext()
+     */
+    @Override
+    public ServletContext getServletContext() {
+        return servletContext;
+    }
+
+    /**
+     * Get the session context.
+     *
+     * @return null
+     * @see HttpSession#getSessionContext()
+     */
+    @Override
+    public HttpSessionContext getSessionContext() {
+        return null;
+    }
+
+    /**
+     * Get the value.
+     *
+     * @param name the attribute name.
+     * @return the value.
+     * @see HttpSession#getValue(java.lang.String)
+     */
+    @Override
+    public Object getValue(String name) {
+        return getAttribute(name);
+    }
+
+    /**
+     * Get the attribute names.
+     *
+     * @return the attribute names.
+     * @see HttpSession#getValueNames()
+     */
+    @Override
+    public String[] getValueNames() {
+        verifyValid("getValueNames");
+        return this.attributes.keySet().toArray(new String[0]);
+    }
+
+    /**
+     * Invalidate the session.
+     *
+     * @see HttpSession#invalidate()
+     */
+    @Override
+    public void invalidate() {
+        verifyValid("invalidate");
+        sessionManager.destroySession(this);
+        this.valid = false;
+    }
+
+    /**
+     * Is the session new.
+     *
+     * @return true if it is, false otherwise.
+     * @see HttpSession#isNew()
+     */
+    @Override
+    public boolean isNew() {
+        verifyValid("isNew");
+        return this.newFlag;
+    }
+
+    /**
+     * Set the value.
+     *
+     * @param name the attribute name.
+     * @param value the attribute value.
+     * @see HttpSession#putValue(java.lang.String, java.lang.Object)
+     */
+    @Override
+    public void putValue(String name, Object value) {
+        setAttribute(name, value);
+    }
+
+    /**
+     * Remove the attribute.
+     *
+     * @param name the attribute name.
+     * @see HttpSession#removeAttribute(java.lang.String)
+     */
+    @Override
+    public void removeAttribute(String name) {
+        verifyValid("removeAttribute");
+        sessionManager.attributeRemoved(this, name, attributes.remove(name));
+    }
+
+    /**
+     * Remove the value.
+     *
+     * @param name the attribute name.
+     * @see HttpSession#removeValue(java.lang.String)
+     */
+    @Override
+    public void removeValue(String name) {
+        removeAttribute(name);
+    }
+
+    /**
+     * Set the attribute.
+     *
+     * @param name the attribute name.
+     * @param value the attribute value.
+     * @see HttpSession#setAttribute(java.lang.String, java.lang.Object)
+     */
+    @Override
+    public void setAttribute(String name, Object value) {
+        verifyValid("setAttribute");
+        if (value != null) {
+            boolean added = true;
+            if (attributes.containsKey(name)) {
+                added = false;
+            }
+            Object oldValue = attributes.put(name, value);
+            if (added) {
+                sessionManager.attributeAdded(this, name, value);
+            } else {
+                sessionManager.attributeReplaced(this, name, oldValue, value);
+            }
+        } else {
+            removeAttribute(name);
+        }
+    }
+
+    /**
+     * Set the id.
+     *
+     * @param id the id.
+     */
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    /**
+     * Set the maximum inactive interval.
+     *
+     * @param maxInactiveInterval the maximum inactive interval.
+     * @see HttpSession#setMaxInactiveInterval(int)
+     */
+    @Override
+    public void setMaxInactiveInterval(int maxInactiveInterval) {
+        this.maxInactiveInterval = maxInactiveInterval;
+    }
+
+    /**
+     * Set the new flag.
+     *
+     * @param newFlag the new flag.
+     */
+    public void setNew(boolean newFlag) {
+        verifyValid("setNew");
+        this.newFlag = newFlag;
+    }
+
+    /**
+     * Set the HTTP session manager.
+     *
+     * @param sessionManager the HTTP session manager.
+     */
+    public void setSessionManager(HttpSessionManager sessionManager) {
+        this.sessionManager = sessionManager;
+    }
+
+    /**
+     * Verify if the session is valid.
+     *
+     * @param methodName the method name.
+     */
+    private void verifyValid(String methodName) {
+        if (!valid) {
+            throw new IllegalStateException("Session is invalid, called by: " + methodName);
+        }
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpSessionManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpSessionManager.java
new file mode 100644
index 00000000..b6399ab9
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultHttpSessionManager.java
@@ -0,0 +1,514 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.webapp.HttpSessionManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.EventListener;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.servlet.SessionCookieConfig;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionAttributeListener;
+import javax.servlet.http.HttpSessionBindingEvent;
+import javax.servlet.http.HttpSessionBindingListener;
+import javax.servlet.http.HttpSessionEvent;
+import javax.servlet.http.HttpSessionIdListener;
+import javax.servlet.http.HttpSessionListener;
+
+/**
+ * The default HttpSessionManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultHttpSessionManager implements HttpSessionManager, SessionCookieConfig {
+
+    /**
+     * Stores the session listeners.
+     */
+    protected final ArrayList<HttpSessionAttributeListener> attributeListeners;
+
+    /**
+     * Stores the comment.
+     */
+    protected String comment;
+
+    /**
+     * Stores the default session tracking modes.
+     */
+    protected final Set<SessionTrackingMode> defaultSessionTrackingModes;
+
+    /**
+     * Stores the domain.
+     */
+    protected String domain;
+
+    /**
+     * Stores the HTTP only flag.
+     */
+    protected boolean httpOnly;
+
+    /**
+     * Stores the session id listeners.
+     */
+    protected final ArrayList<HttpSessionIdListener> idListeners;
+
+    /**
+     * Stores the max age.
+     */
+    protected int maxAge;
+
+    /**
+     * Stores the name.
+     */
+    protected String name;
+
+    /**
+     * Stores the path.
+     */
+    protected String path;
+
+    /**
+     * Stores the secure flag.
+     */
+    protected boolean secure;
+
+    /**
+     * Stores the session listeners.
+     */
+    protected final ArrayList<HttpSessionListener> sessionListeners;
+
+    /**
+     * Stores the session timeout (in minutes).
+     */
+    protected int sessionTimeout;
+
+    /**
+     * Stores the session tracking modes.
+     */
+    protected Set<SessionTrackingMode> sessionTrackingModes;
+
+    /**
+     * Stores the sessions.
+     */
+    protected Map<String, HttpSession> sessions;
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Constructor.
+     */
+    public DefaultHttpSessionManager() {
+        attributeListeners = new ArrayList<>(1);
+        defaultSessionTrackingModes = EnumSet.of(SessionTrackingMode.COOKIE);
+        sessionTrackingModes = defaultSessionTrackingModes;
+        idListeners = new ArrayList<>(1);
+        name = "JSESSIONID";
+        sessionListeners = new ArrayList<>(1);
+        sessionTimeout = 10;
+        maxAge = -1;
+        sessions = new ConcurrentHashMap<>();
+    }
+
+    @Override
+    public synchronized HttpSession createSession(HttpServletRequest request) {
+        String sessionId = UUID.randomUUID().toString();
+        DefaultHttpSession session = new DefaultHttpSession(webApplication, sessionId, true);
+        session.setSessionManager(this);
+        sessions.put(sessionId, session);
+
+        HttpServletResponse response = (HttpServletResponse) webApplication.getResponse(request);
+        Cookie cookie = new Cookie(name, sessionId);
+
+        if (path != null) {
+            cookie.setPath(path);
+        } else {
+            cookie.setPath("".equals(webApplication.getContextPath()) ? "/" : webApplication.getContextPath());
+        }
+
+        cookie.setComment(comment);
+        cookie.setDomain(domain);
+        cookie.setHttpOnly(httpOnly);
+        cookie.setMaxAge(maxAge);
+        cookie.setSecure(secure);
+
+        response.addCookie(cookie);
+
+        sessionListeners.stream().forEach(sessionListener -> sessionListener.sessionCreated(new HttpSessionEvent(session)));
+
+        return session;
+    }
+
+    @Override
+    public HttpSession getSession(HttpServletRequest request, String currentSessionId) {
+        return sessions.get(currentSessionId);
+    }
+
+    /**
+     * Change the session id.
+     *
+     * @param request the request.
+     * @return the session id.
+     */
+    @Override
+    public String changeSessionId(HttpServletRequest request) {
+        HttpSession session = request.getSession(false);
+        if (session == null) {
+            throw new IllegalStateException("No session active");
+        }
+
+        String oldSessionId = session.getId();
+        sessions.remove(oldSessionId);
+        String sessionId = UUID.randomUUID().toString();
+        DefaultHttpSession newSession = (DefaultHttpSession) session;
+        newSession.setId(sessionId);
+        sessions.put(sessionId, session);
+
+        idListeners.stream().forEach(idListener -> idListener.sessionIdChanged(new HttpSessionEvent(session), oldSessionId));
+
+        return sessionId;
+    }
+
+    /**
+     * Add a listener.
+     *
+     * @param <T> the type.
+     * @param listener the listener.
+     */
+    @Override
+    public <T extends EventListener> void addListener(T listener) {
+        if (listener instanceof HttpSessionAttributeListener) {
+            attributeListeners.add((HttpSessionAttributeListener) listener);
+        }
+
+        if (listener instanceof HttpSessionIdListener) {
+            idListeners.add((HttpSessionIdListener) listener);
+        }
+
+        if (listener instanceof HttpSessionListener) {
+            sessionListeners.add((HttpSessionListener) listener);
+        }
+    }
+
+    /**
+     * Attribute added.
+     *
+     * @param session the HTTP session.
+     * @param name the name.
+     * @param value the value.
+     */
+    @Override
+    public void attributeAdded(HttpSession session, String name, Object value) {
+        attributeListeners.stream().forEach(listener -> listener.attributeAdded(new HttpSessionBindingEvent(session, name, value)));
+        if (value instanceof HttpSessionBindingListener){
+            ((HttpSessionBindingListener) value).valueBound(new HttpSessionBindingEvent(session, name));
+        }
+    }
+
+    /**
+     * Attribute replaced.
+     *
+     * @param session the HTTP session.
+     * @param name the name.
+     * @param oldValue the old value.
+     * @param newValue the new value.
+     */
+    @Override
+    public void attributeReplaced(HttpSession session, String name, Object oldValue, Object newValue) {
+        attributeListeners.stream().forEach(listener -> listener.attributeReplaced(new HttpSessionBindingEvent(session, name, oldValue)));
+        if (oldValue instanceof HttpSessionBindingListener)
+            ((HttpSessionBindingListener) oldValue).valueUnbound(new HttpSessionBindingEvent(session, name));
+        if (newValue instanceof HttpSessionBindingListener)
+            ((HttpSessionBindingListener) newValue).valueBound(new HttpSessionBindingEvent(session, name));
+    }
+
+    @Override
+    public void attributeRemoved(HttpSession session, String name, Object value) {
+        attributeListeners.stream().forEach(listener -> listener.attributeRemoved(new HttpSessionBindingEvent(session, name, value)));
+        if (value instanceof HttpSessionBindingListener){
+            ((HttpSessionBindingListener) value).valueUnbound(new HttpSessionBindingEvent(session, name));
+        }
+    }
+
+    /**
+     * Destroy the session.
+     *
+     * @param session the session.
+     */
+    @Override
+    public synchronized void destroySession(HttpSession session) {
+        sessionListeners.stream().forEach(sessionListener -> sessionListener.sessionDestroyed(new HttpSessionEvent(session)));
+        sessions.remove(session.getId());
+    }
+
+    /**
+     * Encode the redirect URL.
+     *
+     * @param response the response.
+     * @param url the redirect url.
+     * @return the encoded redirect url.
+     */
+    @Override
+    public String encodeRedirectURL(HttpServletResponse response, String url) {
+        return url;
+    }
+
+    /**
+     * Encode the URL.
+     *
+     * @param response the response.
+     * @param url the url.
+     * @return the encoded url.
+     */
+    @Override
+    public String encodeURL(HttpServletResponse response, String url) {
+        return url;
+    }
+
+    /**
+     * Get the comment.
+     *
+     * @return the comment.
+     */
+    @Override
+    public String getComment() {
+        return comment;
+    }
+
+    /**
+     * Get the default session tracking modes.
+     *
+     * @return the default session tracking modes.
+     */
+    @Override
+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {
+        return Collections.unmodifiableSet(defaultSessionTrackingModes);
+    }
+
+    /**
+     * Get the domain.
+     *
+     * @return the domain.
+     */
+    @Override
+    public String getDomain() {
+        return domain;
+    }
+
+    /**
+     * Get the effective session tracking modes.
+     *
+     * @return the effective session tracking modes.
+     */
+    @Override
+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {
+        return Collections.unmodifiableSet(sessionTrackingModes);
+    }
+
+    /**
+     * Get the max age.
+     *
+     * @return the max age.
+     */
+    @Override
+    public int getMaxAge() {
+        return maxAge;
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the path.
+     *
+     * @return the path.
+     */
+    @Override
+    public String getPath() {
+        return path;
+    }
+
+    /**
+     * Get the session cookie config.
+     *
+     * @return the session cookie config.
+     */
+    @Override
+    public SessionCookieConfig getSessionCookieConfig() {
+        return this;
+    }
+
+    /**
+     * Get the session timeout (in minutes).
+     *
+     * @return the session timeout.
+     */
+    @Override
+    public int getSessionTimeout() {
+        return sessionTimeout;
+    }
+
+    /**
+     * Has a session with the given id.
+     *
+     * @param sessionId the session id.
+     * @return true if there is one, false otherwise.
+     */
+    @Override
+    public boolean hasSession(String sessionId) {
+        return sessionId != null ? sessions.containsKey(sessionId) : false;
+    }
+
+    /**
+     * Is HTTP only?
+     *
+     * @return true if HTTP only, false otherwise.
+     */
+    @Override
+    public boolean isHttpOnly() {
+        return httpOnly;
+    }
+
+    /**
+     * Is secure.
+     *
+     * @return the secure flag.
+     */
+    @Override
+    public boolean isSecure() {
+        return secure;
+    }
+
+    @Override
+    public void setComment(String comment) {
+        if (webApplication.isInitialized()) {
+            throw new IllegalStateException("You cannot call setComment once ServletContext is initialized");
+        }
+        this.comment = comment;
+    }
+
+    @Override
+    public void setDomain(String domain) {
+        if (webApplication.isInitialized()) {
+            throw new IllegalStateException("You cannot call setDomain once ServletContext is initialized");
+        }
+        this.domain = domain;
+    }
+
+    @Override
+    public void setHttpOnly(boolean httpOnly) {
+        if (webApplication.isInitialized()) {
+            throw new IllegalStateException("You cannot call setHttpOnly once ServletContext is initialized");
+        }
+        this.httpOnly = httpOnly;
+    }
+
+    @Override
+    public void setMaxAge(int maxAge) {
+        if (webApplication.isInitialized()) {
+            throw new IllegalStateException("You cannot call setMaxAge once ServletContext is initialized");
+        }
+        this.maxAge = maxAge;
+    }
+
+    @Override
+    public void setName(String name) {
+        if (webApplication.isInitialized()) {
+            throw new IllegalStateException("You cannot call setName once ServletContext is initialized");
+        }
+        this.name = name;
+    }
+
+    @Override
+    public void setPath(String path) {
+        if (webApplication.isInitialized()) {
+            throw new IllegalStateException("You cannot call setPath once ServletContext is initialized");
+        }
+        this.path = path;
+    }
+
+    @Override
+    public void setSecure(boolean secure) {
+        if (webApplication.isInitialized()) {
+            throw new IllegalStateException("You cannot call setSecure once ServletContext is initialized");
+        }
+        this.secure = secure;
+    }
+
+    /**
+     * Set the session timeout.
+     *
+     * @param sessionTimeout the session timeout.
+     */
+    @Override
+    public void setSessionTimeout(int sessionTimeout) {
+        this.sessionTimeout = sessionTimeout;
+    }
+
+    /**
+     * Set the session tracking modes.
+     *
+     * @param sessionTrackingModes the session tracking modes.
+     */
+    @Override
+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {
+        if (sessionTrackingModes.size() > 1 && sessionTrackingModes.contains(SessionTrackingMode.SSL)) {
+            throw new IllegalArgumentException("SSL cannot be combined with any other method");
+        }
+        this.sessionTrackingModes = Collections.unmodifiableSet(sessionTrackingModes);
+    }
+
+    /**
+     * Set the web application.
+     *
+     * @param webApplication the web application.
+     */
+    @Override
+    public void setWebApplication(WebApplication webApplication) {
+        this.webApplication = webApplication;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultInvocationFinder.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultInvocationFinder.java
new file mode 100644
index 00000000..7a2ae696
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultInvocationFinder.java
@@ -0,0 +1,336 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static java.util.Collections.reverse;
+import static java.util.stream.Collectors.toList;
+import static javax.servlet.DispatcherType.REQUEST;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.FilterChain;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
+
+import cloud.piranha.servlet4.webapp.FilterEnvironment;
+import cloud.piranha.servlet4.webapp.FilterPriority;
+import cloud.piranha.servlet4.webapp.ServletEnvironment;
+import cloud.piranha.servlet4.webapp.WebApplicationRequestMapping;
+
+/**
+ * The invocation finder tries to find a servlet invocation matching a request for a path based or name
+ * based dispatch.
+ *
+ * <p>
+ * Invocations returned by this finder take into account the various mappings, filters, welcome files
+ * and the default servlet.
+ *
+ *
+ * @author Arjan Tijms
+ *
+ */
+public class DefaultInvocationFinder {
+
+    /**
+     * Stores the web application.
+     */
+    private final DefaultWebApplication webApplication;
+
+    /**
+     * Constructor.
+     * 
+     * @param webApplication the web application.
+     */
+    public DefaultInvocationFinder(DefaultWebApplication webApplication) {
+        this.webApplication = webApplication;
+    }
+
+    /**
+     * Find the servlet invocation by path.
+     * 
+     * @param servletPath the servlet path.
+     * @param pathInfo the path info.
+     * @return the servlet invocation.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    public DefaultServletInvocation findServletInvocationByPath(String servletPath, String pathInfo) throws IOException, ServletException {
+        return findServletInvocationByPath(REQUEST, servletPath, pathInfo);
+    }
+
+    /**
+     * Find the servlet invocation by path.
+     * 
+     * @param dispatcherType the dispatcher type.
+     * @param servletPath the servlet path.
+     * @param pathInfo the path info.
+     * @return the servlet invocation.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    public DefaultServletInvocation findServletInvocationByPath(DispatcherType dispatcherType, String servletPath, String pathInfo) throws IOException, ServletException {
+        DefaultServletInvocation servletInvocation = getDirectServletInvocationByPath(servletPath, pathInfo);
+
+        if (servletInvocation == null) {
+            if (dispatcherType == REQUEST) {
+                servletInvocation = getWelcomeFileServletInvocation(servletPath, pathInfo != null ? pathInfo : "/");
+
+                if (servletInvocation == null) { // TODO: access rules for WEB-INF
+                    servletInvocation = getDefaultServletInvocation(servletPath, pathInfo);
+                }
+            } else {
+                // Note: no WEB-INF checks needed here
+                servletInvocation = getDefaultServletInvocation(servletPath, pathInfo);
+            }
+        }
+
+        // Seed the chain with the servlet, if any. REQUEST dispatches can be done to only a filter so a servlet is not hard requirement
+        servletInvocation.seedFilterChain();
+
+        return addFilters(dispatcherType, servletInvocation, servletPath, pathInfo);
+    }
+
+    /**
+     * Add the filters.
+     * 
+     * @param dispatcherType the dispatcher type.
+     * @param servletInvocation the servlet invocation.
+     * @param servletPath the servlet path.
+     * @param pathInfo the path info.
+     * @return the servlet invocation.
+     */
+    public DefaultServletInvocation addFilters(DispatcherType dispatcherType, DefaultServletInvocation servletInvocation, String servletPath, String pathInfo) {
+        if (dispatcherType == null) {
+            // If there's no dispatcher type, don't add filters. This can happen when the dispatch is not yet known
+            // so as with the request dispatcher, which first gets the resource, and only after that gets to be used for a forward or include.
+            return servletInvocation;
+        }
+
+        List<FilterEnvironment> filterEnvironments = findFilterEnvironments(dispatcherType, servletPath, pathInfo, servletInvocation == null? null : servletInvocation.getServletName());
+        if (filterEnvironments != null) {
+            if (servletInvocation == null) {
+                servletInvocation = new DefaultServletInvocation();
+                servletInvocation.setServletPath(servletPath);
+                servletInvocation.setPathInfo(pathInfo);
+            }
+
+            servletInvocation.setFilterEnvironments(filterEnvironments);
+            servletInvocation.setFilterChain(findFilterChain(filterEnvironments, servletInvocation.getFilterChain()));
+        }
+
+        return servletInvocation;
+    }
+
+    /**
+     * Find the servlet invocation by servlet name.
+     * 
+     * @param servletName the servlet name.
+     * @return the servlet invocation, or null if not found.
+     */
+    public DefaultServletInvocation findServletInvocationByName(String servletName) {
+        ServletEnvironment servletEnvironment = webApplication.servletEnvironments.get(servletName);
+        if (servletEnvironment == null) {
+            return null;
+        }
+
+        DefaultServletInvocation servletInvocation = new DefaultServletInvocation();
+
+        servletInvocation.setServletName(servletName);
+        servletInvocation.setServletEnvironment(servletEnvironment);
+        servletInvocation.seedFilterChain();
+
+        return servletInvocation;
+    }
+
+    private DefaultServletInvocation getDirectServletInvocationByPath(String servletPath, String pathInfo) {
+        String path = servletPath + (pathInfo == null ? "" : pathInfo);
+
+        WebApplicationRequestMapping mapping = webApplication.webApplicationRequestMapper.findServletMapping(path);
+        if (mapping == null) {
+            return null;
+        }
+
+        String servletName = webApplication.webApplicationRequestMapper.getServletName(mapping.getPath());
+        if (servletName == null) {
+            return null;
+        }
+
+        ServletEnvironment servletEnvironment = webApplication.servletEnvironments.get(servletName);
+        if (servletEnvironment == null) {
+            return null;
+        }
+
+        DefaultServletInvocation servletInvocation = new DefaultServletInvocation();
+
+        servletInvocation.setInvocationPath(path);
+        servletInvocation.setApplicationRequestMapping(mapping);
+        servletInvocation.setServletName(servletName);
+        servletInvocation.setServletEnvironment(servletEnvironment);
+
+        if (mapping.isExact()) {
+            servletInvocation.setServletPath(path);
+            servletInvocation.setPathInfo(null);
+        } else if (!mapping.isExtension()) {
+            servletInvocation.setServletPath(mapping.getPath().substring(0, mapping.getPath().length() - 2));
+            servletInvocation.setPathInfo(path.substring(mapping.getPath().length() - 2));
+        } else {
+            servletInvocation.setServletPath(servletPath);
+            servletInvocation.setPathInfo(pathInfo);
+        }
+
+        return servletInvocation;
+    }
+
+    private DefaultServletInvocation getWelcomeFileServletInvocation(String servletPath, String pathInfo) throws IOException {
+
+        // Try if we have a welcome file that we can load via the default servlet
+
+        if (webApplication.defaultServlet != null) {
+            for (String welcomeFile : webApplication.getWelcomeFileManager().getWelcomeFileList()) {
+                if (!isStaticResource(servletPath, pathInfo + welcomeFile))
+                    continue;
+                DefaultServletInvocation servletInvocation = getDefaultServletInvocation(servletPath, pathInfo + welcomeFile);
+                return Objects.requireNonNullElseGet(servletInvocation, () -> getDefaultServletInvocation(servletPath, pathInfo + welcomeFile));
+            }
+        }
+
+        // Next try if we have a welcome servlet
+
+        for (String welcomeFile : webApplication.getWelcomeFileManager().getWelcomeFileList()) {
+            if (!isStaticResource(servletPath, pathInfo + welcomeFile))
+                continue;
+            DefaultServletInvocation servletInvocation = getDirectServletInvocationByPath(servletPath, pathInfo + welcomeFile);
+            return Objects.requireNonNullElseGet(servletInvocation, () -> getDefaultServletInvocation(servletPath, pathInfo + welcomeFile));
+        }
+
+        // No welcome file or servlet
+        return null;
+    }
+
+    private boolean isStaticResource(String servletPath, String pathInfo) throws MalformedURLException {
+        return webApplication.getResource(addSlashIfNeeded(servletPath + (pathInfo == null? "" : pathInfo))) != null;
+    }
+
+    private String addSlashIfNeeded(String string) {
+        if (string.startsWith("/")) {
+            return string;
+        }
+
+        return "/" + string;
+    }
+
+    private DefaultServletInvocation getDefaultServletInvocation(String servletPath, String pathInfo) {
+        Servlet defaultServlet = webApplication.defaultServlet;
+        if (defaultServlet == null) {
+            defaultServlet = new DefaultServlet();
+        }
+
+        DefaultServletInvocation servletInvocation = new DefaultServletInvocation();
+
+        servletInvocation.setServletName("default");
+        servletInvocation.setServletEnvironment(new DefaultServletEnvironment(webApplication, "default", defaultServlet));
+        servletInvocation.setServletPath(servletPath);
+        servletInvocation.setPathInfo(pathInfo);
+        servletInvocation.setInvocationPath(servletPath); // look at whether its really needed to have path and invocation path
+
+        return servletInvocation;
+    }
+
+    /**
+     * Find the filter environments.
+     *
+     * @param dispatcherType the dispatcher type.
+     * @param servletPath the servlet path to which filters should apply.
+     * @param pathInfo the path info to which filters should apply.
+     * @param servletName name of the servlet to be filtered, if any. Can be null.
+     *
+     * @return the filter environments.
+     */
+    protected List<FilterEnvironment> findFilterEnvironments(DispatcherType dispatcherType, String servletPath, String pathInfo, String servletName) {
+        List<FilterEnvironment> filterEnvironments = null;
+
+        String path = servletPath + (pathInfo == null ? "" : pathInfo);
+        Collection<String> filterNames = webApplication.webApplicationRequestMapper.findFilterMappings(dispatcherType, path);
+
+        if (servletName != null) {
+            String servletNamePath = "servlet:// " + servletName;
+            filterNames.addAll(webApplication.webApplicationRequestMapper.findFilterMappings(dispatcherType, servletNamePath));
+        }
+
+        if (!filterNames.isEmpty()) {
+            filterEnvironments = new ArrayList<>();
+            for (String filterName : filterNames) {
+                if (webApplication.filters.get(filterName) != null) {
+                    filterEnvironments.add(webApplication.filters.get(filterName));
+                }
+            }
+        }
+
+        return filterEnvironments;
+    }
+
+    private FilterChain findFilterChain(List<FilterEnvironment> filterEnvironments, FilterChain initialFilterChain) {
+        List<FilterEnvironment> prioritisedFilters = filterEnvironments.stream()
+                .filter(e -> e.getFilter() instanceof FilterPriority)
+                .sorted(this::sortOnPriority)
+                .collect(toList());
+
+        List<FilterEnvironment> notPrioritisedFilters = filterEnvironments.stream()
+                .filter(e -> e.getFilter() instanceof FilterPriority == false)
+                .collect(toList());
+
+        List<FilterEnvironment> currentEnvironments = new ArrayList<>();
+        currentEnvironments.addAll(prioritisedFilters);
+        currentEnvironments.addAll(notPrioritisedFilters);
+
+        reverse(currentEnvironments);
+
+        FilterChain downFilterChain = initialFilterChain;
+        FilterChain upFilterChain;
+        for (FilterEnvironment filterEnvironment : currentEnvironments) {
+            upFilterChain = new DefaultFilterChain(filterEnvironment.getFilter(), downFilterChain);
+            downFilterChain = upFilterChain;
+        }
+
+        return downFilterChain;
+    }
+
+    private int sortOnPriority(FilterEnvironment x, FilterEnvironment y) {
+        FilterPriority filterX = (FilterPriority) x.getFilter();
+        FilterPriority filterY = (FilterPriority) y.getFilter();
+
+        return Integer.compare(filterX.getPriority(), filterY.getPriority());
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultJspFileManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultJspFileManager.java
new file mode 100644
index 00000000..20e04d89
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultJspFileManager.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import javax.servlet.ServletRegistration;
+import javax.servlet.descriptor.JspConfigDescriptor;
+
+import cloud.piranha.servlet4.webapp.JspManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The default JspFileManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultJspFileManager implements JspManager {
+
+    /**
+     * Stores the JSP config descriptor.
+     */
+    protected JspConfigDescriptor jspConfigDescriptor;
+
+    /**
+     * Add the JSP file.
+     *
+     * @param webApplication the web application.
+     * @param servletName the servlet name,
+     * @param jspFile the JSP file.
+     * @return null.
+     */
+    @Override
+    public ServletRegistration.Dynamic addJspFile(WebApplication webApplication, String servletName, String jspFile) {
+        return null;
+    }
+
+    /**
+     * Get the JSP config descriptor.
+     *
+     * @return the JSP config descriptor.
+     */
+    @Override
+    public JspConfigDescriptor getJspConfigDescriptor() {
+        return jspConfigDescriptor;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultLocaleEncodingManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultLocaleEncodingManager.java
new file mode 100644
index 00000000..81e9e3bb
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultLocaleEncodingManager.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.webapp.LocaleEncodingManager;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * The default LocaleEncodingManager.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultLocaleEncodingManager implements LocaleEncodingManager {
+
+    /**
+     * Stores the locale mappings.
+     */
+    private final Map<String, String> localeMappings;
+
+    /**
+     * Constructor.
+     */
+    public DefaultLocaleEncodingManager() {
+        localeMappings = new HashMap<>();
+    }
+
+    @Override
+    public void addCharacterEncoding(String locale, String encoding) {
+        localeMappings.put(locale, encoding);
+    }
+
+    @Override
+    public String getCharacterEncoding(String locale) {
+        return localeMappings.get(locale);
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultLoggingManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultLoggingManager.java
new file mode 100644
index 00000000..6c3985c2
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultLoggingManager.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.webapp.LoggingManager;
+
+/**
+ * The default LoggingManager.
+ *
+ * <p>
+ * The default LoggingManager swallows everything. If you want to do some actual
+ * logging you need to deliver your custom LoggingManager.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultLoggingManager implements LoggingManager {
+
+    /**
+     * Constructor.
+     */
+    public DefaultLoggingManager() {
+    }
+
+    /**
+     * Log the message.
+     *
+     * @param message the message to log.
+     * @param throwable the throwable to log.
+     */
+    @Override
+    public void log(String message, Throwable throwable) {
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultMimeTypeManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultMimeTypeManager.java
new file mode 100644
index 00000000..82fa021b
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultMimeTypeManager.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import cloud.piranha.servlet4.webapp.MimeTypeManager;
+
+/**
+ * The default MimeTypeManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultMimeTypeManager implements MimeTypeManager {
+
+    /**
+     * Stores the mime types.
+     */
+    private final Map<String, String> mimeTypes = new HashMap<>();
+
+    /**
+     * Constructor.
+     */
+    public DefaultMimeTypeManager() {
+        mimeTypes.put("css", "text/css");
+        mimeTypes.put("js", "text/javascript");
+        mimeTypes.put("ico", "image/x-icon");
+        mimeTypes.put("svg", "image/svg+xml");
+        mimeTypes.put("png", "image/png");
+        mimeTypes.put("ttf", "font/ttf");
+        mimeTypes.put("html", "text/html");
+        mimeTypes.put("htm", "text/html");
+        mimeTypes.put("text", "text/plain");
+        mimeTypes.put("txt", "text/plain");
+    }
+
+    /**
+     * Add the mime type.
+     *
+     * @param extension the extension (without the dot).
+     * @param mimeType the mime type to return.
+     */
+    @Override
+    public void addMimeType(String extension, String mimeType) {
+        mimeTypes.put(extension.toLowerCase(), mimeType);
+    }
+
+    /**
+     * Get the mime type.
+     *
+     * @param filename the filename.
+     * @return the mime type, or null if not found.
+     */
+    @Override
+    public String getMimeType(String filename) {
+        if (!filename.contains(".")) {
+            return null;
+        }
+        return mimeTypes.get(filename.substring(filename.lastIndexOf(".") + 1).toLowerCase());
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultMultiPartManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultMultiPartManager.java
new file mode 100644
index 00000000..67f0e0fe
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultMultiPartManager.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Part;
+
+import cloud.piranha.servlet4.webapp.MultiPartManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationRequest;
+
+/**
+ * The default MultiPartManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultMultiPartManager implements MultiPartManager {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(DefaultMultiPartManager.class.getName());
+
+    /**
+     * Get the parts.
+     *
+     * @param webApplication the web application.
+     * @param request the request.
+     * @return the parts.
+     * @throws ServletException when the request is not a multipart/form-data
+     * request.
+     */
+    @Override
+    public Collection<Part> getParts(WebApplication webApplication,
+            WebApplicationRequest request) throws ServletException {
+        LOGGER.log(Level.FINE, "Getting parts for request: {0}", request);
+        return Collections.emptyList();
+    }
+
+    /**
+     * Get the part.
+     *
+     * @param webApplication the web application.
+     * @param request the request.
+     * @param name the name of the part.
+     * @return the part, or null if not found.
+     * @throws ServletException when the request is not a multipart/form-data
+     * request.
+     */
+    @Override
+    public Part getPart(WebApplication webApplication,
+            WebApplicationRequest request, String name) throws ServletException {
+        LOGGER.log(Level.FINE, "Getting part: {0} for request: {1}", new Object[]{name, request});
+        return null;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultObjectInstanceManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultObjectInstanceManager.java
new file mode 100644
index 00000000..3d47b15f
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultObjectInstanceManager.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.EventListener;
+
+import javax.servlet.Filter;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
+
+import cloud.piranha.servlet4.webapp.ObjectInstanceManager;
+
+/**
+ * The default object instance manager.
+ *
+ * <p>
+ * This object instance manager does not do any injection and that is by design.
+ * If you need injection into Servlets use the appropriate object instance
+ * manager for your injection framework.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultObjectInstanceManager implements ObjectInstanceManager {
+
+    /**
+     * Create the filter.
+     *
+     * @param <T> the return type.
+     * @param filterClass the filter class.
+     * @return the filter.
+     * @throws ServletException when it fails to create the filter.
+     */
+    @Override
+    public <T extends Filter> T createFilter(Class<T> filterClass) throws ServletException {
+        T result = null;
+        try {
+            result = filterClass.getDeclaredConstructor().newInstance();
+        } catch (Throwable throwable) {
+            throw new ServletException(throwable);
+        }
+        return result;
+    }
+
+    /**
+     * Create the listener.
+     *
+     * @param <T> the type.
+     * @param clazz the class of the listener to create.
+     * @return the listener.
+     * @throws ServletException when it fails to create the listener.
+     */
+    @Override
+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {
+        T result;
+        try {
+            result = clazz.getDeclaredConstructor().newInstance();
+        } catch (Throwable throwable) {
+            throw new ServletException(throwable);
+        }
+        return result;
+    }
+
+    /**
+     * Create the servlet.
+     *
+     * @param <T> the return type.
+     * @param servletClass the servlet class.
+     * @return the servlet.
+     * @throws ServletException when it fails to create the servlet.
+     */
+    @Override
+    public <T extends Servlet> T createServlet(Class<T> servletClass) throws ServletException {
+        T result;
+        try {
+            result = servletClass.getDeclaredConstructor().newInstance();
+        } catch (Throwable throwable) {
+            throw new ServletException(throwable);
+        }
+        return result;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultSecurityManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultSecurityManager.java
new file mode 100644
index 00000000..57a1288a
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultSecurityManager.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
+import javax.servlet.http.HttpServletResponse;
+
+import cloud.piranha.servlet4.webapp.SecurityManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The default SecurityManager.
+ *
+ * <p>
+ * This security manager implies the use of DefaultWebApplicationRequest, if
+ * your server / web application does not want to use
+ * DefaultWebApplicationRequest or subclass DefaultWebApplicationRequest you
+ * have to implement your own security manager.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultSecurityManager implements SecurityManager {
+
+    /**
+     * Stores if we are denying uncovered HTTP methods.
+     */
+    protected boolean denyUncoveredHttpMethods = false;
+
+    /**
+     * Stores the logins.
+     */
+    protected final HashMap<String, String> logins = new HashMap<>();
+
+    /**
+     * Stores the roles.
+     */
+    protected ArrayList<String> roles = new ArrayList<>();
+
+    /**
+     * Stores the user roles.
+     */
+    protected final HashMap<String, String[]> userRoles = new HashMap<>();
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Add user.
+     *
+     * @param username the username.
+     * @param password the password.
+     * @param roles the roles.
+     */
+    public void addUser(String username, String password, String... roles) {
+        logins.put(username, password);
+        if (roles != null) {
+            userRoles.put(username, roles);
+        }
+    }
+
+    /**
+     * Add the user roles.
+     * 
+     * @param username the username.
+     * @param roles the roles.
+     */
+    public void addUserRole(String username, String... roles) {
+        if (roles != null) {
+            userRoles.put(username, roles);
+        }
+    }
+
+    /**
+     * Authenticate the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @return true if authenticated, false otherwise.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public boolean authenticate(
+            HttpServletRequest request, HttpServletResponse response)
+            throws IOException, ServletException {
+
+        boolean result = false;
+
+        if (request.getAuthType() != null) {
+            if (request.getAuthType().equals(HttpServletRequest.BASIC_AUTH)) {
+                throw new ServletException("Basic auth is not supported");
+            }
+
+            if (request.getAuthType().equals(HttpServletRequest.CLIENT_CERT_AUTH)) {
+                throw new ServletException("Client cert auth is not supported");
+            }
+
+            if (request.getAuthType().equals(HttpServletRequest.DIGEST_AUTH)) {
+                throw new ServletException("Digest auth is not supported");
+            }
+
+            if (request.getAuthType().equals(HttpServletRequest.FORM_AUTH)) {
+                String username = request.getParameter("j_username");
+                String password = request.getParameter("j_password");
+                login(request, username, password);
+                if (request.getUserPrincipal() != null) {
+                    result = true;
+                }
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Declare roles.
+     *
+     * @param roles the roles.
+     */
+    @Override
+    public void declareRoles(String[] roles) {
+        this.roles.addAll(Arrays.asList(roles));
+    }
+
+    @Override
+    public Set<String> getRoles() {
+        return new HashSet<>(roles);
+    }
+
+    /**
+     * Get if we are denying uncovered HTTP methods.
+     *
+     * @return true if we are, false otherwise.
+     */
+    @Override
+    public boolean getDenyUncoveredHttpMethods() {
+        return denyUncoveredHttpMethods;
+    }
+
+    /**
+     * Get the web application.
+     *
+     * @return the web application.
+     */
+    @Override
+    public WebApplication getWebApplication() {
+        return webApplication;
+    }
+
+    /**
+     * Is the user in the given role.
+     *
+     * @param request the request.
+     * @param role the role.
+     * @return true if in the role, false otherwise.
+     */
+    @Override
+    public boolean isUserInRole(HttpServletRequest request, String role) {
+        boolean result = false;
+
+        if (request.getRemoteUser() != null) {
+            String foundRoles[] = userRoles.get(request.getRemoteUser());
+            if (foundRoles != null) {
+                for (String foundRole : foundRoles) {
+                    if (foundRole.equals(role)) {
+                        result = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Login with the given username and password.
+     *
+     * @param request the servlet request.
+     * @param username the username.
+     * @param password the password.
+     * @throws ServletException when a serious error occurs.
+     */
+    @Override
+    public void login(HttpServletRequest request, String username, String password) throws ServletException {
+
+        if (logins.containsKey(username) && password != null && password.equals(logins.get(username))) {
+            DefaultWebApplicationRequest abstractRequest;
+
+            while (request instanceof HttpServletRequestWrapper) {
+                HttpServletRequestWrapper wrapper = (HttpServletRequestWrapper) request;
+                request = (HttpServletRequest) wrapper.getRequest();
+            }
+            abstractRequest = (DefaultWebApplicationRequest) request;
+            abstractRequest.setUserPrincipal(new DefaultSecurityPrincipal(username));
+        } else {
+            throw new ServletException("Unable to login using the given username and password");
+        }
+    }
+
+    /**
+     * Logout.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws ServletException when a serious error occurs.
+     */
+    @Override
+    public void logout(HttpServletRequest request, HttpServletResponse response) throws ServletException {
+    }
+
+    /**
+     * Remove the given user.
+     *
+     * @param username the username.
+     */
+    public void removeUser(String username) {
+        logins.remove(username);
+        userRoles.remove(username);
+    }
+
+    /**
+     * Set if we are denying uncovered HTTP methods.
+     *
+     * @param denyUncoveredHttpMethods the boolean value.
+     */
+    @Override
+    public void setDenyUncoveredHttpMethods(boolean denyUncoveredHttpMethods) {
+        this.denyUncoveredHttpMethods = denyUncoveredHttpMethods;
+    }
+
+    /**
+     * Set the web application.
+     *
+     * @param webApplication the web application.
+     */
+    @Override
+    public void setWebApplication(WebApplication webApplication) {
+        this.webApplication = webApplication;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultSecurityPrincipal.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultSecurityPrincipal.java
new file mode 100644
index 00000000..c66c3c4f
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultSecurityPrincipal.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.security.Principal;
+
+/**
+ * The default SecurityPrincipal.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultSecurityPrincipal implements Principal {
+
+    /**
+     * Stores the name.
+     */
+    private final String name;
+
+    /**
+     * Constructor.
+     *
+     * @param name the name.
+     */
+    public DefaultSecurityPrincipal(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    @Override
+    public String getName() {
+        return name;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServlet.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServlet.java
new file mode 100644
index 00000000..68506974
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServlet.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.PrintWriter;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * The default Servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultServlet extends HttpServlet {
+
+    private static final long serialVersionUID = 1331822806510796938L;
+
+    /**
+     * Get the requested resource.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        InputStream resource = getResource(request);
+
+        if (resource == null) {
+            response.sendError(SC_NOT_FOUND);
+            return;
+        }
+
+        setContentType(request, response);
+
+        try (InputStream inputStream = new BufferedInputStream(resource)) {
+            try (OutputStream outputStream = new BufferedOutputStream(response.getOutputStream())) {
+                inputStream.transferTo(outputStream);
+                outputStream.flush();
+            } catch (IllegalStateException ise) {
+                try (PrintWriter writer = response.getWriter()) {
+                    writer.print(new String(inputStream.readAllBytes()));
+                    writer.flush();
+                }
+            }
+        }
+    }
+
+    private InputStream getResource(HttpServletRequest request) {
+        if (request.getServletContext() == null) {
+            return null;
+        }
+
+        return request.getServletContext().getResourceAsStream(getPath(request));
+    }
+
+    private String getPath(HttpServletRequest request) {
+        String requestURI;
+        String contextPath;
+
+        if (request.getDispatcherType() == DispatcherType.INCLUDE) {
+            requestURI = (String) request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI);
+            contextPath = (String) request.getAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH);
+        } else {
+            requestURI = request.getRequestURI();
+            contextPath = request.getContextPath();
+        }
+
+        return requestURI.substring(contextPath.length());
+    }
+
+    private void setContentType(HttpServletRequest request, HttpServletResponse response) {
+        String uri = request.getRequestURI();
+
+        String filename = uri.contains("/") ? uri.substring(uri.lastIndexOf("/") + 1) : uri.isEmpty()? "" : uri.substring(1);
+        String mimeType = request.getServletContext().getMimeType(filename);
+
+        if (mimeType != null) {
+            response.setContentType(mimeType);
+        } else {
+            response.setContentType("application/octet-stream");
+        }
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletEnvironment.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletEnvironment.java
new file mode 100644
index 00000000..3c70b1f4
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletEnvironment.java
@@ -0,0 +1,312 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.servlet.MultipartConfigElement;
+import javax.servlet.Servlet;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletSecurityElement;
+
+import cloud.piranha.servlet4.webapp.ServletEnvironment;
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The default ServletEnvironment.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultServletEnvironment implements ServletEnvironment {
+
+    /**
+     * Stores the async supported flag.
+     */
+    protected boolean asyncSupported;
+
+    /**
+     * Stores the class name.
+     */
+    protected String className;
+
+    /**
+     * Stores the init parameters.
+     */
+    protected final Map<String, String> initParameters;
+
+    /**
+     * Stores the load on startup value.
+     */
+    protected int loadOnStartup;
+
+    /**
+     * Stores the multi-part config.
+     */
+    protected MultipartConfigElement multipartConfig;
+
+    /**
+     * Stores the run-as-role.
+     */
+    protected String runAsRole;
+
+    /**
+     * Stores the servlet.
+     */
+    protected Servlet servlet;
+
+    /**
+     * Stores the servlet class.
+     */
+    protected Class<? extends Servlet> servletClass;
+
+    /**
+     * Stores the servlet name.
+     */
+    protected final String servletName;
+
+    /**
+     * Stores the status.
+     */
+    protected int status;
+
+    /**
+     * Stores the unavailableException.
+     */
+    protected Throwable unavailableException;
+
+    /**
+     * Stores the web application.
+     */
+    protected final WebApplication webApp;
+
+    /**
+     * Constructor.
+     *
+     * @param webApp the web application.
+     * @param servletName the servlet name.
+     */
+    public DefaultServletEnvironment(DefaultWebApplication webApp, String servletName) {
+        this.asyncSupported = false;
+        this.initParameters = new ConcurrentHashMap<>(1);
+        this.loadOnStartup = -1;
+        this.servletName = servletName;
+        this.webApp = webApp;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param webApp the web application.
+     * @param servletName the servlet name.
+     * @param servlet the servlet.
+     */
+    public DefaultServletEnvironment(DefaultWebApplication webApp, String servletName, Servlet servlet) {
+        this(webApp, servletName);
+        this.className = servlet.getClass().getName();
+        this.servlet = servlet;
+    }
+
+    @Override
+    public Set<String> addMapping(String... urlPatterns) {
+        return webApp.addServletMapping(servletName, urlPatterns);
+    }
+
+    @Override
+    public String getClassName() {
+        return className;
+    }
+
+    @Override
+    public String getInitParameter(String name) {
+        return initParameters.get(name);
+    }
+
+    @Override
+    public Enumeration<String> getInitParameterNames() {
+        return Collections.enumeration(initParameters.keySet());
+    }
+
+    @Override
+    public Map<String, String> getInitParameters() {
+        return initParameters;
+    }
+
+    @Override
+    public int getLoadOnStartup() {
+        return loadOnStartup;
+    }
+
+    @Override
+    public Collection<String> getMappings() {
+        Collection<String> result = new ArrayList<>();
+        Collection<String> mappings = webApp.getMappings(servletName);
+        if (mappings != null) {
+            result.addAll(mappings);
+        }
+        return result;
+    }
+
+    @Override
+    public MultipartConfigElement getMultipartConfig() {
+        return multipartConfig;
+    }
+
+    @Override
+    public String getName() {
+        return servletName;
+    }
+
+    @Override
+    public String getRunAsRole() {
+        return runAsRole;
+    }
+
+    @Override
+    public Servlet getServlet() {
+        return servlet;
+    }
+
+    @Override
+    public ServletContext getServletContext() {
+        return webApp;
+    }
+
+    @Override
+    public Class<? extends Servlet> getServletClass() {
+        return servletClass;
+    }
+
+    @Override
+    public String getServletName() {
+        return servletName;
+    }
+
+    @Override
+    public int getStatus() {
+        return status;
+    }
+
+    @Override
+    public WebApplication getWebApplication() {
+        return this.webApp;
+    }
+
+    @Override
+    public boolean isAsyncSupported() {
+        return asyncSupported;
+    }
+
+    @Override
+    public void setAsyncSupported(boolean asyncSupported) {
+        this.asyncSupported = asyncSupported;
+    }
+
+    @Override
+    public void setClassName(String className) {
+        this.className = className;
+    }
+
+    @Override
+    public boolean setInitParameter(String name, String value) {
+        boolean result = false;
+        if (!initParameters.containsKey(name)) {
+            initParameters.put(name, value);
+            result = true;
+        }
+        return result;
+    }
+
+    @Override
+    public Set<String> setInitParameters(Map<String, String> initParameters) {
+        HashSet<String> conflicting = new HashSet<>();
+        if (initParameters != null) {
+            initParameters.entrySet().forEach(entry -> {
+                String name = entry.getKey();
+                String value = entry.getValue();
+                if (name == null) {
+                    throw new IllegalArgumentException("A null name is not allowed");
+                }
+                if (value == null) {
+                    throw new IllegalArgumentException("A null value is not allowed");
+                }
+                if (!setInitParameter(name, value)) {
+                    conflicting.add(name);
+                }
+            });
+        }
+        return conflicting;
+    }
+
+    @Override
+    public void setLoadOnStartup(int loadOnStartup) {
+        this.loadOnStartup = loadOnStartup;
+    }
+
+    @Override
+    public void setMultipartConfig(MultipartConfigElement multipartConfig) {
+        this.multipartConfig = multipartConfig;
+    }
+
+    @Override
+    public void setRunAsRole(String runAsRole) {
+        this.runAsRole = runAsRole;
+    }
+
+    @Override
+    public void setServlet(Servlet servlet) {
+        this.servlet = servlet;
+    }
+
+    @Override
+    public Set<String> setServletSecurity(ServletSecurityElement servletSecurityElement) {
+        return new HashSet<>();
+    }
+
+    @Override
+    public void setStatus(int status) {
+        this.status = status;
+    }
+
+    @Override
+    public Throwable getUnavailableException() {
+        return unavailableException;
+    }
+
+    @Override
+    public void setUnavailableException(Throwable unavailableException) {
+        this.unavailableException = unavailableException;
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletInvocation.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletInvocation.java
new file mode 100644
index 00000000..c8e9bf3a
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletInvocation.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.List;
+
+import javax.servlet.FilterChain;
+
+import cloud.piranha.servlet4.webapp.FilterEnvironment;
+import cloud.piranha.servlet4.webapp.ServletEnvironment;
+import cloud.piranha.servlet4.webapp.ServletInvocation;
+import cloud.piranha.servlet4.webapp.WebApplicationRequestMapping;
+
+/**
+ * The default servlet invocation
+ *
+ * @author Arjan Tijms
+ *
+ */
+public class DefaultServletInvocation implements ServletInvocation {
+
+    /**
+     * Stores the invocation path.
+     */
+    private String invocationPath;
+    
+    /**
+     * Stores the servlet name.
+     */
+    private String servletName;
+    
+    /**
+     * Stores the servlet path.
+     */
+    private String servletPath;
+    
+    /**
+     * Stores the path info.
+     */
+    private String pathInfo;
+    
+    /**
+     * Stores the web application request mapping.
+     */
+    private WebApplicationRequestMapping applicationRequestMapping;
+    
+    /**
+     * Stores the servlet environment.
+     */
+    private ServletEnvironment servletEnvironment;
+    
+    /**
+     * Stores the filter environment.
+     */
+    private List<FilterEnvironment> filterEnvironments;
+    
+    /**
+     * Stores the filter chain.
+     */
+    private FilterChain filterChain;
+
+    @Override
+    public String getInvocationPath() {
+        return invocationPath;
+    }
+
+    /**
+     * Set the invocation path.
+     * 
+     * @param invocationPath the invocation path.
+     */
+    public void setInvocationPath(String invocationPath) {
+        this.invocationPath = invocationPath;
+    }
+
+    @Override
+    public String getServletName() {
+        return servletName;
+    }
+
+    /**
+     * Set the servlet name.
+     * 
+     * @param servletName the servlet name.
+     */
+    public void setServletName(String servletName) {
+        this.servletName = servletName;
+    }
+
+    @Override
+    public String getServletPath() {
+        return servletPath;
+    }
+
+    /**
+     * Set the servlet path.
+     * 
+     * @param servletPath the servlet path.
+     */
+    public void setServletPath(String servletPath) {
+        this.servletPath = servletPath;
+    }
+
+    @Override
+    public String getPathInfo() {
+        return pathInfo;
+    }
+
+    /**
+     * Set the path info.
+     * 
+     * @param pathInfo the path info.
+     */
+    public void setPathInfo(String pathInfo) {
+        this.pathInfo = pathInfo;
+    }
+
+    @Override
+    public WebApplicationRequestMapping getApplicationRequestMapping() {
+        return applicationRequestMapping;
+    }
+
+    /**
+     * Set the web application request mapping.
+     * 
+     * @param applicationRequestMapping the web application request mapping.
+     */
+    public void setApplicationRequestMapping(WebApplicationRequestMapping applicationRequestMapping) {
+        this.applicationRequestMapping = applicationRequestMapping;
+    }
+
+    @Override
+    public ServletEnvironment getServletEnvironment() {
+        return servletEnvironment;
+    }
+
+    /**
+     * Set the servlet environment.
+     * 
+     * @param servletEnvironment the servlet environment.
+     */
+    public void setServletEnvironment(ServletEnvironment servletEnvironment) {
+        this.servletEnvironment = servletEnvironment;
+    }
+
+    @Override
+    public List<FilterEnvironment> getFilterEnvironments() {
+        return filterEnvironments;
+    }
+
+    /**
+     * Set the filter environments.
+     * 
+     * @param filterEnvironments the filter environments.
+     */
+    public void setFilterEnvironments(List<FilterEnvironment> filterEnvironments) {
+        this.filterEnvironments = filterEnvironments;
+    }
+
+    @Override
+    public FilterChain getFilterChain() {
+        return filterChain;
+    }
+
+    /**
+     * Set the filter chain.
+     * 
+     * @param filterChain the filter chain.
+     */
+    public void setFilterChain(FilterChain filterChain) {
+        this.filterChain = filterChain;
+    }
+
+    /**
+     * Seed the filter chain.
+     */
+    public void seedFilterChain() {
+        setFilterChain(
+            new DefaultFilterChain(
+                this,
+                getServletEnvironment() == null ? null : getServletEnvironment().getServlet()));
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletRequestDispatcher.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletRequestDispatcher.java
new file mode 100644
index 00000000..c6541291
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultServletRequestDispatcher.java
@@ -0,0 +1,720 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static cloud.piranha.servlet4.webapp.CurrentRequestHolder.CURRENT_REQUEST_ATTRIBUTE;
+import static cloud.piranha.servlet4.impl.DefaultWebApplicationRequest.unwrap;
+import static java.util.Arrays.asList;
+import static javax.servlet.AsyncContext.ASYNC_CONTEXT_PATH;
+import static javax.servlet.AsyncContext.ASYNC_PATH_INFO;
+import static javax.servlet.AsyncContext.ASYNC_QUERY_STRING;
+import static javax.servlet.AsyncContext.ASYNC_REQUEST_URI;
+import static javax.servlet.AsyncContext.ASYNC_SERVLET_PATH;
+import static javax.servlet.DispatcherType.ASYNC;
+import static javax.servlet.DispatcherType.ERROR;
+import static javax.servlet.DispatcherType.FORWARD;
+import static javax.servlet.DispatcherType.INCLUDE;
+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestWrapper;
+import javax.servlet.ServletResponse;
+import javax.servlet.UnavailableException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
+import javax.servlet.http.HttpServletResponse;
+
+import cloud.piranha.servlet4.webapp.CurrentRequestHolder;
+import cloud.piranha.servlet4.webapp.FilterEnvironment;
+import cloud.piranha.servlet4.webapp.ServletEnvironment;
+import cloud.piranha.servlet4.webapp.WebApplicationRequest;
+
+/**
+ * The default ServletRequestDispatcher.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultServletRequestDispatcher implements RequestDispatcher {
+
+    /**
+     * Stores the previous request attribute name
+     */
+    static final String PREVIOUS_REQUEST = "piranha.previous.request";
+
+    /**
+     * Stores the async attributes.
+     */
+    private static final List<String> ASYNC_ATTRIBUTES = asList(ASYNC_CONTEXT_PATH, ASYNC_PATH_INFO, ASYNC_QUERY_STRING, ASYNC_REQUEST_URI, ASYNC_SERVLET_PATH);
+
+    /**
+     * Stores the servlet invocation.
+     */
+    private final DefaultServletInvocation servletInvocation;
+
+    /**
+     * The servletEnvironment corresponding to the target resource to which this
+     * dispatcher forwards or includes.
+     *
+     * <p>
+     * It contains the actual Servlet, to process the forwarded or included
+     * request, as well as meta data for this Servlet.
+     */
+    private final ServletEnvironment servletEnvironment;
+
+    /**
+     * Stores the path.
+     */
+    private final String path;
+
+    /**
+     * Stores the error page manager.
+     */
+    private final DefaultErrorPageManager errorPageManager;
+
+    /**
+     * Stores the invocation finder.
+     */
+    private final DefaultInvocationFinder invocationFinder;
+
+    /**
+     * Stores the web application.
+     */
+    private final DefaultWebApplication webApplication;
+
+    /**
+     * Constructor.
+     *
+     * @param servletInvocation The servlet invocation containing all info this dispatcher uses to dispatch to the contained Servlet.
+     * @param webApplication the web application.
+     */
+    public DefaultServletRequestDispatcher(DefaultServletInvocation servletInvocation, DefaultWebApplication webApplication) {
+        this.servletInvocation = servletInvocation;
+
+        this.webApplication = webApplication;
+        this.errorPageManager = webApplication.errorPageManager;
+        this.invocationFinder = webApplication.invocationFinder;
+
+        this.servletEnvironment = servletInvocation == null? null : servletInvocation.getServletEnvironment();
+        this.path = servletInvocation == null? null : servletInvocation.getInvocationPath();
+    }
+
+    /**
+     * Dispatches using the REQUEST dispatch type
+     *
+     * @param webappRequest the request.
+     * @param httpResponse the response.
+     * @throws ServletException when a servlet error occurs.
+     * @throws IOException when an I/O error occurs.
+     */
+    public void request(DefaultWebApplicationRequest webappRequest, DefaultWebApplicationResponse httpResponse) throws ServletException, IOException {
+        Throwable exception = null;
+
+        if (servletInvocation == null || !servletInvocation.canInvoke() && !servletInvocation.isServletUnavailable()) {
+            // If there's nothing to invoke at all, there was nothing found, so return a 404
+            httpResponse.sendError(404);
+        } else {
+
+            // There's either a Servlet, Filter or both found matching the request.
+
+            try {
+                if (servletInvocation.getServletEnvironment() != null) {
+                    webappRequest.setAsyncSupported(isAsyncSupportedInChain());
+                }
+                webappRequest.setServletPath(servletInvocation.getServletPath());
+                webappRequest.setPathInfo(servletInvocation.getPathInfo());
+
+                servletInvocation.getFilterChain().doFilter(webappRequest, httpResponse);
+            } catch (Throwable e) {
+                if (webappRequest.getAttribute("piranha.request.exception") != null) {
+                    exception = (Exception) webappRequest.getAttribute("piranha.request.exception");
+                } else {
+                    exception = e;
+                }
+            }
+        }
+
+        if (exception != null) {
+            httpResponse.setStatus(exception instanceof UnavailableException ? SC_NOT_FOUND : SC_INTERNAL_SERVER_ERROR);
+        }
+
+        String errorPagePath = errorPageManager.getErrorPage(exception, httpResponse);
+
+        if (errorPagePath != null) {
+            try {
+                webApplication.getRequestDispatcher(errorPagePath).error(servletInvocation == null? null : servletInvocation.getServletName(), webappRequest, httpResponse, exception);
+            } catch (Exception e) {
+                rethrow(e);
+            }
+        } else if (exception != null) {
+            exception.printStackTrace(httpResponse.getWriter());
+            httpResponse.flushBuffer();
+            rethrow(exception);
+        }
+
+        if (!webappRequest.isAsyncStarted()) {
+            httpResponse.flushBuffer();
+        }
+    }
+
+    /**
+     * Dispatches using the FORWARD or ASYNC dispatch type - Forward the request and response.
+     *
+     * @param servletRequest the request.
+     * @param servletResponse the response.
+     * @throws ServletException when a servlet error occurs.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public void forward(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
+        if (servletRequest.getDispatcherType().equals(ASYNC)) {
+
+            // Asynchronous forward
+            asyncForward(servletRequest, servletResponse);
+            return;
+        }
+
+        // Regular (synchronous) forward
+        syncForward(servletRequest, servletResponse);
+    }
+
+    /**
+     * Dispatches using the INCLUDE dispatch type - Include the request and response.
+     *
+     * @param servletRequest the request.
+     * @param servletResponse the response.
+     * @throws ServletException when a servlet error occurs.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public void include(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
+        try (DefaultWebApplicationRequest includedRequest = new DefaultWebApplicationRequest()) {
+            HttpServletRequest originalRequest = unwrap(servletRequest, HttpServletRequest.class);
+
+            // Change the underlying request if the request was wrapped
+            ServletRequestWrapper wrapper = servletRequest instanceof ServletRequestWrapper ? getLastWrapper((ServletRequestWrapper) servletRequest) : new HttpServletRequestWrapper(originalRequest);
+            wrapper.setRequest(includedRequest);
+
+            includedRequest.setWebApplication(servletEnvironment.getWebApplication());
+            includedRequest.setContextPath(originalRequest.getContextPath());
+
+            includedRequest.setServletPath(path == null ? "/" + servletEnvironment.getServletName() : getServletPath(path));
+            includedRequest.setDispatcherType(INCLUDE);
+            includedRequest.setPathInfo(null);
+            includedRequest.setQueryString(originalRequest.getQueryString());
+
+            copyAttributesFromRequest(originalRequest, includedRequest, attributeName -> true);
+
+            if (path != null) {
+                includedRequest.setAttribute(INCLUDE_CONTEXT_PATH, includedRequest.getContextPath());
+                includedRequest.setAttribute(INCLUDE_SERVLET_PATH, includedRequest.getServletPath());
+                includedRequest.setAttribute(INCLUDE_PATH_INFO, includedRequest.getPathInfo());
+                includedRequest.setAttribute(INCLUDE_REQUEST_URI, includedRequest.getRequestURI());
+                includedRequest.setAttribute(INCLUDE_QUERY_STRING, getQueryString(path));
+            }
+            CurrentRequestHolder currentRequestHolder = updateCurrentRequest(originalRequest, includedRequest);
+
+            invocationFinder.addFilters(INCLUDE, servletInvocation, includedRequest.getServletPath(), "");
+
+            // After setting the include attributes and adding filters, reset the servlet path
+            includedRequest.setServletPath(originalRequest.getServletPath());
+
+            try {
+                servletEnvironment.getWebApplication().linkRequestAndResponse(includedRequest, servletResponse);
+
+                servletInvocation.getFilterChain().doFilter(wrapper, servletResponse);
+
+                // After the include, we need to copy the attributes that were set in the new request to the old one
+                // but not include the "INCLUDE_" attributes that were set previously
+                copyAttributesFromRequest(includedRequest, originalRequest, attributeName ->
+                    originalRequest.getAttribute(attributeName) == null && Stream.of(
+                        INCLUDE_QUERY_STRING,
+                        INCLUDE_CONTEXT_PATH,
+                        INCLUDE_MAPPING,
+                        INCLUDE_PATH_INFO,
+                        INCLUDE_REQUEST_URI,
+                        INCLUDE_SERVLET_PATH).noneMatch(attributeName::equals));
+
+                servletEnvironment.getWebApplication().unlinkRequestAndResponse(includedRequest, servletResponse);
+            } catch (Exception e) {
+                rethrow(e);
+            } finally {
+                restoreCurrentRequest(currentRequestHolder, originalRequest);
+                wrapper.setRequest(originalRequest);
+            }
+        }
+    }
+
+    private ServletRequestWrapper getLastWrapper(ServletRequestWrapper wrapper) {
+        ServletRequestWrapper currentWrapper = wrapper;
+        ServletRequest currentRequest = wrapper;
+        while (currentRequest instanceof ServletRequestWrapper) {
+            currentWrapper = (ServletRequestWrapper) currentRequest;
+            currentRequest = currentWrapper.getRequest();
+        }
+
+        return currentWrapper;
+    }
+
+    /**
+     * Send an error response.
+     * 
+     * @param servletName the servlet name.
+     * @param servletRequest the servlet request.
+     * @param servletResponse the servlet response.
+     * @param throwable the throwable.
+     * @throws Exception when a serious error occurs.
+     */
+    public void error(String servletName, ServletRequest servletRequest, ServletResponse servletResponse, Throwable throwable) throws Exception {
+        try (DefaultWebApplicationRequest errorRequest = new DefaultWebApplicationRequest()) {
+
+            HttpServletRequest request = (HttpServletRequest) servletRequest;
+            HttpServletResponse response = (HttpServletResponse) servletResponse;
+
+            response.resetBuffer();
+
+            errorRequest.setWebApplication(servletEnvironment.getWebApplication());
+            errorRequest.setContextPath(request.getContextPath());
+            errorRequest.setDispatcherType(ERROR);
+
+            if (path != null) {
+                setForwardAttributes(request, errorRequest,
+                        FORWARD_CONTEXT_PATH,
+                        FORWARD_PATH_INFO,
+                        FORWARD_QUERY_STRING,
+                        FORWARD_REQUEST_URI,
+                        FORWARD_SERVLET_PATH);
+
+                errorRequest.setServletPath(getServletPath(path));
+                errorRequest.setQueryString(getQueryString(path));
+
+            } else {
+                errorRequest.setServletPath("/" + servletEnvironment.getServletName());
+            }
+
+            errorRequest.setAttribute(ERROR_EXCEPTION, throwable);
+            errorRequest.setAttribute(ERROR_EXCEPTION_TYPE, throwable == null ? null : throwable.getClass());
+            errorRequest.setAttribute(ERROR_MESSAGE, throwable == null ? null : throwable.getMessage());
+            errorRequest.setAttribute(ERROR_STATUS_CODE, response.getStatus());
+            errorRequest.setAttribute(ERROR_REQUEST_URI, request.getRequestURI());
+            errorRequest.setAttribute(ERROR_SERVLET_NAME, servletName);
+
+
+            CurrentRequestHolder currentRequestHolder = updateCurrentRequest(request, errorRequest);
+
+            copyAttributesFromRequest(request, errorRequest, attribute -> true);
+
+            invocationFinder.addFilters(ERROR, servletInvocation, errorRequest.getServletPath(), "");
+
+            if (servletInvocation.getServletEnvironment() != null) {
+                errorRequest.setAsyncSupported(request.isAsyncSupported() && isAsyncSupportedInChain());
+            }
+
+            try {
+                servletEnvironment.getWebApplication().linkRequestAndResponse(errorRequest, servletResponse);
+
+                servletInvocation.getFilterChain().doFilter(errorRequest, servletResponse);
+
+                servletEnvironment.getWebApplication().unlinkRequestAndResponse(errorRequest, servletResponse);
+            } finally {
+                restoreCurrentRequest(currentRequestHolder, request);
+            }
+
+            response.flushBuffer();
+        }
+
+
+    }
+
+    // #### SYNC forward private methods
+    private void syncForward(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
+        if (servletResponse.isCommitted()) {
+            throw new IllegalStateException("Response already committed");
+        }
+
+        try (DefaultWebApplicationRequest forwardedRequest = new DefaultWebApplicationRequest()) {
+
+            HttpServletRequest request =  unwrap(servletRequest, HttpServletRequest.class);
+            HttpServletResponse response = (HttpServletResponse) servletResponse;
+
+            response.resetBuffer();
+
+            forwardedRequest.setWebApplication(servletEnvironment.getWebApplication());
+            forwardedRequest.setContextPath(request.getContextPath());
+            forwardedRequest.setDispatcherType(FORWARD);
+
+            if (path != null) {
+                setForwardAttributes(request, forwardedRequest,
+                        FORWARD_CONTEXT_PATH,
+                        FORWARD_PATH_INFO,
+                        FORWARD_QUERY_STRING,
+                        FORWARD_REQUEST_URI,
+                        FORWARD_SERVLET_PATH);
+
+                forwardedRequest.setServletPath(getServletPath(path));
+                forwardedRequest.setQueryString(getQueryString(path));
+
+            } else {
+                forwardedRequest.setServletPath("/" + servletEnvironment.getServletName());
+                forwardedRequest.setQueryString(request.getQueryString());
+            }
+
+            CurrentRequestHolder currentRequestHolder = updateCurrentRequest(request, forwardedRequest);
+
+            copyAttributesFromRequest(request, forwardedRequest, attribute -> true);
+
+            invocationFinder.addFilters(FORWARD, servletInvocation, forwardedRequest.getServletPath(), "");
+
+            if (servletInvocation.getServletEnvironment() != null) {
+                forwardedRequest.setAsyncSupported(request.isAsyncSupported() && isAsyncSupportedInChain());
+            }
+
+            try {
+                servletEnvironment.getWebApplication().linkRequestAndResponse(forwardedRequest, servletResponse);
+
+                servletInvocation.getFilterChain().doFilter(forwardedRequest, servletResponse);
+
+                servletEnvironment.getWebApplication().unlinkRequestAndResponse(forwardedRequest, servletResponse);
+            } catch (Exception e) {
+                rethrow(e);
+            } finally {
+                restoreCurrentRequest(currentRequestHolder, request);
+            }
+
+            response.flushBuffer();
+        }
+    }
+
+    /**
+     * Checks if all filters (if any) and the servlet support async
+     * @return true if all supports, false otherwise
+     */
+    private boolean isAsyncSupportedInChain() {
+        List<FilterEnvironment> filterEnvironments = servletInvocation.getFilterEnvironments();
+        boolean hasFilterAsync = filterEnvironments == null || filterEnvironments.stream().allMatch(FilterEnvironment::isAsyncSupported);
+        return servletInvocation.getServletEnvironment().isAsyncSupported() && hasFilterAsync;
+    }
+
+
+    private void setForwardAttributes(HttpServletRequest originalRequest, HttpServletRequest forwardedRequest, String... dispatcherKeys) {
+        for (String dispatcherKey : dispatcherKeys) {
+            setForwardAttribute(originalRequest, forwardedRequest, dispatcherKey);
+        }
+    }
+
+    /**
+     * Set forward attribute.
+     *
+     * @param originalRequest the original request
+     * @param forwardedRequest the forward request.
+     * @param dispatcherKey the dispatcher key.
+     */
+    private void setForwardAttribute(HttpServletRequest originalRequest, HttpServletRequest forwardedRequest, String dispatcherKey) {
+        String value = null;
+
+        if (originalRequest.getAttribute(dispatcherKey) != null) {
+            value = (String) originalRequest.getAttribute(dispatcherKey);
+        } else {
+            if (dispatcherKey.equals(FORWARD_CONTEXT_PATH)) {
+                value = originalRequest.getContextPath();
+            }
+            if (dispatcherKey.equals(FORWARD_PATH_INFO)) {
+                value = originalRequest.getPathInfo();
+            }
+            if (dispatcherKey.equals(FORWARD_QUERY_STRING)) {
+                value = originalRequest.getQueryString();
+            }
+            if (dispatcherKey.equals(FORWARD_REQUEST_URI)) {
+                value = originalRequest.getRequestURI();
+            }
+            if (dispatcherKey.equals(FORWARD_SERVLET_PATH)) {
+                value = originalRequest.getServletPath();
+            }
+        }
+
+        forwardedRequest.setAttribute(dispatcherKey, value);
+    }
+
+    private CurrentRequestHolder updateCurrentRequest(HttpServletRequest originalRequest, HttpServletRequest forwardedRequest) {
+        CurrentRequestHolder currentRequestHolder = (CurrentRequestHolder) originalRequest.getAttribute(CURRENT_REQUEST_ATTRIBUTE);
+        if (currentRequestHolder != null) {
+            currentRequestHolder.setRequest(forwardedRequest);
+            forwardedRequest.setAttribute(CURRENT_REQUEST_ATTRIBUTE, currentRequestHolder);
+        }
+
+        forwardedRequest.setAttribute(PREVIOUS_REQUEST, originalRequest);
+
+        return currentRequestHolder;
+    }
+
+    private void copyAttributesFromRequest(ServletRequest fromRequest, ServletRequest toRequest, Predicate<String> attributesToExclude) {
+        Collections.list(fromRequest.getAttributeNames())
+                .stream()
+                .filter(attributesToExclude)
+                .forEach(attributeName -> toRequest.setAttribute(attributeName, fromRequest.getAttribute(attributeName)));
+    }
+
+    private void restoreCurrentRequest(CurrentRequestHolder currentRequestHolder, HttpServletRequest originalRequest) {
+        if (currentRequestHolder != null) {
+            currentRequestHolder.setRequest(originalRequest);
+        }
+    }
+
+    // #### ASYNC forward private methods
+    private void asyncForward(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
+
+        if (servletRequest instanceof AsyncHttpDispatchWrapper
+                || servletRequest instanceof AsyncNonHttpDispatchWrapper) {
+
+            if (servletRequest instanceof AsyncHttpDispatchWrapper) {
+                // The caller provided or let us default to an HttpServletRequest
+                asyncHttpForward((AsyncHttpDispatchWrapper) servletRequest, servletResponse);
+                return;
+            }
+
+            // The caller provided a ServletRequest
+            asyncNonHttpForward((AsyncNonHttpDispatchWrapper) servletRequest, servletResponse);
+        } else {
+            throw new IllegalStateException("Async invocations without wrapper not supported at this moment.");
+        }
+    }
+
+    private void asyncHttpForward(AsyncHttpDispatchWrapper asyncHttpDispatchWrapper, ServletResponse servletResponse) throws ServletException, IOException {
+        // A typical chain to arrive here is DefaultAsyncContext#dispatch -> DefaultAsyncDispatcher#dispatch -> forward -> asyncForwrd -> asyncHttpForward
+
+        HttpServletRequest asyncStartRequest = asyncHttpDispatchWrapper.getRequest();
+
+        if (asyncStartRequest instanceof WebApplicationRequest) {
+            // original request or previously dispatched request passed-in, not an application wrapped one
+            // In this case our asyncHttpDispatchWrapper is both the object with which the Servlet will be invoked, as well as the
+            // object on which the path and attributes for the previous path will be set.
+
+            invokeTargetAsyncServlet(asyncHttpDispatchWrapper, servletResponse);
+
+        } else if (asyncStartRequest instanceof HttpServletRequestWrapper) {
+            // Application wrapped request passed-in. We now need no make sure that the applications sees this request
+
+            // We swap our asyncHttpDispatchWrapper from being the head of the chain, to be in between the request that was provided by the application
+            // and the request it is wrapping.
+            HttpServletRequestWrapper applicationProvidedWrapper = (HttpServletRequestWrapper) asyncStartRequest;
+
+            ServletRequest wrappedRequest = applicationProvidedWrapper.getRequest();
+
+            applicationProvidedWrapper.setRequest(asyncHttpDispatchWrapper);
+            asyncHttpDispatchWrapper.setRequest(wrappedRequest);
+
+            // Original chain: asyncHttpDispatchWrapper -> applicationProvidedWrapper (asyncStartRequest) -> wrappedRequest
+            // New chain: applicationProvidedWrapper (asyncStartRequest) -> asyncHttpDispatchWrapper -> wrappedRequest
+            invokeTargetAsyncServlet(applicationProvidedWrapper, asyncHttpDispatchWrapper, servletResponse);
+
+        } else {
+            throw new IllegalStateException("Async invocation with a request that was neither the original one nor a wrapped one: " + asyncStartRequest);
+        }
+    }
+
+    private void asyncNonHttpForward(AsyncNonHttpDispatchWrapper asyncNonHttpDispatchWrapper, ServletResponse servletResponse) throws ServletException, IOException {
+        // A typical chain to arrive here is DefaultAsyncContext#dispatch -> DefaultAsyncDispatcher#dispatch -> forward -> asyncForward -> asyncNonHttpForward
+
+        ServletRequest asyncStartRequest = asyncNonHttpDispatchWrapper.getRequest();
+
+        if (asyncStartRequest instanceof ServletRequestWrapper) {
+
+            ServletRequestWrapper applicationProvidedWrapper = (ServletRequestWrapper) asyncStartRequest;
+
+            HttpServletRequest httpServletRequestInChain = findHttpServletRequestInChain(applicationProvidedWrapper);
+
+            if (httpServletRequestInChain != null) {
+
+                // We swap our asyncHttpDispatchWrapper from being the head of the chain, with a new wrapper, wrapping the HttpServletRequest that we found, and put
+                // that in between the request that was provided by the application and the request it is wrapping.
+                ServletRequest wrappedRequest = applicationProvidedWrapper.getRequest();
+
+                AsyncHttpDispatchWrapper newAsyncHttpDispatchWrapper = new AsyncHttpDispatchWrapper(null);
+                // Note that by doing this, methods called on HttpServletRequestWrapper itself (and not its super interface) will throw.
+                newAsyncHttpDispatchWrapper.setRequest(wrappedRequest);
+
+                applicationProvidedWrapper.setRequest(newAsyncHttpDispatchWrapper);
+
+                // Original chain: asyncNonHttpDispatchWrapper -> applicationProvidedWrapper (asyncStartRequest) -> wrappedRequest -> .... -> HttpServletRequest
+                // New chain: applicationProvidedWrapper (asyncStartRequest) -> newAsyncHttpDispatchWrapper -> wrappedRequest -> .... -> HttpServletRequest
+                invokeTargetAsyncServlet(asyncStartRequest, httpServletRequestInChain, newAsyncHttpDispatchWrapper, servletResponse);
+            }
+
+        }
+    }
+
+    private void invokeTargetAsyncServlet(AsyncHttpDispatchWrapper asyncHttpDispatchWrapper, ServletResponse servletResponse) throws ServletException, IOException {
+        invokeTargetAsyncServlet(asyncHttpDispatchWrapper, asyncHttpDispatchWrapper, servletResponse);
+    }
+
+    private void invokeTargetAsyncServlet(HttpServletRequest invokeServletRequest, AsyncHttpDispatchWrapper asyncHttpDispatchWrapper, ServletResponse servletResponse) throws ServletException, IOException {
+        invokeTargetAsyncServlet(invokeServletRequest, invokeServletRequest, asyncHttpDispatchWrapper, servletResponse);
+    }
+
+    private void invokeTargetAsyncServlet(ServletRequest invokeServletRequest, HttpServletRequest previousPathRequest, AsyncHttpDispatchWrapper asyncHttpDispatchWrapper, ServletResponse servletResponse) throws ServletException, IOException {
+        // A typical call chain to arrive here is DefaultAsyncContext#dispatch -> DefaultAsyncDispatcher#dispatch -> forward -> asyncForwrd -> asyncHttpForward -> invokeTargetAsyncServlet
+
+        if (path != null) {
+
+            setAsyncAttributes(previousPathRequest, asyncHttpDispatchWrapper);
+
+            asyncHttpDispatchWrapper.setServletPath(getServletPath(path));
+
+            String queryString = getQueryString(path);
+            if (queryString != null && !queryString.trim().equals("")) {
+                asyncHttpDispatchWrapper.setQueryString(queryString);
+                setRequestParameters(queryString, asyncHttpDispatchWrapper);
+            } else {
+                asyncHttpDispatchWrapper.setQueryString(previousPathRequest.getQueryString());
+            }
+
+            asyncHttpDispatchWrapper.setRequestURI(previousPathRequest.getServletContext().getContextPath() + getServletPath(path));
+            asyncHttpDispatchWrapper.setAsWrapperAttribute(PREVIOUS_REQUEST, invokeServletRequest);
+
+        } else {
+            asyncHttpDispatchWrapper.setServletPath("/" + servletEnvironment.getServletName());
+        }
+
+
+
+        servletEnvironment.getWebApplication().linkRequestAndResponse(invokeServletRequest, servletResponse);
+        servletEnvironment.getServlet().service(invokeServletRequest, servletResponse);
+        servletEnvironment.getWebApplication().unlinkRequestAndResponse(invokeServletRequest, servletResponse);
+    }
+
+    private void setAsyncAttributes(HttpServletRequest asyncStartRequest, AsyncHttpDispatchWrapper asyncHttpDispatchWrapper) {
+        for (String asyncAttribute : ASYNC_ATTRIBUTES) {
+            // Set the spec demanded attributes on asyncHttpDispatchWrapper with the values taken from asyncStartRequest
+            setAsyncAttribute(asyncStartRequest, asyncHttpDispatchWrapper, asyncAttribute);
+        }
+    }
+
+    private void setAsyncAttribute(HttpServletRequest originalRequest, AsyncHttpDispatchWrapper asyncHttpDispatchWrapper, String dispatcherKey) {
+        String value = null;
+
+        if (originalRequest.getAttribute(dispatcherKey) != null) {
+            value = (String) originalRequest.getAttribute(dispatcherKey);
+        } else {
+            if (dispatcherKey.equals(ASYNC_CONTEXT_PATH)) {
+                value = originalRequest.getContextPath();
+            }
+            if (dispatcherKey.equals(ASYNC_PATH_INFO)) {
+                value = originalRequest.getPathInfo();
+            }
+            if (dispatcherKey.equals(ASYNC_QUERY_STRING)) {
+                value = originalRequest.getQueryString();
+            }
+            if (dispatcherKey.equals(ASYNC_REQUEST_URI)) {
+                value = originalRequest.getRequestURI();
+            }
+            if (dispatcherKey.equals(ASYNC_SERVLET_PATH)) {
+                value = originalRequest.getServletPath();
+            }
+        }
+
+        asyncHttpDispatchWrapper.setAsWrapperAttribute(dispatcherKey, value);
+    }
+
+    private void setRequestParameters(String queryString, AsyncHttpDispatchWrapper asyncHttpDispatchWrapper) {
+        try {
+            Map<String, String[]> parameters = asyncHttpDispatchWrapper.getWrapperParameters();
+
+            if (queryString != null) {
+                for (String param : queryString.split("&")) {
+                    String pair[] = param.split("=");
+                    String key = URLDecoder.decode(pair[0], "UTF-8");
+                    String value = "";
+                    if (pair.length > 1) {
+                        value = URLDecoder.decode(pair[1], "UTF-8");
+                    }
+                    String[] values = parameters.get(key);
+                    if (values == null) {
+                        values = new String[]{value};
+                        parameters.put(key, values);
+                    } else {
+                        String[] newValues = new String[values.length + 1];
+                        System.arraycopy(values, 0, newValues, 0, values.length);
+                        newValues[values.length] = value;
+                        parameters.put(key, newValues);
+                    }
+                }
+            }
+        } catch (UnsupportedEncodingException e) {
+            throw new IllegalStateException(e);
+        }
+
+    }
+
+    private String getServletPath(String path) {
+        return !path.contains("?") ? path : path.substring(0, path.indexOf("?"));
+    }
+
+    private String getQueryString(String path) {
+        return !path.contains("?") ? null : path.substring(path.indexOf("?") + 1);
+    }
+
+    private HttpServletRequest findHttpServletRequestInChain(ServletRequest request) {
+        ServletRequest currentRequest = request;
+        while (currentRequest instanceof ServletRequestWrapper) {
+            ServletRequestWrapper wrapper = (ServletRequestWrapper) currentRequest;
+            currentRequest = wrapper.getRequest();
+
+            if (currentRequest instanceof HttpServletRequest) {
+                return (HttpServletRequest) currentRequest;
+            }
+        }
+        return null;
+    }
+
+    private void rethrow(Throwable exception) throws ServletException, IOException {
+        if (exception instanceof ServletException) {
+            throw (ServletException) exception;
+        }
+
+        if (exception instanceof IOException) {
+            throw (IOException) exception;
+        }
+
+        if (exception instanceof RuntimeException) {
+            throw (RuntimeException) exception;
+        }
+
+        throw new IllegalStateException(exception);
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplication.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplication.java
new file mode 100644
index 00000000..ab311e5f
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplication.java
@@ -0,0 +1,2098 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.naming.api.NamingManager;
+import cloud.piranha.naming.impl.DefaultInitialContext;
+import cloud.piranha.naming.impl.DefaultNamingManager;
+import cloud.piranha.policy.api.PolicyManager;
+import cloud.piranha.policy.impl.DefaultPolicyManager;
+import cloud.piranha.resource.DefaultResourceManager;
+import cloud.piranha.resource.api.Resource;
+import cloud.piranha.resource.api.ResourceManager;
+import cloud.piranha.servlet4.webapp.AnnotationManager;
+import cloud.piranha.servlet4.webapp.AsyncManager;
+import cloud.piranha.servlet4.webapp.HttpRequestManager;
+import cloud.piranha.servlet4.webapp.HttpSessionManager;
+import cloud.piranha.servlet4.webapp.JspManager;
+import cloud.piranha.servlet4.webapp.LocaleEncodingManager;
+import cloud.piranha.servlet4.webapp.LoggingManager;
+import cloud.piranha.servlet4.webapp.MimeTypeManager;
+import cloud.piranha.servlet4.webapp.MultiPartManager;
+import cloud.piranha.servlet4.webapp.ObjectInstanceManager;
+import cloud.piranha.servlet4.webapp.SecurityManager;
+import cloud.piranha.servlet4.webapp.ServletEnvironment;
+import static cloud.piranha.servlet4.webapp.ServletEnvironment.UNAVAILABLE;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationRequestMapper;
+import cloud.piranha.servlet4.webapp.WelcomeFileManager;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import static java.util.Collections.enumeration;
+import static java.util.Collections.reverse;
+import static java.util.Collections.unmodifiableMap;
+import java.util.Enumeration;
+import java.util.EventListener;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import static java.util.Objects.requireNonNull;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import static java.util.function.Predicate.isEqual;
+import static java.util.function.Predicate.not;
+import static java.util.logging.Level.FINE;
+import static java.util.logging.Level.WARNING;
+import java.util.logging.Logger;
+import java.util.stream.Collectors;
+import static java.util.stream.Collectors.toSet;
+import java.util.stream.Stream;
+import javax.servlet.DispatcherType;
+import javax.servlet.Filter;
+import javax.servlet.FilterRegistration;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.Servlet;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletContextAttributeEvent;
+import javax.servlet.ServletContextAttributeListener;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.ServletRegistration.Dynamic;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestAttributeListener;
+import javax.servlet.ServletRequestEvent;
+import javax.servlet.ServletRequestListener;
+import javax.servlet.ServletResponse;
+import javax.servlet.SessionCookieConfig;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.UnavailableException;
+import javax.servlet.annotation.HandlesTypes;
+import javax.servlet.descriptor.JspConfigDescriptor;
+import javax.servlet.http.HttpSessionAttributeListener;
+import javax.servlet.http.HttpSessionIdListener;
+import javax.servlet.http.HttpSessionListener;
+
+/**
+ * The default WebApplication.
+ *
+ * <p>
+ * The <code>filters</code> field is backed by a LinkedHashMap so we get an
+ * insertion-order key set. If you change this, be aware that methods using this
+ * field should be changed to account for that.
+ * </p>
+ *
+ * <p>
+ * The <code>servlets</code> field is backed by a LinkedHashMap so we get an
+ * insertion-order key set. If you change this, be aware that methods using this
+ * field should be changed to account for that.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWebApplication implements WebApplication {
+
+    /**
+     * Stores the SETUP constant.
+     */
+    protected static final int SETUP = 0;
+
+    /**
+     * Stores the INITIALIZED_DECLARED constant. This signals that web.xml, web-fragment.xml
+     * and annotations have been processed.
+     */
+    protected static final int INITIALIZED_DECLARED = 4;
+
+    /**
+     * Stores the INITIALIZED constant.
+     */
+    protected static final int INITIALIZED = 1;
+
+    /**
+     * Stores the SERVICING constant.
+     */
+    protected static final int SERVICING = 2;
+
+    /**
+     * Stores the ERROR constant.
+     */
+    protected static final int ERROR = 3;
+
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(DefaultWebApplication.class.getName());
+
+    /**
+     * Stores the async manager.
+     */
+    protected AsyncManager asyncManager;
+
+    /**
+     * Stores the class loader.
+     */
+    protected ClassLoader classLoader;
+
+    /**
+     * Stores the context path.
+     */
+    protected String contextPath;
+
+    /**
+     * Stores the default servlet (if any).
+     */
+    protected Servlet defaultServlet;
+
+    /**
+     * Stores the boolean flag indicating if the web application is
+     * distributable.
+     */
+    protected boolean distributable;
+
+    /**
+     * Stores the effective major version.
+     */
+    protected int effectiveMajorVersion = -1;
+
+    /**
+     * Stores the effective minor version.
+     */
+    protected int effectiveMinorVersion = -1;
+    
+    /**
+     * Stores the naming manager.
+     */
+    protected NamingManager namingManager;
+
+    /**
+     * Stores the servlet context name.
+     */
+    protected String servletContextName;
+
+    /**
+     * Stores the virtual server name.
+     */
+    protected String virtualServerName = "server";
+
+    /**
+     * Stores the response character encoding.
+     */
+    protected String responseCharacterEncoding;
+
+    /**
+     * Stores the status.
+     */
+    protected int status;
+
+    /**
+     * Stores the active responses and the associated requests.
+     */
+    protected final Map<ServletResponse, ServletRequest> responses;
+
+    /**
+     * Stores the servlet container initializers.
+     */
+    protected final List<ServletContainerInitializer> initializers;
+
+    /**
+     * Stores the init parameters.
+     */
+    protected final Map<String, String> initParameters;
+
+    /**
+     * Stores the attributes.
+     */
+    protected final Map<String, Object> attributes;
+
+    /**
+     * Stores the locale encoding manager
+     */
+    protected LocaleEncodingManager localeEncodingManager;
+
+    /**
+     * Stores the servlet environments
+     */
+    protected final Map<String, DefaultServletEnvironment> servletEnvironments;
+
+    /**
+     * Stores the filters.
+     */
+    protected final Map<String, DefaultFilterEnvironment> filters;
+
+    // ### Listeners
+    /**
+     * Stores the servlet context attribute listeners.
+     */
+    protected final List<ServletContextAttributeListener> contextAttributeListeners;
+
+    /**
+     * Stores the servlet context listeners that were declared in web.xml, web-fragment.xml, or via annotations
+     */
+    protected final List<ServletContextListener> declaredContextListeners;
+
+    /**
+     * Stores the servlet context listeners that were not declared in web.xml, web-fragment.xml, or via annotations
+     */
+    protected final List<ServletContextListener> contextListeners;
+
+    /**
+     * Stores the servlet request listeners.
+     */
+    protected final List<ServletRequestListener> requestListeners;
+
+    // ### Managers
+    /**
+     * Stores the object instance manager.
+     */
+    protected ObjectInstanceManager objectInstanceManager;
+
+    /**
+     * Stores the annotation manager.
+     */
+    protected AnnotationManager annotationManager;
+
+    /**
+     * Stores the resource manager.
+     */
+    protected ResourceManager resourceManager;
+
+    /**
+     * Stores the session manager.
+     */
+    protected HttpSessionManager httpSessionManager;
+
+    /**
+     * Stores the error page manager
+     */
+    protected DefaultErrorPageManager errorPageManager;
+
+    /**
+     * Stores the security manager.
+     */
+    protected SecurityManager securityManager;
+
+    /**
+     * Stores the JSP manager.
+     */
+    protected JspManager jspManager;
+
+    /**
+     * Stores the logging manager.
+     */
+    protected LoggingManager loggingManager;
+
+    /**
+     * Stores the request manager.
+     */
+    protected HttpRequestManager httpRequestManager;
+
+    /**
+     * Stores the mime type manager.
+     */
+    protected MimeTypeManager mimeTypeManager;
+
+    /**
+     * Stores the multi part manager.
+     */
+    protected MultiPartManager multiPartManager;
+    
+    /**
+     * Stores the Policy manager.
+     */
+    protected PolicyManager policyManager;
+
+    /**
+     * Stores the request character encoding.
+     */
+    protected String requestCharacterEncoding;
+
+    /**
+     * Stores the web application request mapper.
+     */
+    protected WebApplicationRequestMapper webApplicationRequestMapper;
+
+    /**
+     * Stores the welcome file manager.
+     */
+    protected WelcomeFileManager welcomeFileManager;
+
+    /**
+     * Stores the invocation finder, which finds a Servlet, Filter(chain) and variants thereof to invoke
+     * for a given request path.
+     */
+    protected DefaultInvocationFinder invocationFinder;
+
+    /**
+     * When we're in tainted mode, we have to throw exceptions for a large number of methods.
+     *
+     * Tainted mode is required for ServletContextListeners which have not been declared. At the
+     * moment of writing it's not clear why this tainted mode is needed.
+     */
+    protected boolean tainted;
+
+    /**
+     * The source object where this web application instance originates from, i.e. the artifact this
+     * was last passed into by the container. Compare to the source object of an event.
+     */
+    protected Object source;
+
+    /**
+     * Constructor.
+     */
+    public DefaultWebApplication() {
+        annotationManager = new DefaultAnnotationManager();
+        asyncManager = new DefaultAsyncManager();
+        attributes = new HashMap<>(1);
+        classLoader = getClass().getClassLoader();
+        contextAttributeListeners = new ArrayList<>(1);
+        declaredContextListeners = new ArrayList<>(1);
+        contextListeners = new ArrayList<>(1);
+        contextPath = "";
+        filters = new LinkedHashMap<>(1);
+        httpSessionManager = new DefaultHttpSessionManager();
+        httpSessionManager.setWebApplication(this);
+        httpRequestManager = new DefaultHttpRequestManager();
+        initParameters = new ConcurrentHashMap<>(1);
+        initializers = new ArrayList<>(1);
+        jspManager = new DefaultJspFileManager();
+        loggingManager = new DefaultLoggingManager();
+        mimeTypeManager = new DefaultMimeTypeManager();
+        multiPartManager = new DefaultMultiPartManager();
+        namingManager = new DefaultNamingManager(new DefaultInitialContext());
+        objectInstanceManager = new DefaultObjectInstanceManager();
+        policyManager = new DefaultPolicyManager();
+        requestListeners = new ArrayList<>(1);
+        resourceManager = new DefaultResourceManager();
+        responses = new ConcurrentHashMap<>(1);
+        errorPageManager = new DefaultErrorPageManager();
+        securityManager = new DefaultSecurityManager();
+        servletContextName = UUID.randomUUID().toString();
+        servletEnvironments = new LinkedHashMap<>();
+        webApplicationRequestMapper = new DefaultWebApplicationRequestMapper();
+        welcomeFileManager = new DefaultWelcomeFileManager();
+        invocationFinder = new DefaultInvocationFinder(this);
+        localeEncodingManager = new DefaultLocaleEncodingManager();
+    }
+
+    @Override
+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {
+        return addFilter(filterName, filterClass.getCanonicalName());
+    }
+
+    @Override
+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {
+        checkTainted();
+        checkServicing();
+
+        if (filterName == null || filterName.trim().equals("")) {
+            throw new IllegalArgumentException("Filter name cannot be null or empty");
+        }
+
+        DefaultFilterEnvironment defaultFilterEnvironment;
+        if (filters.containsKey(filterName)) {
+            defaultFilterEnvironment = filters.get(filterName);
+            if (defaultFilterEnvironment.getClassName() != null) {
+                // Filter already set, can't override
+                return null;
+            }
+        } else {
+            defaultFilterEnvironment = new DefaultFilterEnvironment();
+            defaultFilterEnvironment.setFilterName(filterName);
+            defaultFilterEnvironment.setWebApplication(this);
+            filters.put(filterName, defaultFilterEnvironment);
+        }
+        defaultFilterEnvironment.setClassName(className);
+
+        return defaultFilterEnvironment;
+    }
+
+    @Override
+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {
+        checkTainted();
+        checkServicing();
+
+        if (filters.containsKey(filterName)) {
+            DefaultFilterEnvironment filterEnvironment = filters.get(filterName);
+            if (filterEnvironment.getClassName() != null) {
+                // Filter already set, can't override
+                return null;
+            }
+        }
+
+        DefaultFilterEnvironment filterEnvironment = new DefaultFilterEnvironment(this, filterName, filter);
+        filters.put(filterName, filterEnvironment);
+
+        return filterEnvironment;
+
+    }
+
+    @Override
+    public Set<String> addFilterMapping(Set<DispatcherType> dispatcherTypes, String filterName, boolean isMatchAfter, String... urlPatterns) {
+        if (isMatchAfter) {
+            return webApplicationRequestMapper.addFilterMapping(dispatcherTypes, filterName, urlPatterns);
+        }
+
+        return webApplicationRequestMapper.addFilterMappingBeforeExisting(dispatcherTypes, filterName, urlPatterns);
+    }
+
+    @Override
+    public void addInitializer(String className) {
+        try {
+            @SuppressWarnings("unchecked")
+            Class<ServletContainerInitializer> clazz = (Class<ServletContainerInitializer>) getClassLoader().loadClass(className);
+            initializers.add(clazz.getDeclaredConstructor().newInstance());
+        } catch (Throwable throwable) {
+            LOGGER.log(WARNING, throwable, () -> "Unable to add initializer: " + className);
+        }
+    }
+
+    @Override
+    public void addInitializer(ServletContainerInitializer servletContainerInitializer) {
+        initializers.add(servletContainerInitializer);
+    }
+
+    @Override
+    public ServletRegistration.Dynamic addJspFile(String servletName, String jspFile) {
+        if (status != SETUP && status != INITIALIZED_DECLARED) {
+            throw new IllegalStateException("Illegal to add JSP file because state is not SETUP");
+        }
+
+        if (isEmpty(servletName)) {
+            throw new IllegalArgumentException("Servlet name cannot be null or empty");
+        }
+
+        return jspManager.addJspFile(this, servletName, jspFile);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void addListener(String className) {
+        checkTainted();
+
+        if (status != SETUP && status != INITIALIZED_DECLARED) {
+            throw new IllegalStateException("Illegal to add listener because state is not SETUP");
+        }
+
+        try {
+            addListener((Class<EventListener>) getClassLoader().loadClass(className));
+        } catch (ClassNotFoundException exception) {
+            LOGGER.log(WARNING, exception, () -> "Unable to add listener: " + className);
+        }
+    }
+
+    @Override
+    public void addListener(Class<? extends EventListener> type) {
+        checkTainted();
+
+        if (status != SETUP && status != INITIALIZED_DECLARED) {
+            throw new IllegalStateException("Illegal to add listener because state is not SETUP");
+        }
+
+        try {
+            addListener(createListener(type));
+        } catch (ServletException exception) {
+            LOGGER.log(WARNING, exception, () -> "Unable to add listener: " + type);
+        }
+    }
+
+    @Override
+    public <T extends EventListener> void addListener(T listener) {
+        checkTainted();
+
+        if (status != SETUP && status != INITIALIZED_DECLARED) {
+            throw new IllegalStateException("Illegal to add listener because state is not SETUP");
+        }
+
+        if (listener instanceof ServletContextListener) {
+            if (source != null && source instanceof ServletContainerInitializer == false) {
+                throw new IllegalArgumentException("Illegal to add ServletContextListener because this context was not passed to a ServletContainerInitializer");
+            }
+
+            if (status == INITIALIZED_DECLARED) {
+                contextListeners.add((ServletContextListener) listener);
+            } else {
+                declaredContextListeners.add((ServletContextListener) listener);
+            }
+        }
+
+        if (listener instanceof ServletContextAttributeListener) {
+            contextAttributeListeners.add((ServletContextAttributeListener) listener);
+        }
+        if (listener instanceof ServletRequestListener) {
+            requestListeners.add((ServletRequestListener) listener);
+        }
+        if (listener instanceof ServletRequestAttributeListener) {
+            httpRequestManager.addListener((ServletRequestAttributeListener) listener);
+        }
+        if (listener instanceof HttpSessionAttributeListener) {
+            httpSessionManager.addListener(listener);
+        }
+        if (listener instanceof HttpSessionIdListener) {
+            httpSessionManager.addListener(listener);
+        }
+        if (listener instanceof HttpSessionListener) {
+            httpSessionManager.addListener(listener);
+        }
+    }
+
+    @Override
+    public void addResource(Resource resource) {
+        resourceManager.addResource(resource);
+    }
+
+    @Override
+    public Dynamic addServlet(String servletName, Class<? extends Servlet> servletClass) {
+        return addServlet(servletName, servletClass.getName());
+    }
+
+    @Override
+    public Dynamic addServlet(String servletName, String className) {
+        checkTainted();
+        checkServicing();
+
+        DefaultServletEnvironment servletEnvironment = servletEnvironments.get(servletName);
+        if (servletEnvironment == null) {
+            servletEnvironment = new DefaultServletEnvironment(this, servletName);
+            servletEnvironment.setClassName(className);
+            servletEnvironments.put(servletName, servletEnvironment);
+        } else {
+            if (!isEmpty(servletEnvironment.getClassName())) {
+                // Servlet already set, can't override
+                return null;
+            }
+            servletEnvironment.setClassName(className);
+        }
+
+        return servletEnvironment;
+    }
+
+    @Override
+    public Dynamic addServlet(String servletName, Servlet servlet) {
+        checkTainted();
+        checkServicing();
+
+        if (servletEnvironments.containsKey(servletName)) {
+            DefaultServletEnvironment servletEnvironment = servletEnvironments.get(servletName);
+            if (!isEmpty(servletEnvironment.getClassName())) {
+                // Servlet already set, can't override
+                return null;
+            }
+        }
+
+        DefaultServletEnvironment servletEnvironment = new DefaultServletEnvironment(this, servletName, servlet);
+        servletEnvironments.put(servletName, servletEnvironment);
+
+        return servletEnvironment;
+    }
+
+    @Override
+    public Set<String> addServletMapping(String servletName, String... urlPatterns) {
+        return webApplicationRequestMapper.addServletMapping(servletName, urlPatterns);
+    }
+
+    @Override
+    public void addErrorPage(int code, String location) {
+        errorPageManager.getErrorPagesByCode().put(code, location);
+    }
+
+    @Override
+    public void addErrorPage(String exception, String location) {
+        errorPageManager.getErrorPagesByException().put(exception, location);
+    }
+
+    @Override
+    public <T extends Filter> T createFilter(Class<T> filterClass) throws ServletException {
+        checkTainted();
+
+        return objectInstanceManager.createFilter(filterClass);
+    }
+
+    /**
+     * Create the listener.
+     *
+     * @param <T> the type.
+     * @param clazz the class of the listener to create.
+     * @return the listener.
+     * @throws ServletException when it fails to create the listener.
+     */
+    @Override
+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {
+        checkTainted();
+
+        T result = objectInstanceManager.createListener(clazz);
+        boolean ok = false;
+        if (result instanceof ServletContextListener || result instanceof ServletContextAttributeListener || result instanceof ServletRequestListener
+                || result instanceof ServletRequestAttributeListener || result instanceof HttpSessionAttributeListener
+                || result instanceof HttpSessionIdListener || result instanceof HttpSessionListener) {
+            ok = true;
+        }
+
+        if (!ok) {
+            LOGGER.log(WARNING, "Unable to create listener: {0}", clazz);
+            throw new IllegalArgumentException("Invalid type");
+        }
+
+        return result;
+    }
+
+    /**
+     * Create the servlet.
+     *
+     * @param <T> the return type.
+     * @param servletClass the servlet class.
+     * @return the servlet.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public <T extends Servlet> T createServlet(Class<T> servletClass) throws ServletException {
+        checkTainted();
+
+        return objectInstanceManager.createServlet(servletClass);
+    }
+
+    /**
+     * Declare roles.
+     *
+     * @param roles the roles.
+     */
+    @Override
+    public void declareRoles(String... roles) {
+        securityManager.declareRoles(roles);
+    }
+
+    /**
+     * Destroy the web application.
+     */
+    @Override
+    public void destroy() {
+        verifyState(INITIALIZED, "Unable to destroy web application");
+
+        servletEnvironments.values().stream().forEach(servletEnv -> servletEnv.getServlet().destroy());
+        servletEnvironments.clear();
+
+
+        reverse(contextListeners);
+        contextListeners.stream().forEach(listener -> listener.contextDestroyed(new ServletContextEvent(this)));
+        contextListeners.clear();
+
+        reverse(declaredContextListeners);
+        declaredContextListeners.stream().forEach(listener -> listener.contextDestroyed(new ServletContextEvent(this)));
+        declaredContextListeners.clear();
+        status = SETUP;
+    }
+
+    /**
+     * Get the attribute.
+     *
+     * @param name the attribute name.
+     * @return the attribute value.
+     */
+    @Override
+    public Object getAttribute(String name) {
+        Objects.requireNonNull(name);
+        return attributes.get(name);
+    }
+
+    /**
+     * Get the attribute names.
+     *
+     * @return the attribute names.
+     */
+    @Override
+    public Enumeration<String> getAttributeNames() {
+        return enumeration(attributes.keySet());
+    }
+
+    /**
+     * Are we denying uncovered HTTP methods.
+     *
+     * @return true if we are, false otherwise.
+     */
+    @Override
+    public boolean getDenyUncoveredHttpMethods() {
+        return securityManager.getDenyUncoveredHttpMethods();
+    }
+
+    /**
+     * Get the class loader.
+     *
+     * @return the class loader.
+     */
+    @Override
+    public ClassLoader getClassLoader() {
+        return classLoader;
+    }
+
+    /**
+     * Get the servlet context for the given uripath.
+     *
+     * @param uripath the uripath.
+     * @return the servlet context.
+     */
+    @Override
+    public ServletContext getContext(String uripath) {
+        return null;
+    }
+
+    /**
+     * Get the context path.
+     *
+     * @return the context path.
+     */
+    @Override
+    public String getContextPath() {
+        return contextPath;
+    }
+
+    /**
+     * @see WebApplication#getDefaultSessionTrackingModes()
+     */
+    @Override
+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {
+        checkTainted();
+
+        return httpSessionManager.getDefaultSessionTrackingModes();
+    }
+
+    /**
+     * @see WebApplication#getDefaultServlet()
+     */
+    @Override
+    public Servlet getDefaultServlet() {
+        return defaultServlet;
+    }
+
+    /**
+     * Get the DependencyInjectionManager.
+     *
+     * @return the DependencyInjectionManager.
+     */
+    @Override
+    public ObjectInstanceManager getObjectInstanceManager() {
+        return objectInstanceManager;
+    }
+
+    /**
+     * Get the effective major version.
+     *
+     * @return the effective major version.
+     */
+    @Override
+    public int getEffectiveMajorVersion() {
+        checkTainted();
+
+        if (effectiveMajorVersion == -1) {
+            return getMajorVersion();
+        }
+
+        return effectiveMajorVersion;
+    }
+
+    /**
+     * Get the effective minor version.
+     *
+     * @return the effective minor version.
+     */
+    @Override
+    public int getEffectiveMinorVersion() {
+        checkTainted();
+
+        if (effectiveMinorVersion == -1) {
+            return getMinorVersion();
+        }
+
+        return effectiveMinorVersion;
+    }
+
+    @Override
+    public void setEffectiveMajorVersion(int effectiveMajorVersion) {
+        this.effectiveMajorVersion = effectiveMajorVersion;
+
+    }
+
+    @Override
+    public void setEffectiveMinorVersion(int effectiveMinorVersion) {
+        this.effectiveMinorVersion = effectiveMinorVersion;
+
+    }
+
+    /**
+     * Get the multi part manager.
+     *
+     * @return the multi part manager.
+     */
+    @Override
+    public MultiPartManager getMultiPartManager() {
+        return multiPartManager;
+    }
+
+    /**
+     * Get the effective tracking modes.
+     *
+     * @return the effective tracking modes.
+     */
+    @Override
+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {
+        checkTainted();
+
+        return httpSessionManager.getEffectiveSessionTrackingModes();
+    }
+
+    /**
+     * Get the filter registration.
+     *
+     * @param filterName the filter name.
+     * @return the filter registration, or null if not found.
+     */
+    @Override
+    public FilterRegistration getFilterRegistration(String filterName) {
+        checkTainted();
+
+        return filters.get(filterName);
+    }
+
+    /**
+     * Get the filter registrations.
+     *
+     * @return the filter registrations.
+     */
+    @Override
+    public Map<String, ? extends FilterRegistration> getFilterRegistrations() {
+        checkTainted();
+
+        return unmodifiableMap(filters);
+    }
+
+    /**
+     * Get the init parameter.
+     *
+     * @param name the init parameter name.
+     * @return the init parameter value.
+     */
+    @Override
+    public String getInitParameter(String name) {
+        return initParameters.get(name);
+    }
+
+    /**
+     * Get the init parameter names.
+     *
+     * @return the enumeration.
+     */
+    @Override
+    public Enumeration<String> getInitParameterNames() {
+        return enumeration(initParameters.keySet());
+    }
+
+    @Override
+    public List<ServletContainerInitializer> getInitializers() {
+        return initializers;
+    }
+
+    /**
+     * Get the JSP config descriptor.
+     *
+     * @return the JSP config descriptor.
+     */
+    @Override
+    public JspConfigDescriptor getJspConfigDescriptor() {
+        checkTainted();
+
+        return jspManager.getJspConfigDescriptor();
+    }
+
+    /**
+     * Get the major version.
+     *
+     * @return the major version.
+     */
+    @Override
+    public int getMajorVersion() {
+        return 4;
+    }
+
+    /**
+     * Get the servlet mappings for the given servlet.
+     *
+     * @param servletName the name of the servlet.
+     * @return the servlet mappings.
+     */
+    @Override
+    public Collection<String> getMappings(String servletName) {
+        return webApplicationRequestMapper.getServletMappings(servletName);
+    }
+
+    /**
+     * Get the mime type.
+     *
+     * @param filename the filename.
+     * @return the mime type.
+     */
+    @Override
+    public String getMimeType(String filename) {
+        return mimeTypeManager.getMimeType(filename);
+    }
+
+    /**
+     * Get the mime type manager.
+     *
+     * @return the mime type manager.
+     */
+    @Override
+    public MimeTypeManager getMimeTypeManager() {
+        return mimeTypeManager;
+    }
+
+    /**
+     * Get the minor version.
+     *
+     * @return the minor version.
+     */
+    @Override
+    public int getMinorVersion() {
+        return 0;
+    }
+
+    /**
+     * Get the real path.
+     *
+     * @param path the path
+     * @return the real path.
+     */
+    @Override
+    public String getRealPath(String path) {
+        String realPath = null;
+        try {
+
+            URL resourceUrl = getResource(path);
+
+            if (resourceUrl != null && "file".equals(resourceUrl.getProtocol())) {
+                File file = new File(resourceUrl.toURI());
+                if (file.exists()) {
+                    realPath = file.toString();
+                }
+            }
+        } catch (MalformedURLException | URISyntaxException | IllegalArgumentException exception) {
+            LOGGER.log(WARNING, exception, () -> "Unable to get real path: " + path);
+        }
+        return realPath;
+    }
+
+    /**
+     * Get the request associated with the response.
+     *
+     * @param response the response.
+     * @return the request.
+     */
+    @Override
+    public ServletRequest getRequest(ServletResponse response) {
+        return responses.get(response);
+    }
+
+    /**
+     * Get the default request character encoding.
+     *
+     * @return the default request character encoding.
+     */
+    @Override
+    public String getRequestCharacterEncoding() {
+        return requestCharacterEncoding;
+    }
+
+    /**
+     * Get the default response character encoding.
+     *
+     * @return the default response character encoding.
+     */
+    @Override
+    public String getResponseCharacterEncoding() {
+        return responseCharacterEncoding;
+    }
+
+    /**
+     * Get the resource.
+     *
+     * @param location the location.
+     * @return the URL.
+     * @throws MalformedURLException when the URL is malformed.
+     */
+    @Override
+    public URL getResource(String location) throws MalformedURLException {
+        if (!location.startsWith("/")) {
+            throw new MalformedURLException("Location " + location + " must start with a /");
+        }
+
+        return resourceManager.getResource(location);
+    }
+
+    /**
+     * Get the resource as a stream.
+     *
+     * @param location the resource location
+     * @return the input stream, or null if not found.
+     */
+    @Override
+    public InputStream getResourceAsStream(String location) {
+        return resourceManager.getResourceAsStream(location);
+    }
+
+    /**
+     * Returns the file path or the first nested folder
+     *
+     * @apiNote
+     *  <p><b>Examples.</b>
+     * <pre>{@code
+     *  getFileOrFirstFolder("/rootFolder", "/rootFolder/file.html").equals("/rootFolder/file.html")
+     * }</pre>
+     *
+     * <pre>{@code
+     *  getFileOrFirstFolder("/rootFolder", "/rootFolder/nestedFolder/file.html").equals("/rootFolder/nestedFolder/")
+     * }</pre>
+     *
+     * <pre>{@code
+     *  getFileOrFirstFolder("/rootFolder/nestedFolder", "/rootFolder/nestedFolder/file.html")
+     *      .equals("/rootFolder/nestedFolder/file.html")
+     * }</pre>
+     *
+     * @param path the path of root folder
+     * @param resource the resource that is a file directory or file
+     * @return the file path or the first nested folder
+     */
+    private String getFileOrFirstFolder(String path, String resource){
+        String normalizedPath = path.endsWith("/") ? path : path + "/";
+        String[] split = resource.replace(normalizedPath, "/").split("/");
+
+        // It's a directory
+        if (split.length > 2) {
+            return normalizedPath + split[1] + "/";
+        }
+
+        // It's a file
+        return normalizedPath + split[1];
+    }
+
+    /**
+     * Returns a directory-like listing of all the paths to resources
+     * within the web application whose longest sub-path matches the supplied path argument.
+     * @param path the partial path used to match the resources
+     * @return a Set containing the directory listing, or null if there are no resources in the web application
+     * whose path begins with the supplied path.
+     */
+    private Set<String> getResourcePathsImpl(String path) {
+        Set<String> collect =
+            resourceManager.getAllLocations()
+                           .filter(resource -> resource.startsWith(path))
+                           .filter(not(isEqual(path)))
+                           .map(resource -> getFileOrFirstFolder(path, resource))
+                           .collect(toSet());
+
+        if (collect.isEmpty()) {
+            return null;
+        }
+
+        return collect;
+    }
+    /**
+     * Get the resource paths.
+     *
+     * @param path the path.
+     * @return the resource paths.
+     */
+    @Override
+    public Set<String> getResourcePaths(String path) {
+        if (path == null) {
+            return null;
+        }
+
+        if (!path.startsWith("/")) {
+            throw new IllegalArgumentException("Path must start with /");
+        }
+
+        return getResourcePathsImpl(path);
+    }
+
+    /**
+     * Get the response.
+     *
+     * @param request the request.
+     * @return the response.
+     */
+    @Override
+    public ServletResponse getResponse(ServletRequest request) {
+        return (ServletResponse) request.getAttribute("piranha.response");
+    }
+
+    /**
+     * Get the security manager.
+     *
+     * @return the security manager.
+     */
+    @Override
+    public SecurityManager getSecurityManager() {
+        return securityManager;
+    }
+
+    @Override
+    public AnnotationManager getAnnotationManager() {
+        return annotationManager;
+    }
+
+    @Override
+    public void setAnnotationManager(AnnotationManager annotationManager) {
+        this.annotationManager = annotationManager;
+    }
+
+    /**
+     * Get the server info.
+     *
+     * @return the server info.
+     */
+    @Override
+    public String getServerInfo() {
+        return "";
+    }
+
+    /**
+     * Get the servlet.
+     *
+     * @param name the name of the servlet.
+     * @return null
+     * @throws ServletException when a Servlet error occurs.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public Servlet getServlet(String name) throws ServletException {
+        throw new UnsupportedOperationException("ServletContext.getServlet(String) is no longer supported");
+    }
+
+    /**
+     * Get the servlet context name (aka display-name).
+     *
+     * @return the servlet context name.
+     */
+    @Override
+    public String getServletContextName() {
+        return servletContextName;
+    }
+
+    /**
+     * Get the servlet names.
+     *
+     * @return the servlet names.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public Enumeration<String> getServletNames() {
+        throw new UnsupportedOperationException("ServletContext.getServletNames() is no longer supported");
+    }
+
+    /**
+     * Get the servlet registration.
+     *
+     * @param servletName the servlet name.
+     * @return the servlet registration, or null if not found.
+     */
+    @Override
+    public ServletRegistration getServletRegistration(String servletName) {
+        checkTainted();
+        return servletEnvironments.get(servletName);
+    }
+
+    /**
+     * Get the servlet registrations.
+     *
+     * @return the servlet registrations.
+     */
+    @Override
+    public Map<String, ? extends ServletRegistration> getServletRegistrations() {
+        checkTainted();
+        return unmodifiableMap(servletEnvironments);
+    }
+
+    /**
+     * Get the servlets.
+     *
+     * @return the servlets (empty enumeration).
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public Enumeration<Servlet> getServlets() {
+        throw new UnsupportedOperationException("ServletContext.getServlets() is no longer supported");
+    }
+
+    /**
+     * Get the session cookie config.
+     *
+     * @return the session cookie config.
+     */
+    @Override
+    public SessionCookieConfig getSessionCookieConfig() {
+        checkTainted();
+        return httpSessionManager.getSessionCookieConfig();
+    }
+
+    /**
+     * Get the default session timeout.
+     *
+     * @return the default session timeout.
+     */
+    @Override
+    public int getSessionTimeout() {
+        return httpSessionManager.getSessionTimeout();
+    }
+
+    /**
+     * Get the session manager.
+     *
+     * @return the session manager.
+     */
+    @Override
+    public HttpSessionManager getHttpSessionManager() {
+        return httpSessionManager;
+    }
+
+    /**
+     * Get the virtual server name.
+     *
+     * @return the virtual server name.
+     */
+    @Override
+    public String getVirtualServerName() {
+        return virtualServerName;
+    }
+
+    /**
+     * Get the welcome file manager.
+     *
+     * @return the welcome file manager.
+     */
+    @Override
+    public WelcomeFileManager getWelcomeFileManager() {
+        return welcomeFileManager;
+    }
+
+    /**
+     * Initialize the web application.
+     */
+    @Override
+    public void initialize() {
+        LOGGER.log(FINE, "Initializing web application at {0}", contextPath);
+        verifyState(SETUP, "Unable to initialize web application");
+        initializeInitializers();
+        initializeFilters();
+        initializeServlets();
+        initializeFinish();
+    }
+
+    /**
+     * Finish the initialization.
+     */
+    @Override
+    public void initializeDeclaredFinish() {
+        if (status == SETUP) {
+            status = INITIALIZED_DECLARED;
+            LOGGER.log(FINE, "Initialized declared items for web application at {0}", contextPath);
+        }
+        if (status == ERROR) {
+            LOGGER.log(WARNING, "An error occurred initializing webapplication at {0}", contextPath);
+        }
+    }
+
+    /**
+     * Finish the initialization.
+     */
+    @Override
+    public void initializeFinish() {
+        if (status == SETUP || status == INITIALIZED_DECLARED) {
+            status = INITIALIZED;
+            LOGGER.log(FINE, "Initialized web application at {0}", contextPath);
+        }
+        if (status == ERROR) {
+            LOGGER.log(WARNING, () -> "An error occurred initializing webapplication at " + contextPath);
+        }
+    }
+
+    /**
+     * Initialize the filters.
+     */
+    @Override
+    public void initializeFilters() {
+        if (status == SETUP || status == INITIALIZED_DECLARED) {
+            List<String> filterNames = new ArrayList<>(filters.keySet());
+            filterNames.stream().map(filters::get).forEach(environment -> {
+                try {
+                    environment.initialize();
+                    environment.getFilter().init(environment);
+                } catch (Throwable t) {
+                    LOGGER.log(WARNING, t, () -> "Unable to initialize filter: " + environment.getFilterName());
+                    environment.setStatus(UNAVAILABLE);
+                }
+            });
+        }
+    }
+
+    /**
+     * Initialize the servlet container initializers.
+     */
+    @Override
+    public void initializeInitializers() {
+        boolean error = false;
+        for (ServletContainerInitializer initializer : initializers) {
+            try {
+                HandlesTypes annotation = initializer.getClass().getAnnotation(HandlesTypes.class);
+                Set<Class<?>> classes = Collections.emptySet();
+                if (annotation != null) {
+                    Class<?>[] value = annotation.value();
+                    // Get instances
+                    Stream<Class<?>> instances = annotationManager.getInstances(value).stream();
+
+                    // Get classes by target type
+                    List<AnnotationManager.AnnotationInfo<?>> annotations = annotationManager.getAnnotations(value);
+                    Stream<Class<?>> classStream = annotations.stream().map(AnnotationManager.AnnotationInfo::getTargetType);
+
+                    classes = Stream.concat(instances, classStream).collect(Collectors.toUnmodifiableSet());
+                }
+                try {
+                    source = initializer;
+                    initializer.onStartup(classes, this);
+                }  finally {
+                    source = null;
+                }
+            } catch (Throwable t) {
+                LOGGER.log(WARNING, t,  () -> "Initializer " + initializer.getClass().getName() + " failing onStartup");
+                error = true;
+            }
+        }
+
+        if (!error) {
+            List<ServletContextListener> listeners = new ArrayList<>(declaredContextListeners);
+            listeners.stream().forEach(listener -> {
+                try {
+                    source = listener;
+                    listener.contextInitialized(new ServletContextEvent(this));
+                } finally {
+                    source = null;
+                }
+            });
+
+            try {
+                tainted = true;
+                listeners = new ArrayList<>(contextListeners);
+                listeners.stream().forEach(listener -> {
+                    source = listener;
+                    listener.contextInitialized(new ServletContextEvent(this));
+                });
+            } finally {
+                tainted = false;
+                source = null;
+            }
+        } else {
+            status = ERROR;
+        }
+    }
+
+    /**
+     * Initialize the servlets.
+     */
+    @Override
+    public void initializeServlets() {
+        if (status == SETUP || status == INITIALIZED_DECLARED) {
+            List<String> servletsToBeRemoved = new ArrayList<>();
+            List<String> servletNames = new ArrayList<>(servletEnvironments.keySet());
+
+            servletNames.stream().map(servletEnvironments::get).forEach(environment -> {
+                initializeServlet(environment);
+                if (isPermanentlyUnavailable(environment)) {
+                    servletsToBeRemoved.add(environment.getServletName());
+                }
+            });
+
+            for (String servletName : servletsToBeRemoved) {
+                // Servlet:SPEC:11 - If a permanent unavailability is indicated by the UnavailableException, the servlet container must
+                // remove the servlet from service ... and release the servlet instance.
+                servletEnvironments.remove(servletName);
+            }
+
+        }
+    }
+
+    /**
+     * Is the web application distributable.
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isDistributable() {
+        return distributable;
+    }
+
+    /**
+     * Is the web application initialized.
+     * 
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isInitialized() {
+        return status >= INITIALIZED && status < ERROR;
+    }
+    
+    /**
+     * Initialize the servlet.
+     *
+     * @param environment the default servlet environment.
+     */
+    @SuppressWarnings("unchecked")
+    private void initializeServlet(DefaultServletEnvironment environment) {
+        try {
+            LOGGER.log(FINE, "Initializing servlet: {0}", environment.servletName);
+            if (environment.getServlet() == null) {
+                Class<? extends Servlet> clazz = environment.getServletClass();
+                if (clazz == null) {
+                    ClassLoader loader = getClassLoader();
+                    if (loader == null) {
+                        loader = getClass().getClassLoader();
+                    }
+                    if (loader == null) {
+                        loader = ClassLoader.getSystemClassLoader();
+                    }
+                    clazz = (Class<? extends Servlet>) loader.loadClass(environment.getClassName());
+                }
+                environment.setServlet(createServlet(clazz));
+            }
+            environment.getServlet().init(environment);
+            LOGGER.log(FINE, "Initialized servlet: {0}", environment.servletName);
+        } catch (Throwable t) {
+            LOGGER.log(WARNING, t, () -> "Unable to initialize servlet: " + environment.className);
+
+            environment.setStatus(ServletEnvironment.UNAVAILABLE);
+            environment.setUnavailableException(t);
+
+            // Servlet:SPEC:11 - If a permanent unavailability is indicated by the UnavailableException, the servlet container must ... call its destroy method
+            if (isPermanentlyUnavailable(environment) && environment.getServlet() != null) {
+                try {
+                    environment.getServlet().destroy();
+                } catch (Throwable t2) {
+                    t.addSuppressed(t2);
+                }
+            }
+
+            environment.setServlet(null);
+        }
+    }
+
+    /**
+     * Link the request and response.
+     *
+     * @param request the request.
+     * @param response the response.
+     */
+    @Override
+    public void linkRequestAndResponse(ServletRequest request, ServletResponse response) {
+        request.setAttribute("piranha.response", response);
+        responses.put(response, request);
+    }
+
+    /**
+     * Log a message.
+     *
+     * @param exception the exception.
+     * @param message the message.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public void log(Exception exception, String message) {
+        throw new UnsupportedOperationException("ServletContext.log(Exception, String) is no longer supported");
+    }
+
+    /**
+     * Log a message.
+     *
+     * @param message the message.
+     * @param throwable the throwable.
+     */
+    @Override
+    public void log(String message, Throwable throwable) {
+        loggingManager.log(message, throwable);
+    }
+
+    /**
+     * Log a message.
+     *
+     * @param message the message.
+     */
+    @Override
+    public void log(String message) {
+        log(message, null);
+    }
+
+    /**
+     * Remove the attribute with the given name.
+     *
+     * @param name the name.
+     */
+    @Override
+    public void removeAttribute(String name) {
+        attributeRemoved(name, attributes.remove(name));
+    }
+
+    /**
+     * Service the request using this web application.
+     *
+     * @param request the servlet request.
+     * @param response the servlet response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
+        verifyState(SERVICING, "Unable to service request");
+        verifyRequestResponseTypes(request, response);
+
+        linkRequestAndResponse(request, response);
+        requestInitialized(request);
+
+        DefaultWebApplicationRequest webappRequest = (DefaultWebApplicationRequest) request;
+        DefaultWebApplicationResponse httpResponse = (DefaultWebApplicationResponse) response;
+
+        // Obtain a reference to the target servlet invocation, which includes the Servlet itself and/or Filters, as well as mapping data
+        DefaultServletInvocation servletInvocation = invocationFinder.findServletInvocationByPath(webappRequest.getServletPath(), webappRequest.getPathInfo());
+
+        // Dispatch using the REQUEST dispatch type. This will invoke the Servlet and/or Filters if present and available.
+        getInvocationDispatcher(servletInvocation).request(webappRequest, httpResponse);
+
+        requestDestroyed(request);
+        unlinkRequestAndResponse(request, response);
+    }
+
+    /**
+     * Set the attribute.
+     *
+     * @param name the attribute name.
+     * @param value the attribute value.
+     */
+    @Override
+    public void setAttribute(String name, Object value) {
+        Objects.requireNonNull(name);
+        if (value != null) {
+            boolean added = true;
+            if (attributes.containsKey(name)) {
+                added = false;
+            }
+            Object previousValue = attributes.put(name, value);
+            if (added) {
+                attributeAdded(name, value);
+            } else {
+                attributeReplaced(name, previousValue);
+            }
+        } else {
+            removeAttribute(name);
+        }
+    }
+
+    /**
+     * Set the class-loader.
+     *
+     * @param classLoader the class loader.
+     */
+    @Override
+    public void setClassLoader(ClassLoader classLoader) {
+        this.classLoader = classLoader;
+    }
+
+    /**
+     * Set the context path.
+     *
+     * @param contextPath the context path.
+     */
+    @Override
+    public void setContextPath(String contextPath) {
+        LOGGER.log(FINE, "Setting context path to: {0}", contextPath);
+        this.contextPath = contextPath;
+    }
+
+    /**
+     * @see WebApplication#setDefaultServlet(javax.servlet.Servlet)
+     */
+    @Override
+    public void setDefaultServlet(Servlet defaultServlet) {
+        this.defaultServlet = defaultServlet;
+    }
+
+    /**
+     * Set if we are denying uncovered HTTP methods.
+     *
+     * @param denyUncoveredHttpMethods the boolean value.
+     */
+    @Override
+    public void setDenyUncoveredHttpMethods(boolean denyUncoveredHttpMethods) {
+        securityManager.setDenyUncoveredHttpMethods(denyUncoveredHttpMethods);
+    }
+
+    /**
+     * Set if the web application is distributable.
+     *
+     * @param distributable the boolean value.
+     */
+    @Override
+    public void setDistributable(boolean distributable) {
+        this.distributable = distributable;
+    }
+
+    /**
+     * Set the HTTP session manager.
+     *
+     * @param httpSessionManager the HTTP session manager.
+     */
+    @Override
+    public void setHttpSessionManager(HttpSessionManager httpSessionManager) {
+        this.httpSessionManager = httpSessionManager;
+    }
+
+    @Override
+    public HttpRequestManager getHttpRequestManager() {
+        return httpRequestManager;
+    }
+
+    @Override
+    public void setHttpRequestManager(HttpRequestManager httpRequestManager) {
+        this.httpRequestManager = httpRequestManager;
+    }
+
+    /**
+     * Set the init parameter.
+     *
+     * @param name the name.
+     * @param value the value.
+     * @return true if it could be set, false otherwise.
+     */
+    @Override
+    public boolean setInitParameter(String name, String value) {
+        requireNonNull(name);
+
+        checkTainted();
+
+        if (status != SETUP && status != INITIALIZED_DECLARED) {
+            throw new IllegalStateException("Cannot set init parameter once web application is initialized");
+        }
+
+        boolean result = true;
+        if (initParameters.containsKey(name)) {
+            result = false;
+        } else {
+            initParameters.put(name, value);
+        }
+        return result;
+    }
+
+    /**
+     * Set the JSP manager.
+     *
+     * @param jspManager the JSP manager.
+     */
+    @Override
+    public void setJspManager(JspManager jspManager) {
+        this.jspManager = jspManager;
+    }
+
+    /**
+     * Set the logging manager.
+     *
+     * @param loggingManager the logging manager.
+     */
+    @Override
+    public void setLoggingManager(LoggingManager loggingManager) {
+        this.loggingManager = loggingManager;
+    }
+
+    /**
+     * Set the mimeType manager.
+     *
+     * @param mimeTypeManager the mimeType manager.
+     */
+    @Override
+    public void setMimeTypeManager(MimeTypeManager mimeTypeManager) {
+        this.mimeTypeManager = mimeTypeManager;
+    }
+
+    /**
+     * Set the multi part manager.
+     *
+     * @param multiPartManager the multi part manager.
+     */
+    @Override
+    public void setMultiPartManager(MultiPartManager multiPartManager) {
+        this.multiPartManager = multiPartManager;
+    }
+
+    /**
+     * Set the object instance manager.
+     *
+     * @param objectInstanceManager the object instance manager.
+     */
+    @Override
+    public void setObjectInstanceManager(ObjectInstanceManager objectInstanceManager) {
+        this.objectInstanceManager = objectInstanceManager;
+    }
+
+    /**
+     * Set the default request character encoding.
+     *
+     * @param requestCharacterEncoding the default request character encoding.
+     */
+    @Override
+    public void setRequestCharacterEncoding(String requestCharacterEncoding) {
+        this.requestCharacterEncoding = requestCharacterEncoding;
+    }
+
+    /**
+     * Set the resource manager.
+     *
+     * @param resourceManager the resource manager.
+     */
+    @Override
+    public void setResourceManager(ResourceManager resourceManager) {
+        this.resourceManager = resourceManager;
+    }
+
+    /**
+     * Set the default response character encoding.
+     *
+     * @param responseCharacterEncoding the default response character encoding.
+     */
+    @Override
+    public void setResponseCharacterEncoding(String responseCharacterEncoding) {
+        this.responseCharacterEncoding = responseCharacterEncoding;
+    }
+
+    /**
+     * Set the security manager.
+     *
+     * @param securityManager the security manager.
+     */
+    @Override
+    public void setSecurityManager(SecurityManager securityManager) {
+        this.securityManager = securityManager;
+    }
+
+    /**
+     * Set the servlet context name.
+     *
+     * @param servletContextName the servlet context name.
+     */
+    @Override
+    public void setServletContextName(String servletContextName) {
+        this.servletContextName = servletContextName;
+    }
+
+    /**
+     * Set the session tracking modes.
+     *
+     * @param sessionTrackingModes the session tracking modes.
+     */
+    @Override
+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {
+        checkTainted();
+
+        checkServicing();
+
+        httpSessionManager.setSessionTrackingModes(sessionTrackingModes);
+    }
+
+    /**
+     * Set the default session timeout.
+     *
+     * @param sessionTimeout the default session timeout.
+     */
+    @Override
+    public void setSessionTimeout(int sessionTimeout) {
+        if (status != SETUP && status != INITIALIZED_DECLARED) {
+            throw new IllegalStateException("Illegal to set session timeout because state is not SETUP");
+        }
+        httpSessionManager.setSessionTimeout(sessionTimeout);
+    }
+
+    /**
+     * Set the virtual server name.
+     *
+     * @param virtualServerName the virtual server name.
+     */
+    public void setVirtualServerName(String virtualServerName) {
+        this.virtualServerName = virtualServerName;
+    }
+
+    /**
+     * Set the web application request mapper.
+     *
+     * @param webApplicationRequestMapper the web application request mapper.
+     */
+    @Override
+    public void setWebApplicationRequestMapper(WebApplicationRequestMapper webApplicationRequestMapper) {
+        this.webApplicationRequestMapper = webApplicationRequestMapper;
+    }
+
+    /**
+     * Set the welcome file manager.
+     *
+     * @param welcomeFileManager the welcome file manager.
+     */
+    @Override
+    public void setWelcomeFileManager(WelcomeFileManager welcomeFileManager) {
+        this.welcomeFileManager = welcomeFileManager;
+    }
+
+    /**
+     * Start servicing.
+     */
+    @Override
+    public void start() {
+        LOGGER.log(FINE, "Starting web application at {0}", contextPath);
+        verifyState(INITIALIZED, "Unable to start servicing");
+        status = SERVICING;
+        LOGGER.log(FINE, "Started web application at {0}", contextPath);
+    }
+
+    /**
+     * Stop servicing.
+     */
+    @Override
+    public void stop() {
+        LOGGER.log(FINE, "Stopping web application at {0}", contextPath);
+        verifyState(SERVICING, "Unable to stop servicing");
+        status = INITIALIZED;
+        LOGGER.log(FINE, "Stopped web application at {0}", contextPath);
+    }
+
+    /**
+     * Unlink the request and response.
+     *
+     * @param request the request.
+     * @param response the response.
+     */
+    @Override
+    public void unlinkRequestAndResponse(ServletRequest request, ServletResponse response) {
+        request.removeAttribute("piranha.response");
+        responses.remove(response);
+    }
+
+    @Override
+    public LocaleEncodingManager getLocaleEncodingManager() {
+        return localeEncodingManager;
+    }
+
+    @Override
+    public void setLocaleEncodingManager(LocaleEncodingManager localeEncodingManager) {
+        this.localeEncodingManager = localeEncodingManager;
+    }
+
+    /**
+     * Get the request dispatcher.
+     *
+     * @param path the path.
+     * @return the request dispatcher.
+     */
+    @Override
+    public DefaultServletRequestDispatcher getRequestDispatcher(String path) {
+        try {
+            DefaultServletInvocation servletInvocation = invocationFinder.findServletInvocationByPath(null, path, null);
+            if (servletInvocation == null) {
+                return null;
+            }
+
+            return getInvocationDispatcher(servletInvocation);
+        } catch (IOException | ServletException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    /**
+     * Get the name request dispatcher.
+     *
+     * @param name the name.
+     * @return the request dispatcher.
+     */
+    @Override
+    public RequestDispatcher getNamedDispatcher(String name) {
+        DefaultServletInvocation servletInvocation = invocationFinder.findServletInvocationByName(name);
+        if (servletInvocation == null) {
+            return null;
+        }
+
+        return getInvocationDispatcher(servletInvocation);
+    }
+
+    /**
+     * Get the async manager.
+     *
+     * @return the async manager.
+     */
+    @Override
+    public AsyncManager getAsyncManager() {
+        return asyncManager;
+    }
+
+
+
+    // ### Private methods
+
+
+
+    /**
+     * Get the name request dispatcher.
+     *
+     * @param servletInvocation the servlet invocation.
+     * @return the request dispatcher.
+     */
+    private DefaultServletRequestDispatcher getInvocationDispatcher(DefaultServletInvocation servletInvocation) {
+        return new DefaultServletRequestDispatcher(servletInvocation, this);
+    }
+
+    private void verifyRequestResponseTypes(ServletRequest request, ServletResponse response) throws ServletException {
+        if (!(request instanceof DefaultWebApplicationRequest) || !(response instanceof DefaultWebApplicationResponse)) {
+            throw new ServletException("Invalid request or response");
+        }
+    }
+
+    /**
+     * Verify the web application state.
+     *
+     * @param desiredStatus the desired status.
+     * @param message the message.
+     */
+    protected void verifyState(int desiredStatus, String message) {
+        if (status != desiredStatus) {
+            throw new RuntimeException(message);
+        }
+    }
+
+    /**
+     * Fire the request initialized event
+     *
+     * @param request the request
+     */
+    private void requestInitialized(ServletRequest request) {
+        if (!requestListeners.isEmpty()) {
+            requestListeners.stream().forEach(servletRequestListener -> servletRequestListener.requestInitialized(new ServletRequestEvent(this, request)));
+        }
+    }
+
+    /**
+     * Fire the request destroyed event
+     *
+     * @param request the request
+     */
+    private void requestDestroyed(ServletRequest request) {
+        if (!requestListeners.isEmpty()) {
+            requestListeners.stream().forEach(servletRequestListener -> servletRequestListener.requestDestroyed(new ServletRequestEvent(this, request)));
+        }
+    }
+
+    /**
+     * Attribute added.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    private void attributeAdded(String name, Object value) {
+        contextAttributeListeners.stream().forEach(listener -> listener.attributeAdded(new ServletContextAttributeEvent(this, name, value)));
+    }
+
+    /**
+     * Attributed removed.
+     *
+     * @param name the name.
+     * @param previousValue the previous value.
+     */
+    private void attributeRemoved(String name, Object previousValue) {
+        contextAttributeListeners.stream().forEach(listener -> listener.attributeRemoved(new ServletContextAttributeEvent(this, name, previousValue)));
+    }
+
+    /**
+     * Attribute removed.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    private void attributeReplaced(String name, Object value) {
+        contextAttributeListeners.stream().forEach(listener -> listener.attributeReplaced(new ServletContextAttributeEvent(this, name, value)));
+    }
+
+    private boolean isPermanentlyUnavailable(DefaultServletEnvironment environment) {
+        return
+            environment.getUnavailableException() instanceof UnavailableException && ((UnavailableException)
+            environment.getUnavailableException()).isPermanent();
+    }
+
+    private void checkTainted() {
+        if (tainted) {
+            throw new UnsupportedOperationException("ServletContext is in tainted mode (as required by spec).");
+        }
+    }
+
+    private void checkServicing() {
+        if (status == SERVICING) {
+            throw new IllegalStateException("Cannot call this after web application has initialized");
+        }
+    }
+
+    private boolean isEmpty(String string) {
+        return string == null || string.isEmpty();
+    }
+
+    @Override
+    public NamingManager getNamingManager() {
+        return namingManager;
+    }
+
+    @Override
+    public PolicyManager getPolicyManager() {
+        return policyManager;
+    }
+
+    @Override
+    public void setNamingManager(NamingManager namingManager) {
+        this.namingManager = namingManager;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationClassLoader.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationClassLoader.java
new file mode 100644
index 00000000..58e198d3
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationClassLoader.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.io.File;
+
+import cloud.piranha.resource.DefaultResourceManager;
+import cloud.piranha.resource.DefaultResourceManagerClassLoader;
+import cloud.piranha.resource.DirectoryResource;
+import cloud.piranha.resource.JarResource;
+import cloud.piranha.resource.api.ResourceManager;
+import cloud.piranha.servlet4.webapp.WebApplicationClassLoader;
+
+/**
+ * The default WebApplicationClassLoader.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWebApplicationClassLoader extends DefaultResourceManagerClassLoader implements WebApplicationClassLoader {
+
+    /**
+     * Constructor.
+     */
+    public DefaultWebApplicationClassLoader() {
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param baseDirectory the base directory.
+     */
+    public DefaultWebApplicationClassLoader(File baseDirectory) {
+        ResourceManager resourceManager = new DefaultResourceManager();
+        File classesDirectory = new File(baseDirectory, "WEB-INF/classes");
+        if (classesDirectory.exists()) {
+            resourceManager.addResource(new DirectoryResource(classesDirectory));
+        }
+
+        File libDirectory = new File(baseDirectory, "WEB-INF/lib");
+        if (libDirectory.exists()) {
+            File[] jarFiles = libDirectory.listFiles();
+            if (jarFiles != null) {
+                for (File jarFile : jarFiles) {
+                    resourceManager.addResource(new JarResource(jarFile));
+                }
+            }
+        }
+
+        setResourceManager(resourceManager);
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationExtensionContext.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationExtensionContext.java
new file mode 100644
index 00000000..74a4b639
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationExtensionContext.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationExtension;
+import cloud.piranha.servlet4.webapp.WebApplicationExtensionContext;
+
+/**
+ * The default web application extension context.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWebApplicationExtensionContext implements WebApplicationExtensionContext {
+
+    /**
+     * Stores the extensions.
+     */
+    private final ArrayList<WebApplicationExtension> extensions;
+
+    /**
+     * Stores the extension classes.
+     */
+    private final ArrayList<Class<? extends WebApplicationExtension>> extensionClasses;
+
+    /**
+     * Constructor.
+     */
+    public DefaultWebApplicationExtensionContext() {
+        extensions = new ArrayList<>();
+        extensionClasses = new ArrayList<>();
+    }
+
+    /**
+     * Add the extension.
+     *
+     * @param extension the extension.
+     */
+    @Override
+    public void add(Class<? extends WebApplicationExtension> extension) {
+        try {
+            WebApplicationExtension instance = extension.getDeclaredConstructor().newInstance();
+            instance.extend(this);
+            extensions.add(instance);
+            extensionClasses.add(extension);
+        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    /**
+     * Add the extension.
+     *
+     * @param extension the extension.
+     */
+    @Override
+    public void add(WebApplicationExtension extension) {
+        extension.extend(this);
+        extensions.add(extension);
+        extensionClasses.add(extension.getClass());
+    }
+
+    /**
+     * Configure the web application.
+     *
+     * @param webApplication the web application.
+     */
+    public void configure(WebApplication webApplication) {
+        extensions.forEach(extension -> extension.configure(webApplication));
+    }
+
+    /**
+     * Remove the extension.
+     *
+     * @param extension the extension.
+     */
+    @Override
+    public void remove(Class<? extends WebApplicationExtension> extension) {
+        if (extensionClasses.contains(extension)) {
+            int index = extensionClasses.indexOf(extension);
+            extensionClasses.remove(index);
+            extensions.remove(index);
+        }
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequest.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequest.java
new file mode 100644
index 00000000..05a90ae5
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequest.java
@@ -0,0 +1,1753 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static cloud.piranha.servlet4.impl.DefaultServletRequestDispatcher.PREVIOUS_REQUEST;
+import static java.util.Objects.requireNonNull;
+import static javax.servlet.DispatcherType.INCLUDE;
+import static javax.servlet.RequestDispatcher.INCLUDE_QUERY_STRING;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
+import java.lang.reflect.InvocationTargetException;
+import java.net.URLDecoder;
+import java.nio.charset.Charset;
+import java.nio.charset.IllegalCharsetNameException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.Principal;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import javax.servlet.AsyncContext;
+import javax.servlet.DispatcherType;
+import javax.servlet.ReadListener;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestWrapper;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpUpgradeHandler;
+import javax.servlet.http.Part;
+
+import cloud.piranha.servlet4.webapp.AttributeManager;
+import cloud.piranha.servlet4.webapp.HttpHeaderManager;
+import cloud.piranha.servlet4.webapp.HttpSessionManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationRequest;
+
+/**
+ * The default WebApplicationRequest.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWebApplicationRequest extends ServletInputStream implements WebApplicationRequest {
+
+    /**
+     * Stores the auth type.
+     */
+    protected String authType;
+
+    /**
+     * Stores the async context.
+     */
+    protected AsyncContext asyncContext;
+
+    /**
+     * Stores if async is started.
+     */
+    protected boolean asyncStarted;
+
+    /**
+     * Stores if async is supported.
+     */
+    protected boolean asyncSupported;
+
+    /**
+     * Stores the attribute manager.
+     */
+    protected AttributeManager attributeManager;
+
+    /**
+     * Stores the character encoding.
+     */
+    protected String characterEncoding;
+
+    /**
+     * Stores the content length.
+     */
+    protected long contentLength;
+
+    /**
+     * Stores the content type.
+     */
+    protected String contentType;
+
+    /**
+     * Stores the context path.
+     */
+    protected String contextPath;
+
+    /**
+     * Stores the cookies.
+     */
+    protected Cookie[] cookies;
+
+    /**
+     * Stores the current session id.
+     */
+    protected String currentSessionId;
+
+    /**
+     * Stores the dispatcher type.
+     */
+    protected DispatcherType dispatcherType;
+
+    /**
+     * Stores the gotInputStream flag.
+     */
+    protected boolean gotInputStream;
+
+    /**
+     * Stores the gotReader flag.
+     */
+    protected boolean gotReader;
+
+    /**
+     * Stores the header manager.
+     */
+    protected HttpHeaderManager headerManager;
+
+    /**
+     * Stores the input stream.
+     */
+    protected InputStream inputStream;
+
+    /**
+     * Stores the local address.
+     */
+    protected String localAddress;
+
+    /**
+     * Stores the local name.
+     */
+    protected String localName;
+
+    /**
+     * Stores the local port.
+     */
+    protected int localPort;
+
+    /**
+     * Stores the method.
+     */
+    protected String method;
+
+    /**
+     * Stores the parameters.
+     */
+    protected HashMap<String, String[]> parameters;
+
+    /**
+     * Stores the parameters parsed flag.
+     */
+    protected boolean parametersParsed;
+
+    /**
+     * Stores the path info.
+     */
+    protected String pathInfo;
+
+    /**
+     * Stores the protocol.
+     */
+    protected String protocol;
+
+    /**
+     * Stores the query string.
+     */
+    protected String queryString;
+
+    /**
+     * Stores the reader.
+     */
+    protected BufferedReader reader;
+
+    /**
+     * Stores the remote address.
+     */
+    protected String remoteAddr;
+
+    /**
+     * Stores the remote host.
+     */
+    protected String remoteHost;
+
+    /**
+     * Stores the remote port.
+     */
+    protected int remotePort;
+
+    /**
+     * Stores the requested session id.
+     */
+    protected String requestedSessionId;
+
+    /**
+     * Stores the requested session id from cookie flag.
+     */
+    protected boolean requestedSessionIdFromCookie;
+
+    /**
+     * Stores the requested session id from url flag.
+     */
+    protected boolean requestedSessionIdFromURL;
+
+    /**
+     * Stores the scheme.
+     */
+    protected String scheme;
+
+    /**
+     * Stores the server name.
+     */
+    protected String serverName;
+
+    /**
+     * Stores the server port.
+     */
+    protected int serverPort;
+
+    /**
+     * Stores the servlet path.
+     */
+    protected String servletPath;
+
+    /**
+     * Stores the upgraded flag.
+     */
+    protected boolean upgraded;
+
+    /**
+     * Stores the upgrade handler.
+     */
+    protected HttpUpgradeHandler upgradeHandler;
+
+    /**
+     * Stores the user principal.
+     */
+    protected Principal userPrincipal;
+
+    /**
+     * Stores the web application
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Stores the finished flag.
+     */
+    private boolean finished;
+
+    /**
+     * The number of items read from the input stream
+     */
+    private int index;
+
+    /**
+     * Stores the read listener.
+     */
+    private ReadListener readListener;
+
+    /**
+     * Constructor.
+     */
+    public DefaultWebApplicationRequest() {
+        this.authType = null;
+        this.asyncStarted = false;
+        this.asyncSupported = false;
+        this.attributeManager = new DefaultAttributeManager();
+        this.characterEncoding = null;
+        this.contentLength = -1;
+        this.contentType = null;
+        this.contextPath = "";
+        this.cookies = null;
+        this.dispatcherType = DispatcherType.REQUEST;
+        this.headerManager = new DefaultHttpHeaderManager();
+        this.headerManager.setHeader("Accept", "*/*");
+        this.inputStream = new ByteArrayInputStream(new byte[0]);
+        this.method = "GET";
+        this.protocol = "HTTP/1.1";
+        this.scheme = "http";
+        this.serverName = "localhost";
+        this.serverPort = 80;
+        this.servletPath = "";
+        this.parameters = new HashMap<>();
+        this.upgraded = false;
+    }
+
+    /**
+     * Authenticate.
+     *
+     * @param response the HTTP servlet response.
+     * @return true if authenticated, false otherwise.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {
+        return webApplication.getSecurityManager().authenticate(this, response);
+    }
+
+    /**
+     * Change the session id.
+     *
+     * @return the changed session id.
+     */
+    @Override
+    public String changeSessionId() {
+        return webApplication.getHttpSessionManager().changeSessionId(this);
+    }
+
+    /**
+     * Get the async context.
+     *
+     * @return the async context.
+     */
+    @Override
+    public AsyncContext getAsyncContext() {
+        if (asyncContext == null) {
+            throw new IllegalStateException("Async was not started");
+        }
+        return asyncContext;
+    }
+
+    /**
+     * Get the attribute.
+     *
+     * @param name the attribute name.
+     * @return the value.
+     */
+    @Override
+    public Object getAttribute(String name) {
+        return attributeManager.getAttribute(name);
+    }
+
+    /**
+     * Get attribute names.
+     *
+     * @return the attribute names.
+     */
+    @Override
+    public Enumeration<String> getAttributeNames() {
+        return attributeManager.getAttributeNames();
+    }
+
+    /**
+     * Get the auth type.
+     *
+     * @return the auth type.
+     */
+    @Override
+    public String getAuthType() {
+        return authType;
+    }
+
+    /**
+     * Get the character encoding.
+     *
+     * @return the character encoding.
+     */
+    @Override
+    public String getCharacterEncoding() {
+        return characterEncoding;
+    }
+
+    /**
+     * Get the content length.
+     *
+     * @return the content length.
+     */
+    @Override
+    public int getContentLength() {
+        return (int) contentLength;
+    }
+
+    /**
+     * Get the content length.
+     *
+     * @return the content length.
+     */
+    @Override
+    public long getContentLengthLong() {
+        return contentLength;
+    }
+
+    /**
+     * Get the content type.
+     *
+     * @return the content type.
+     */
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+
+    /**
+     * Get the context path.
+     *
+     * @return the context path.
+     */
+    @Override
+    public String getContextPath() {
+        return contextPath;
+    }
+
+    /**
+     * Get the cookies.
+     *
+     * @return the cookies.
+     */
+    @Override
+    public Cookie[] getCookies() {
+        Cookie[] result = null;
+        if (cookies != null) {
+            result = new Cookie[cookies.length];
+            for (int i = 0; i < result.length; i++) {
+                result[i] = (Cookie) cookies[i].clone();
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Get the date header.
+     *
+     * @param name the header name.
+     * @return the date header.
+     */
+    @Override
+    public long getDateHeader(String name) {
+        return headerManager.getDateHeader(name);
+    }
+
+    /**
+     * Get the dispatcher type.
+     *
+     * @return the dispatcher type.
+     */
+    @Override
+    public DispatcherType getDispatcherType() {
+        return dispatcherType;
+    }
+
+    /**
+     * Get the header.
+     *
+     * @param name the header name.
+     * @return the header value.
+     */
+    @Override
+    public String getHeader(String name) {
+        return headerManager.getHeader(name);
+    }
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    @Override
+    public Enumeration<String> getHeaderNames() {
+        return headerManager.getHeaderNames();
+    }
+
+    /**
+     * Get the headers.
+     *
+     * @param name the header name.
+     * @return the header values.
+     */
+    @Override
+    public Enumeration<String> getHeaders(String name) {
+        return headerManager.getHeaders(name);
+    }
+
+    /**
+     * Get the input stream.
+     *
+     * @return the input stream.
+     * @throws IOException when a serious I/O error occurs.
+     */
+    @Override
+    public ServletInputStream getInputStream() throws IOException {
+        ServletInputStream result;
+        if (!gotReader) {
+            gotInputStream = true;
+            result = this;
+        } else {
+            throw new IllegalStateException(
+                    "Cannot getInputStream because getReader has been previously called");
+        }
+        return result;
+    }
+
+    /**
+     * Get the int header.
+     *
+     * @param name the name.
+     * @return the int header.
+     */
+    @Override
+    public int getIntHeader(String name) {
+        return headerManager.getIntHeader(name);
+    }
+
+    /**
+     * Get the local address.
+     *
+     * @return the local address.
+     */
+    @Override
+    public String getLocalAddr() {
+        return localAddress;
+    }
+
+    /**
+     * Get the local name.
+     *
+     * @return the local name.
+     */
+    @Override
+    public String getLocalName() {
+        return localName;
+    }
+
+    /**
+     * Get the local port.
+     *
+     * @return the local port.
+     */
+    @Override
+    public int getLocalPort() {
+        return localPort;
+    }
+
+    /**
+     * Get locale.
+     *
+     * @return the locale.
+     */
+    @Override
+    public Locale getLocale() {
+        Locale result = Locale.getDefault();
+        Enumeration<String> languages = getHeaders("Accept-Language");
+        if (languages.hasMoreElements()) {
+            String localeString = languages.nextElement();
+            String[] localeStrings = localeString.split(",");
+            if (localeStrings[0].contains("-")) {
+                String[] localeString1 = localeStrings[0].split("-");
+                result = new Locale(localeString1[0].trim(), localeString1[1].trim());
+            } else {
+                result = new Locale(localeStrings[0].trim());
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Get the locales.
+     *
+     * @return the locales.
+     */
+    @Override
+    public Enumeration<Locale> getLocales() {
+        ArrayList<Locale> locales = new ArrayList<>();
+        Enumeration<String> languages = getHeaders("Accept-Language");
+        if (languages.hasMoreElements()) {
+            String localeString = languages.nextElement();
+            String[] localeStrings = localeString.split(",");
+            for (String localeString1 : localeStrings) {
+                if (localeString1.contains("-")) {
+                    String[] localeString2 = localeString1.split("-");
+                    locales.add(new Locale(localeString2[0].trim(), localeString2[1].trim()));
+                } else {
+                    locales.add(new Locale(localeString1.trim()));
+                }
+            }
+        } else {
+            locales = new ArrayList<>();
+            locales.add(Locale.getDefault());
+        }
+        return Collections.enumeration(locales);
+    }
+
+    /**
+     * Get the request method.
+     *
+     * @return the request method.
+     */
+    @Override
+    public String getMethod() {
+        return method;
+    }
+
+    /**
+     * Get the parameter.
+     *
+     * @param name the name.
+     * @return the value.
+     */
+    @Override
+    public String getParameter(String name) {
+        String result = null;
+        getParametersFromRequest();
+        if (getParameterValues(name) != null) {
+            result = getParameterValues(name)[0];
+        }
+        return result;
+    }
+
+    /**
+     * Get the parameter map.
+     *
+     * @return the parameter map.
+     */
+    @Override
+    public Map<String, String[]> getParameterMap() {
+        getParametersFromRequest();
+        return Collections.unmodifiableMap(parameters);
+    }
+
+    /**
+     * Get the parameter names.
+     *
+     * @return the parameter names.
+     */
+    @Override
+    public Enumeration<String> getParameterNames() {
+        getParametersFromRequest();
+        return Collections.enumeration(parameters.keySet());
+    }
+
+    /**
+     * Get the parameter values.
+     *
+     * @param name the parameter name.
+     * @return the parameter values.
+     */
+    @Override
+    public String[] getParameterValues(String name) {
+        getParametersFromRequest();
+        return parameters.get(name);
+    }
+
+    /**
+     * Get the parameters from the request.
+     */
+    protected void getParametersFromRequest() {
+        if (!parametersParsed) {
+            parametersParsed = true;
+            try {
+                String mergedQueryString = mergeQueryFromAttributes();
+                if (mergedQueryString != null) {
+                    for (String param : mergedQueryString.split("&")) {
+                        String pair[] = param.split("=");
+                        String key = URLDecoder.decode(pair[0], "UTF-8");
+                        String value = "";
+                        if (pair.length > 1) {
+                            value = URLDecoder.decode(pair[1], "UTF-8");
+                        }
+                        String[] values = parameters.get(key);
+                        if (values == null) {
+                            values = new String[]{value};
+                            parameters.put(key, values);
+                        } else {
+                            String[] newValues = new String[values.length + 1];
+                            System.arraycopy(values, 0, newValues, 0, values.length);
+                            newValues[values.length] = value;
+                            parameters.put(key, newValues);
+                        }
+                    }
+                }
+
+                boolean hasBody
+                        = // FORM submission
+                        contentType != null && contentType.equals("application/x-www-form-urlencoded")
+                        || // PUT parameters
+                        "put".equalsIgnoreCase(getMethod()) && getContentLength() > 0;
+
+                if (hasBody) {
+                    ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+                    int read = read();
+                    while (read != -1) {
+                        byteOutput.write(read);
+                        read = read();
+                    }
+
+                    if (read != -1) {
+                        byteOutput.write(read);
+                    }
+
+                    String parameterString = new String(byteOutput.toByteArray());
+                    String[] pairs = parameterString.trim().split("&");
+                    if (pairs != null) {
+                        for (int i = 0; i < pairs.length; i++) {
+                            String[] pair = pairs[i].trim().split("=");
+                            if (pair.length == 2) {
+                                pair[0] = URLDecoder.decode(pair[0], "UTF-8");
+                                pair[1] = URLDecoder.decode(pair[1], "UTF-8");
+                                setParameter(pair[0], new String[]{pair[1]});
+                            } else {
+                                pair[0] = URLDecoder.decode(pair[0], "UTF-8");
+                                if (!"".equals(pair[0])) {
+                                    setParameter(pair[0], new String[]{""});
+                                }
+                            }
+                        }
+                    }
+                }
+            } catch (IOException ioe) {
+                throw new RuntimeException(ioe);
+            }
+        }
+    }
+
+    /**
+     * Merge query string from this request and from the attribute
+     * {@link RequestDispatcher.INCLUDE_QUERY_STRING} if the dispatcher type is {@link DispatcherType.INCLUDE}
+     * @return the query string merged
+     */
+    private String mergeQueryFromAttributes() {
+        String queryStringFromAttribute = dispatcherType == INCLUDE ? (String) getAttribute(INCLUDE_QUERY_STRING) : null;
+        if (queryStringFromAttribute == null) {
+            return queryString;
+        }
+
+        if (queryString == null) {
+            return queryStringFromAttribute;
+        }
+
+        return queryStringFromAttribute + "&" + queryString;
+    }
+
+    /**
+     * Get the part.
+     *
+     * @param name the name.
+     * @return the part, or null.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public Part getPart(String name) throws IOException, ServletException {
+        verifyMultipartFormData();
+        return webApplication.getMultiPartManager().getPart(webApplication, this, name);
+    }
+
+    /**
+     * Get the parts.
+     *
+     * @return the parts.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public Collection<Part> getParts() throws IOException, ServletException {
+        verifyMultipartFormData();
+        return webApplication.getMultiPartManager().getParts(webApplication, this);
+    }
+
+    /**
+     * Get the path info.
+     *
+     * @return the path info.
+     */
+    @Override
+    public String getPathInfo() {
+        return pathInfo;
+    }
+
+    /**
+     * Get the translated path.
+     *
+     * @return the translated path.
+     */
+    @Override
+    public String getPathTranslated() {
+        return null;
+    }
+
+    /**
+     * Get the protocol.
+     *
+     * @return the protocol.
+     */
+    @Override
+    public String getProtocol() {
+        return protocol;
+    }
+
+    /**
+     * Get the query string.
+     *
+     * @return the query string.
+     */
+    @Override
+    public String getQueryString() {
+        return queryString;
+    }
+
+    /**
+     * Get the reader.
+     *
+     * @return the reader.
+     * @throws IOException when a serious I/O error occurs.
+     */
+    @Override
+    public BufferedReader getReader() throws IOException {
+        if (!gotInputStream) {
+            if (reader == null) {
+
+                String charsetName = characterEncoding == null ? StandardCharsets.ISO_8859_1.toString() : characterEncoding;
+                if (!isSupported(charsetName)) {
+                    throw new UnsupportedEncodingException(charsetName);
+                }
+
+                reader = new BufferedReader(new InputStreamReader(this, charsetName));
+            }
+            gotReader = true;
+        } else {
+            throw new IllegalStateException("Cannot getReader because getInputStream has been previously called");
+        }
+        return reader;
+    }
+
+    private boolean isSupported(String csn) {
+        try {
+            return Charset.isSupported(csn);
+        } catch (IllegalCharsetNameException x) {
+            return false;
+        }
+    }
+
+
+    /**
+     * Get the real path.
+     *
+     * @param path the path.
+     * @return the real path.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public String getRealPath(String path) {
+        throw new UnsupportedOperationException("HttpServletRequest.getRealPath is no longer supported");
+    }
+
+    /**
+     * Get the remote address.
+     *
+     * @return the remote address.
+     */
+    @Override
+    public String getRemoteAddr() {
+        return remoteAddr;
+    }
+
+    /**
+     * Get the remote host.
+     *
+     * @return the remote host.
+     */
+    @Override
+    public String getRemoteHost() {
+        return remoteHost;
+    }
+
+    /**
+     * Get the remote port.
+     *
+     * @return the remote port.
+     */
+    @Override
+    public int getRemotePort() {
+        return remotePort;
+    }
+
+    /**
+     * Get the remote user.
+     *
+     * @return the remote user.
+     */
+    @Override
+    public String getRemoteUser() {
+        String result = null;
+        if (getUserPrincipal() != null) {
+            result = getUserPrincipal().getName();
+        }
+        return result;
+    }
+
+    /**
+     * Get the request dispatcher.
+     *
+     * @param path the path.
+     * @return the request dispatcher.
+     */
+    @Override
+    public RequestDispatcher getRequestDispatcher(String path) {
+        Path rootContext = Paths.get(getContextPath());
+        Path resolved = rootContext.resolveSibling(Paths.get(path)).normalize();
+        if (!resolved.startsWith(rootContext))
+            resolved = rootContext.resolveSibling(resolved);
+        return webApplication.getRequestDispatcher(resolved.toString());
+    }
+
+    /**
+     * Get the request URI.
+     *
+     * @return the request URI.
+     */
+    @Override
+    public String getRequestURI() {
+        String result = contextPath + servletPath;
+        if (pathInfo != null) {
+            result = contextPath + servletPath + pathInfo;
+        }
+        return result;
+    }
+
+    /**
+     * Get the request URL.
+     *
+     * @return the request URL.
+     */
+    @Override
+    public StringBuffer getRequestURL() {
+        StringBuffer result = new StringBuffer();
+        result.append(getScheme());
+        result.append("://");
+        result.append(getServerName());
+        result.append(":");
+        result.append(getServerPort());
+        result.append(getContextPath());
+        result.append(getServletPath());
+        if (getPathInfo() != null) {
+            result.append(getPathInfo());
+        }
+        return result;
+    }
+
+    /**
+     * Get the requested session id.
+     *
+     * @return the requested session id.
+     */
+    @Override
+    public String getRequestedSessionId() {
+        return requestedSessionId;
+    }
+
+    /**
+     * Get the scheme.
+     *
+     * @return the scheme.
+     */
+    @Override
+    public String getScheme() {
+        return scheme;
+    }
+
+    /**
+     * Get the server name.
+     *
+     * @return the server name.
+     */
+    @Override
+    public String getServerName() {
+        return serverName;
+    }
+
+    /**
+     * Get the server port.
+     *
+     * @return the server port.
+     */
+    @Override
+    public int getServerPort() {
+        return serverPort;
+    }
+
+    /**
+     * Get the servlet context.
+     *
+     * @return the servlet context.
+     */
+    @Override
+    public WebApplication getServletContext() {
+        return webApplication;
+    }
+
+    /**
+     * Get the servlet path.
+     *
+     * @return the servlet path.
+     */
+    @Override
+    public String getServletPath() {
+        return servletPath;
+    }
+
+    /**
+     * Get the session.
+     *
+     * @return the session.
+     */
+    @Override
+    public HttpSession getSession() {
+        return getSession(true);
+    }
+
+    @Override
+    public HttpSession getSession(boolean create) {
+        HttpSession session = null;
+        HttpSessionManager manager = webApplication.getHttpSessionManager();
+        if (currentSessionId == null && requestedSessionId != null) {
+            currentSessionId = requestedSessionId;
+        }
+
+        if (manager.hasSession(currentSessionId)) {
+            session = manager.getSession(this, currentSessionId);
+        } else if (create) {
+            session = manager.createSession(this);
+            currentSessionId = session.getId();
+        }
+
+        return session;
+    }
+
+    /**
+     * Get the upgrade handler.
+     *
+     * @return the upgrade handler.
+     */
+    public HttpUpgradeHandler getUpgradeHandler() {
+        return upgradeHandler;
+    }
+
+    /**
+     * Get the user principal.
+     *
+     * @return the user principal.
+     */
+    @Override
+    public Principal getUserPrincipal() {
+        return userPrincipal;
+    }
+
+    /**
+     * Is async started.
+     *
+     * @return is async started.
+     */
+    @Override
+    public boolean isAsyncStarted() {
+        return asyncStarted;
+    }
+
+    /**
+     * Is async supported.
+     *
+     * @return true if is async is supported.
+     */
+    @Override
+    public boolean isAsyncSupported() {
+        return asyncSupported;
+    }
+
+    /**
+     * Is the requested session id from cookie.
+     *
+     * @return if the requested session id from cookie.
+     */
+    @Override
+    public boolean isRequestedSessionIdFromCookie() {
+        return requestedSessionIdFromCookie;
+    }
+
+    /**
+     * Is the requested session id from the request url.
+     *
+     * @return if the requested session id from the request url.
+     */
+    @Override
+    public boolean isRequestedSessionIdFromURL() {
+        return requestedSessionIdFromURL;
+    }
+
+    /**
+     * Is the requested session id from the request url.
+     *
+     * @return if the requested session id from the request url.
+     * @deprecated
+     */
+    @Deprecated
+    @Override
+    public boolean isRequestedSessionIdFromUrl() {
+        return isRequestedSessionIdFromURL();
+    }
+
+    /**
+     * Is the requested session id valid?
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isRequestedSessionIdValid() {
+        boolean result = false;
+        if (requestedSessionId != null) {
+            HttpSessionManager manager = webApplication.getHttpSessionManager();
+            result = manager.hasSession(requestedSessionId);
+        }
+        return result;
+    }
+
+    /**
+     * Is the request secure.
+     *
+     * @return is the request secure.
+     */
+    @Override
+    public boolean isSecure() {
+        boolean result = false;
+        if ("https".equals(scheme)) {
+            result = true;
+        }
+        return result;
+    }
+
+    /**
+     * Is the request upgraded.
+     *
+     * @return false
+     */
+    public boolean isUpgraded() {
+        return upgraded;
+    }
+
+    /**
+     * Is the user in the specified role.
+     *
+     * @param role the role.
+     * @return if the user in the specified role.
+     */
+    @Override
+    public boolean isUserInRole(String role) {
+        return webApplication.getSecurityManager().isUserInRole(this, role);
+    }
+
+    /**
+     * Login.
+     *
+     * @param username the username.
+     * @param password the password.
+     * @throws ServletException when a serious error occurs.
+     */
+    @Override
+    public void login(String username, String password) throws ServletException {
+        webApplication.getSecurityManager().login(this, username, password);
+    }
+
+    /**
+     * Logout.
+     *
+     * @throws ServletException when a serious error occurs.
+     */
+    @Override
+    public void logout() throws ServletException {
+        webApplication.getSecurityManager().logout(this, (HttpServletResponse) this.webApplication.getResponse(this));
+    }
+
+    /**
+     * Remove the attribute.
+     *
+     * @param name the name.
+     */
+    @Override
+    public void removeAttribute(String name) {
+        Object oldValue = attributeManager.getAttribute(name);
+        attributeManager.removeAttribute(name);
+        if (webApplication != null && webApplication.getHttpRequestManager() != null) {
+            webApplication.getHttpRequestManager().attributeRemoved(this, name, oldValue);
+        }
+    }
+
+    /**
+     * Set the async supported flag.
+     *
+     * @param asyncSupported the async supported flag.
+     */
+    public void setAsyncSupported(boolean asyncSupported) {
+        this.asyncSupported = asyncSupported;
+    }
+
+    /**
+     * Set the attribute.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    @Override
+    public void setAttribute(String name, Object value) {
+        if (value != null) {
+            boolean added = true;
+            Object oldValue = attributeManager.getAttribute(name);
+            if (oldValue == null) {
+                added = false;
+            }
+
+            attributeManager.setAttribute(name, value);
+            if (webApplication != null && webApplication.getHttpRequestManager() != null) {
+                if (!added) {
+                    webApplication.getHttpRequestManager().attributeAdded(this, name, value);
+                } else {
+                    webApplication.getHttpRequestManager().attributeReplaced(this, name, oldValue);
+                }
+            }
+        } else {
+            Object oldValue = attributeManager.getAttribute(name);
+            attributeManager.removeAttribute(name);
+            if (webApplication != null && webApplication.getHttpRequestManager() != null) {
+                webApplication.getHttpRequestManager().attributeRemoved(this, name, oldValue);
+            }
+        }
+    }
+
+    /**
+     * Set the auth type.
+     *
+     * @param authType the auth type.
+     */
+    public void setAuthType(String authType) {
+        this.authType = authType;
+    }
+
+    /**
+     * Set the character encoding.
+     *
+     * @param characterEncoding the character encoding.
+     * @throws UnsupportedEncodingException when the encoding is not supported.
+     */
+    @Override
+    public void setCharacterEncoding(String characterEncoding) throws UnsupportedEncodingException {
+        boolean supported = false;
+        try {
+            supported = Charset.isSupported(characterEncoding);
+        } catch (IllegalArgumentException e) {
+        }
+        if (!supported) {
+            throw new UnsupportedEncodingException("Character encoding '" + characterEncoding + "' is not supported");
+        }
+        if (!gotReader) {
+            this.characterEncoding = characterEncoding;
+        }
+    }
+
+    /**
+     * Set the content length.
+     *
+     * @param contentLength the content length.
+     */
+    public void setContentLength(int contentLength) {
+        this.contentLength = contentLength;
+    }
+
+    /**
+     * Set the content type.
+     *
+     * @param contentType the content type.
+     */
+    public void setContentType(String contentType) {
+        this.contentType = contentType;
+        String[] parts = contentType.split(";");
+        if (parts.length == 1) {
+            return;
+        }
+        String charset = parts[1].trim();
+        String[] pair = charset.split("=");
+        if (pair.length == 1) {
+            return;
+        }
+        characterEncoding = pair[1].trim();
+    }
+
+    @Override
+    public void setContextPath(String contextPath) {
+        this.contextPath = contextPath;
+    }
+
+    /**
+     * Set the cookies.
+     *
+     * @param cookies the cookies.
+     */
+    public void setCookies(Cookie[] cookies) {
+        if (cookies == null || cookies.length == 0) {
+            this.cookies = null;
+        } else {
+            this.cookies = new Cookie[cookies.length];
+            for (int i = 0; i < cookies.length; i++) {
+                this.cookies[i] = (Cookie) cookies[i].clone();
+            }
+        }
+    }
+
+    /**
+     * Set the dispatcher type.
+     *
+     * @param dispatcherType the dispatcher type.
+     */
+    @Override
+    public void setDispatcherType(DispatcherType dispatcherType) {
+        this.dispatcherType = dispatcherType;
+    }
+
+    /**
+     * Set the header.
+     *
+     * @param name the name.
+     * @param value the value (string).
+     */
+    public void setHeader(String name, String value) {
+        headerManager.setHeader(name, value);
+    }
+
+    /**
+     * Set the input stream.
+     *
+     * @param inputStream the input stream.
+     */
+    public void setInputStream(InputStream inputStream) {
+        this.inputStream = inputStream;
+    }
+
+    /**
+     * Set the local address.
+     *
+     * @param localAddress the local address.
+     */
+    public void setLocalAddr(String localAddress) {
+        this.localAddress = localAddress;
+    }
+
+    /**
+     * Set the local name.
+     *
+     * @param localName the local name.
+     */
+    public void setLocalName(String localName) {
+        this.localName = localName;
+    }
+
+    /**
+     * Set the local port.
+     *
+     * @param localPort the local port.
+     */
+    public void setLocalPort(int localPort) {
+        this.localPort = localPort;
+    }
+
+    /**
+     * Set the method.
+     *
+     * @param method the method.
+     */
+    public void setMethod(String method) {
+        this.method = method;
+    }
+
+    /**
+     * Set the parameter values.
+     *
+     * @param name the parameter name.
+     * @param values the values.
+     */
+    public void setParameter(String name, String[] values) {
+        parameters.put(name, values);
+    }
+
+    /**
+     * Set the path info.
+     *
+     * @param pathInfo the path info.
+     */
+    public void setPathInfo(String pathInfo) {
+        this.pathInfo = pathInfo;
+    }
+
+    /**
+     * Set the protocol.
+     *
+     * @param protocol the protocol.
+     */
+    public void setProtocol(String protocol) {
+        this.protocol = protocol;
+    }
+
+    /**
+     * Set the query string.
+     *
+     * @param queryString the query string.
+     */
+    public void setQueryString(String queryString) {
+        this.queryString = queryString;
+    }
+
+    /**
+     * Set the remote address.
+     *
+     * @param remoteAddr the remote address.
+     */
+    public void setRemoteAddr(String remoteAddr) {
+        this.remoteAddr = remoteAddr;
+    }
+
+    /**
+     * Set the remote host.
+     *
+     * @param remoteHost the remote host.
+     */
+    public void setRemoteHost(String remoteHost) {
+        this.remoteHost = remoteHost;
+    }
+
+    /**
+     * Set the remote port.
+     *
+     * @param remotePort the remote port.
+     */
+    public void setRemotePort(int remotePort) {
+        this.remotePort = remotePort;
+    }
+
+    /**
+     * Set the requested session id.
+     *
+     * @param requestedSessionId the requested session id.
+     */
+    public void setRequestedSessionId(String requestedSessionId) {
+        this.requestedSessionId = requestedSessionId;
+    }
+
+    /**
+     * Set the requested session id from cookie.
+     *
+     * @param requestedSessionIdFromCookie the requested session id from cookie.
+     */
+    public void setRequestedSessionIdFromCookie(boolean requestedSessionIdFromCookie) {
+        this.requestedSessionIdFromCookie = requestedSessionIdFromCookie;
+    }
+
+    /**
+     * Set the request session id from URL flag.
+     *
+     * @param requestedSessionIdFromURL the requested session if from URL flag.
+     */
+    public void setRequestedSessionIdFromURL(boolean requestedSessionIdFromURL) {
+        this.requestedSessionIdFromURL = requestedSessionIdFromURL;
+    }
+
+    /**
+     * Set the scheme.
+     *
+     * @param scheme the scheme.
+     */
+    public void setScheme(String scheme) {
+        this.scheme = scheme;
+    }
+
+    /**
+     * Set the server name.
+     *
+     * @param serverName the server name.
+     */
+    public void setServerName(String serverName) {
+        this.serverName = serverName;
+    }
+
+    /**
+     * Set the server port.
+     *
+     * @param serverPort the server port.
+     */
+    public void setServerPort(int serverPort) {
+        this.serverPort = serverPort;
+    }
+
+    @Override
+    public void setServletPath(String servletPath) {
+        this.servletPath = servletPath;
+    }
+
+    /**
+     * Set the upgraded flag.
+     *
+     * @param upgraded the upgraded flag.
+     */
+    public void setUpgraded(boolean upgraded) {
+        this.upgraded = upgraded;
+    }
+
+    /**
+     * Set the user principal.
+     *
+     * @param userPrincipal the user principal.
+     */
+    public void setUserPrincipal(Principal userPrincipal) {
+        this.userPrincipal = userPrincipal;
+    }
+
+    @Override
+    public void setWebApplication(WebApplication webApplication) {
+        this.webApplication = webApplication;
+    }
+
+    /**
+     * Start async.
+     *
+     * @return the async context.
+     * @throws IllegalStateException when async is not supported.
+     */
+    @Override
+    public AsyncContext startAsync() throws IllegalStateException {
+        if (!isAsyncSupported()) {
+            throw new IllegalStateException("Async is not supported");
+        }
+
+        return startAsync(this, this.webApplication.getResponse(this));
+    }
+
+    /**
+     * Unwrap the request.
+     *
+     * @param <T> the type to unwrap to.
+     * @param request the request.
+     * @param type the class type of the result
+     * @return the unwrapped request.
+     */
+    public static <T> T unwrap(ServletRequest request, Class<T> type) {
+        ServletRequest currentRequest = request;
+        while (currentRequest instanceof ServletRequestWrapper) {
+            ServletRequestWrapper wrapper = (ServletRequestWrapper) currentRequest;
+            currentRequest = wrapper.getRequest();
+        }
+        return type.cast(currentRequest);
+    }
+
+    /**
+     * Set the async started flag.
+     * 
+     * @param asyncStarted the async started flag.
+     */
+    public void setAsyncStarted(boolean asyncStarted) {
+        this.asyncStarted = asyncStarted;
+    }
+
+    /**
+     * Start async.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @return the async context.
+     * @throws IllegalStateException when async is not supported.
+     */
+    @Override
+    public AsyncContext startAsync(ServletRequest request, ServletResponse response) throws IllegalStateException {
+        requireNonNull(request); requireNonNull(response);
+
+        if (!isAsyncSupported()) {
+            throw new IllegalStateException("Async is not supported");
+        }
+
+        if (request.getAttribute("CALLED_FROM_ASYNC_WRAPPER") != null) {
+            return new DefaultAsyncContext(request, response);
+        }
+
+        if (asyncContext != null) {
+            throw new IllegalStateException("Async cycle has already been started");
+        }
+
+        asyncContext = new DefaultAsyncContext(request, response);
+        asyncStarted = true;
+
+        Object previousAttribute = request.getAttribute(PREVIOUS_REQUEST);
+        while (previousAttribute instanceof HttpServletRequest) {
+            HttpServletRequest previousRequest = unwrap((HttpServletRequest) previousAttribute, HttpServletRequest.class);
+
+            if (previousRequest instanceof DefaultWebApplicationRequest) {
+                @SuppressWarnings("resource")
+                DefaultWebApplicationRequest defaultRequest = (DefaultWebApplicationRequest) previousRequest;
+
+                defaultRequest.setAsyncStarted(true);
+            }
+
+            previousAttribute = previousRequest.getAttribute(PREVIOUS_REQUEST);
+        }
+
+
+        return asyncContext;
+    }
+
+    /**
+     * Upgrade the request.
+     *
+     * @param <T> the type.
+     * @param handlerClass the handler class.
+     * @return the upgrade handler.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a serious error occurs.
+     */
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T extends HttpUpgradeHandler> T upgrade(Class<T> handlerClass) throws IOException, ServletException {
+        try {
+            upgradeHandler = handlerClass.getDeclaredConstructor().newInstance();
+        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException ie) {
+            throw new ServletException(ie);
+        }
+        setUpgraded(true);
+        return (T) upgradeHandler;
+    }
+
+    /**
+     * Verify the method is of type "multipart/form-data"
+     *
+     * @throws ServletException the exception thrown when it is not.
+     */
+    protected void verifyMultipartFormData() throws ServletException {
+        if (contentType != null && !contentType.startsWith("multipart/form-data")) {
+            throw new ServletException("Request not of type multipart/form-data");
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    //  ServletInputStream methods
+    // -------------------------------------------------------------------------
+    /**
+     * Is the Servlet input stream finished?
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isFinished() {
+        return finished;
+    }
+
+    /**
+     * Is the Servlet input stream ready?
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isReady() {
+        return true;
+    }
+
+    /**
+     * Set the read listener.
+     *
+     * @param listener the read listener.
+     */
+    @Override
+    public void setReadListener(ReadListener listener) {
+        if (listener == null) {
+            throw new NullPointerException("Read listener cannot be null");
+        }
+        if (this.readListener != null) {
+            throw new IllegalStateException("Read listener can only be set once");
+        }
+        if (!isAsyncStarted() && !isUpgraded()) {
+            throw new IllegalStateException("Read listener cannot be set as the request is not upgraded nor the async is started");
+        }
+        this.readListener = listener;
+    }
+
+    /**
+     * Read from the Servlet input stream.
+     *
+     * @return the read value.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Override
+    public int read() throws IOException {
+        if (finished || getContentLength() == 0) {
+            return -1;
+        }
+
+        int read = inputStream.read();
+        index++;
+        if (index == getContentLength() || read == -1) {
+            finished = true;
+        }
+
+        return read;
+    }
+
+    @Override
+    public String toString() {
+        return getRequestURIWithQueryString() + " " + super.toString();
+    }
+
+    /**
+     * Get the request URI with query string.
+     * 
+     * @return the request URI with query string.
+     */
+    public String getRequestURIWithQueryString() {
+        String requestURI = getRequestURI();
+        String queryString = getQueryString();
+        return queryString == null ? requestURI : requestURI + "?" + queryString;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapper.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapper.java
new file mode 100644
index 00000000..90f37cdb
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapper.java
@@ -0,0 +1,337 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static java.util.Arrays.stream;
+import static java.util.Collections.emptySet;
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toSet;
+import static javax.servlet.DispatcherType.REQUEST;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.Enumeration;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.servlet.DispatcherType;
+
+import cloud.piranha.servlet4.webapp.FilterMapping;
+import cloud.piranha.servlet4.webapp.WebApplicationRequestMapper;
+
+/**
+ * The default WebApplicationRequestMapper.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWebApplicationRequestMapper implements WebApplicationRequestMapper {
+
+    /**
+     * Stores the filter mappings.
+     */
+    protected final List<FilterMapping> filterMappings = new ArrayList<>();
+
+    /**
+     * Stores the servlet mappings.
+     */
+    protected final ConcurrentHashMap<String, String> servletMappings = new ConcurrentHashMap<>();
+
+    @Override
+    public Set<String> addFilterMapping(Set<DispatcherType> dispatcherTypes, String filterName, String... urlPatterns) {
+        return doAddFilterMapping(isEmpty(dispatcherTypes)? EnumSet.of(REQUEST) : dispatcherTypes, filterName, urlPatterns);
+    }
+
+    @Override
+    public Set<String> addFilterMappingBeforeExisting(Set<DispatcherType> dispatcherTypes, String filterName, String... urlPatterns) {
+       return doAddFilterMappingBeforeExisting(isEmpty(dispatcherTypes)? EnumSet.of(REQUEST) : dispatcherTypes, filterName, urlPatterns);
+    }
+
+    /**
+     * Add a servlet mapping.
+     *
+     * @param servletName the servlet name.
+     * @param urlPatterns the URL patterns to map (aka mappings).
+     * @return the URL patterns that were already added.
+     */
+    @Override
+    public Set<String> addServletMapping(String servletName, String... urlPatterns) {
+        // Servlet:JAVADOC:696.3 - if urlPatterns is null or empty throw IllegalArgumentException
+        if (isEmpty(urlPatterns)) {
+            throw new IllegalArgumentException("Mappings for " + servletName + " cannot be empty");
+        }
+
+        // Servlet:JAVADOC:696.1 - If any of the specified URL patterns are already mapped to a different Servlet, no updates will be performed.
+        Set<String> mappedToOtherServlet = stream(urlPatterns)
+            .filter(servletMappings::containsKey)
+            .filter(urlPattern -> !servletMappings.get(urlPattern).equals(servletName))
+            .collect(toSet());
+
+        if (!mappedToOtherServlet.isEmpty()) {
+            return mappedToOtherServlet;
+        }
+
+        for (String urlPattern : urlPatterns) {
+            servletMappings.put(urlPattern, servletName);
+        }
+
+        return emptySet();
+    }
+
+    /**
+     * Find the filter mappings.
+     *
+     * @param path the path.
+     * @return the filter mappings.
+     */
+    @Override
+    public Collection<String> findFilterMappings(DispatcherType dispatcherType, String path) {
+        List<String> result = new ArrayList<>();
+
+        if (path.contains("?")) {
+            path = path.substring(0, path.indexOf("?"));
+        }
+
+        for (FilterMapping filterMapping : filterMappings) {
+            if (dispatcherType.equals(filterMapping.getDispatcherType())) {
+                String filterName = filterMapping.getFilterName();
+                String urlPattern = filterMapping.getUrlPattern();
+
+                if (path.equals(urlPattern)) {
+                    result.add(filterName);
+                } else if (!path.startsWith("servlet:// ")) {
+
+                    // For Servlet "patterns", only do exact matches.
+                    // URL patterns are also matched prefix and extension.
+
+                    if (urlPattern.startsWith("*.")) {
+                        urlPattern = urlPattern.substring(1);
+                        if (path.endsWith(urlPattern)) {
+                            result.add(filterName);
+                        }
+                    } else if (!urlPattern.startsWith("*.") && urlPattern.endsWith("/*")) {
+                        urlPattern = urlPattern.substring(0, urlPattern.length() - 2);
+                        if (path.startsWith(urlPattern)) {
+                            result.add(filterName);
+                        }
+                    }
+                }
+            }
+        }
+
+        return result;
+    }
+
+    private Set<String> doAddFilterMapping(Set<DispatcherType> dispatcherTypes, String filterName, String... urlPatterns) {
+        requireNonNull(dispatcherTypes);
+
+        Set<String> result = new HashSet<>();
+        for (String urlPattern : urlPatterns) {
+            for (DispatcherType dispatcherType : dispatcherTypes) {
+                DefaultFilterMapping filterMapping = new DefaultFilterMapping(dispatcherType, filterName, urlPattern);
+                if (filterMappings.contains(filterMapping)) {
+                    result.add(urlPattern);
+                } else {
+                    filterMappings.add(filterMapping);
+                }
+            }
+        }
+        return result;
+    }
+
+    private Set<String> doAddFilterMappingBeforeExisting(Set<DispatcherType> dispatcherTypes, String filterName, String... urlPatterns) {
+        requireNonNull(dispatcherTypes);
+
+        Set<String> result = new HashSet<>();
+        for (String urlPattern : urlPatterns) {
+            for (DispatcherType dispatcherType : dispatcherTypes) {
+                DefaultFilterMapping filterMapping = new DefaultFilterMapping(dispatcherType, filterName, urlPattern);
+                if (filterMappings.contains(filterMapping)) {
+                    result.add(urlPattern);
+                } else {
+                    filterMappings.add(0, filterMapping);
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Find a servlet mapping with an exact mapping.
+     *
+     * @param path the path.
+     * @return the mapping, or null if not found.
+     */
+    private DefaultWebApplicationRequestMapping findServletExactMatch(String path) {
+        DefaultWebApplicationRequestMapping result = null;
+        Enumeration<String> exacts = servletMappings.keys();
+        while (exacts.hasMoreElements()) {
+            String exact = exacts.nextElement();
+
+            if (path.equals(exact)) {
+                result = new DefaultWebApplicationRequestMapping(exact);
+                result.setExact(true);
+                break;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Find a servlet mapping with an extension match.
+     *
+     * @param path the path.
+     * @return the mapping, or null if not found.
+     */
+    private DefaultWebApplicationRequestMapping findServletExtensionMatch(String path) {
+        DefaultWebApplicationRequestMapping result = null;
+        Enumeration<String> extensions = servletMappings.keys();
+        while (extensions.hasMoreElements()) {
+            String extension = extensions.nextElement();
+            /*
+             * Make sure it really is an extension first.
+             */
+            if (extension.startsWith("*.")) {
+                extension = extension.substring(1);
+                if (path.endsWith(extension)) {
+                    result = new DefaultWebApplicationRequestMapping("*" + extension);
+                    result.setExtension(true);
+                    break;
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Find a servlet mapping for the given path.
+     *
+     * @param path the path.
+     * @return the mapping, or null if not found.
+     */
+    @Override
+    public DefaultWebApplicationRequestMapping findServletMapping(String path) {
+        if (path.contains("?")) {
+            path = path.substring(0, path.indexOf("?"));
+        }
+        DefaultWebApplicationRequestMapping result = findServletExactMatch(path);
+        if (result == null) {
+            result = findServletPrefixMatch(path);
+        }
+        if (result == null) {
+            result = findServletExtensionMatch(path);
+        }
+        return result;
+    }
+
+    /**
+     * Find a servlet mapping with the longest prefix mapping.
+     *
+     * @param path the path.
+     * @return the mapping, or null if not found.
+     */
+    private DefaultWebApplicationRequestMapping findServletPrefixMatch(String path) {
+        DefaultWebApplicationRequestMapping result = null;
+        DefaultWebApplicationRequestMapping found;
+        for (;;) {
+            found = findServletPrefixMatch(path, result);
+            if (found != null) {
+                result = found;
+            } else {
+                break;
+            }
+        }
+        if (result != null) {
+            result.setMapping(result.getPath() + "*");
+        }
+        return result;
+    }
+
+    /**
+     * Find a servlet mapping with a prefix mapping longer than the given
+     * current prefix.
+     *
+     * @param path the path.
+     * @param currentPrefix the current matched prefix.
+     * @return the mapping, or null if not found.
+     */
+    private DefaultWebApplicationRequestMapping findServletPrefixMatch(String path, DefaultWebApplicationRequestMapping currentPrefix) {
+        DefaultWebApplicationRequestMapping result = null;
+        Enumeration<String> prefixes = servletMappings.keys();
+        while (prefixes.hasMoreElements()) {
+            String prefix = prefixes.nextElement();
+            if (!prefix.startsWith("*.") && prefix.endsWith("/*")) {
+                prefix = prefix.substring(0, prefix.length() - 1);
+                if ((path + "/").startsWith(prefix)) {
+                    result = new DefaultWebApplicationRequestMapping(prefix);
+                    break;
+                }
+            }
+        }
+        if (result != null && currentPrefix != null
+                && result.getPath().length() <= currentPrefix.getPath().length()) {
+            result = null;
+        }
+        return result;
+    }
+
+    /**
+     * Get the mappings for the specified servlet.
+     *
+     * @param servletName the servlet name.
+     * @return the mappings, or an empty collection if none.
+     */
+    @Override
+    public Collection<String> getServletMappings(String servletName) {
+        Collection<String> result = new ArrayList<>();
+        servletMappings.keySet().stream().filter(urlPattern
+                -> servletMappings.get(urlPattern).equals(servletName)).forEach(result::add);
+        return result;
+    }
+
+    /**
+     * Get the servlet name for the specified mapping..
+     *
+     * @param mapping the mapping.
+     * @return the servlet name, or null if not found.
+     */
+    @Override
+    public String getServletName(String mapping) {
+        return servletMappings.get(mapping);
+    }
+
+    private boolean isEmpty(Collection<?> collection) {
+        return collection == null || collection.isEmpty();
+    }
+
+    private boolean isEmpty(String[] strings) {
+        return strings == null || strings.length == 0;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapping.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapping.java
new file mode 100644
index 00000000..10a0d942
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapping.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.webapp.WebApplicationRequestMapping;
+
+/**
+ * The default WebApplicationRequestMapping.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWebApplicationRequestMapping implements WebApplicationRequestMapping {
+
+    /**
+     * Stores the exact flag.
+     */
+    private boolean exact;
+
+    /**
+     * Stores the extension flag.
+     */
+    private boolean extension;
+
+    /**
+     * Stores the mapping.
+     */
+    private String mapping;
+
+    /**
+     * Constructor.
+     *
+     * @param mapping the mapping.
+     */
+    public DefaultWebApplicationRequestMapping(String mapping) {
+        this.mapping = mapping;
+    }
+
+    /**
+     * Get the mapping.
+     *
+     * @return the mapping.
+     */
+    @Override
+    public String getPath() {
+        return mapping;
+    }
+
+    /**
+     * Is this an exact match.
+     *
+     * @return true it it is, false otherwise.
+     */
+    @Override
+    public boolean isExact() {
+        return exact;
+    }
+
+    /**
+     * Is this an extension match.
+     *
+     * @return true if it is, false otherwise.
+     */
+    @Override
+    public boolean isExtension() {
+        return extension;
+    }
+
+    /**
+     * Set the exact flag.
+     *
+     * @param exact the exact flag.
+     */
+    public void setExact(boolean exact) {
+        this.exact = exact;
+    }
+
+    /**
+     * Set the extension flag.
+     *
+     * @param extension the extension flag.
+     */
+    public void setExtension(boolean extension) {
+        this.extension = extension;
+    }
+
+    /**
+     * Set the mapping.
+     *
+     * @param mapping the mapping.
+     */
+    public void setMapping(String mapping) {
+        this.mapping = mapping;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationResponse.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationResponse.java
new file mode 100644
index 00000000..a766c6ca
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWebApplicationResponse.java
@@ -0,0 +1,831 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import static java.util.Collections.list;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.time.Instant;
+import java.time.ZoneId;
+import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.ServletRequest;
+import javax.servlet.WriteListener;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+
+import cloud.piranha.servlet4.webapp.LocaleEncodingManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationResponse;
+import java.util.Date;
+
+/**
+ * The default WebApplicationResponse.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWebApplicationResponse extends ServletOutputStream implements WebApplicationResponse {
+
+    /**
+     * Stores the body only flag.
+     */
+    protected boolean bodyOnly;
+
+    /**
+     * Stores the buffer.
+     */
+    protected byte[] buffer;
+
+    /**
+     * Stores the character encoding.
+     */
+    protected String characterEncoding;
+
+    /**
+     * Stores if the character encoding has been set manually.
+     */
+    protected boolean characterEncodingSet;
+
+    /**
+     * Stores the committed flag.
+     */
+    protected boolean committed;
+
+    /**
+     * Stores the content length.
+     */
+    protected long contentLength;
+
+    /**
+     * Stores the content type.
+     */
+    protected String contentType;
+
+    /**
+     * Stores if the content type has been set manually.
+     */
+    protected boolean contentTypeSet;
+
+    /**
+     * Stores the cookies.
+     */
+    protected List<Cookie> cookies;
+
+    /**
+     * Stores if we acquired the output stream.
+     */
+    protected boolean gotOutput;
+
+    /**
+     * Stores if we acquired the writer.
+     */
+    protected boolean gotWriter;
+
+    /**
+     * Stores the header manager.
+     */
+    protected DefaultHttpHeaderManager headerManager;
+
+    /**
+     * Stores the index.
+     */
+    protected int index;
+
+    /**
+     * Stores the locale.
+     */
+    protected Locale locale;
+
+    /**
+     * Stores the writer.
+     */
+    protected PrintWriter writer;
+
+    /**
+     * Stores the output stream.
+     */
+    protected OutputStream outputStream;
+
+    /**
+     * Stores the status code.
+     */
+    protected int status;
+
+    /**
+     * Stores the status message.
+     */
+    protected String statusMessage;
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Stores the content language
+     */
+    protected String contentLanguage;
+    
+    /**
+     * Stores the response closer.
+     */
+    protected Runnable responseCloser;
+
+    /**
+     * Constructor.
+     */
+    public DefaultWebApplicationResponse() {
+        buffer = new byte[8192];
+        characterEncoding = "ISO-8859-1";
+        characterEncodingSet = false;
+        committed = false;
+        contentType = null;
+        contentTypeSet = false;
+        cookies = new ArrayList<>();
+        gotOutput = false;
+        gotWriter = false;
+        headerManager = new DefaultHttpHeaderManager();
+        locale = Locale.getDefault();
+        status = 200;
+        statusMessage = null;
+        writer = null;
+    }
+
+    @Override
+    public void addCookie(Cookie cookie) {
+        if (isInclude()) {
+            return;
+        }
+        this.cookies.add(cookie);
+    }
+
+    @Override
+    public void addDateHeader(String name, long date) {
+        addHeader(name, formatDateToGMT(date));
+    }
+
+    @Override
+    public void addHeader(String name, String value) {
+        if (isInclude()) {
+            return;
+        }
+        headerManager.addHeader(name, value);
+    }
+
+    @Override
+    public void addIntHeader(String name, int value) {
+        addHeader(name, Integer.toString(value));
+    }
+
+    @Override
+    public boolean containsHeader(String name) {
+        return headerManager.containsHeader(name);
+    }
+
+    @Override
+    public String encodeRedirectURL(String url) {
+        String result = url;
+
+        if (webApplication.getHttpSessionManager() != null) {
+            result = webApplication.getHttpSessionManager().encodeRedirectURL(this, url);
+        }
+
+        return result;
+    }
+
+    @Deprecated
+    @Override
+    public String encodeRedirectUrl(String url) {
+        return encodeRedirectURL(url);
+    }
+
+    @Override
+    public String encodeURL(String url) {
+        String result = url;
+        if (webApplication.getHttpSessionManager() != null) {
+            result = webApplication.getHttpSessionManager().encodeURL(this, url);
+        }
+        return result;
+    }
+
+    @Deprecated
+    @Override
+    public String encodeUrl(String url) {
+        return encodeURL(url);
+    }
+
+    @Override
+    public void flushBuffer() throws IOException {
+        if (!isCommitted()) {
+            writeOut();
+        }
+        if (gotWriter) {
+            writer.flush();
+        }
+    }
+
+    @Override
+    public String getCharacterEncoding() {
+        String result = "ISO-8859-1";
+        if (characterEncoding != null) {
+            result = characterEncoding;
+        }
+        return result;
+    }
+
+    @Override
+    public int getBufferSize() {
+        return buffer.length;
+    }
+
+    /**
+     * Get the content length.
+     *
+     * @return the content length.
+     */
+    public long getContentLength() {
+        return contentLength;
+    }
+
+    @Override
+    public String getContentType() {
+        if (contentType == null) {
+            return null;
+        }
+        String encoding = characterEncodingSet ? ";charset=" + characterEncoding : "";
+        return contentType + encoding;
+    }
+
+    @Override
+    public String getHeader(String name) {
+        return headerManager.getHeader(name);
+    }
+
+    @Override
+    public Collection<String> getHeaderNames() {
+        List<String> headerNames = new ArrayList<>();
+        Enumeration<String> enumeration = headerManager.getHeaderNames();
+        if (enumeration != null) {
+            headerNames = list(enumeration);
+        }
+        return headerNames;
+    }
+
+    @Override
+    public Collection<String> getHeaders(String name) {
+        ArrayList<String> result = new ArrayList<>();
+        Enumeration<String> enumeration = headerManager.getHeaders(name);
+        if (enumeration != null) {
+            result = list(enumeration);
+        }
+        return result;
+    }
+
+    @Override
+    public Locale getLocale() {
+        return locale;
+    }
+
+    @Override
+    public ServletOutputStream getOutputStream() throws IOException {
+        if (!gotWriter) {
+            gotOutput = true;
+            return this;
+        }
+        throw new IllegalStateException("Cannot get output stream as the writer was already acquired");
+    }
+
+    @Override
+    public int getStatus() {
+        return status;
+    }
+
+    /**
+     * Get the status message.
+     *
+     * @return the status message.
+     */
+    public String getStatusMessage() {
+        return statusMessage;
+    }
+
+    /**
+     * Get the web application.
+     *
+     * @return the web application.
+     */
+    public WebApplication getWebApplication() {
+        return webApplication;
+    }
+
+    @Override
+    public synchronized PrintWriter getWriter() throws IOException {
+        PrintWriter result = null;
+        if (!gotOutput) {
+            if (gotWriter == false) {
+                if (characterEncoding == null || !characterEncodingSet) {
+                    setCharacterEncoding("ISO-8859-1");
+                }
+                gotWriter = true;
+                writer = new PrintWriter(new OutputStreamWriter(this, characterEncoding), false);
+            }
+            result = writer;
+        } else {
+            throw new IllegalStateException("Cannot get writer as the output stream was already acquired");
+        }
+        return result;
+    }
+
+    /**
+     * Is body only.
+     *
+     * @return true if we are only sending the body, false otherwise.
+     */
+    public boolean isBodyOnly() {
+        return bodyOnly;
+    }
+
+    @Override
+    public boolean isCommitted() {
+        return committed;
+    }
+
+    @Override
+    public void reset() {
+        verifyNotCommitted("reset");
+        this.status = 200;
+        this.statusMessage = null;
+        resetBuffer();
+        setErrorMessageAttribute();
+    }
+
+    @Override
+    public void resetBuffer() {
+        this.buffer = new byte[buffer.length];
+    }
+
+    @Override
+    public void sendError(int status) throws IOException {
+        verifyNotCommitted("sendError");
+        setStatus(status);
+    }
+
+    @Override
+    public void sendError(int status, String statusMessage) throws IOException {
+        verifyNotCommitted("sendError");
+        setStatus(status);
+        this.statusMessage = statusMessage;
+        setErrorMessageAttribute();
+    }
+
+    @Override
+    public void sendRedirect(String location) throws IOException {
+        verifyNotCommitted("sendRedirect");
+        resetBuffer();
+        setStatus(SC_FOUND);
+        URL url;
+        try {
+            url = new URL(location);
+        } catch (MalformedURLException mue) {
+            HttpServletRequest request = (HttpServletRequest) webApplication.getRequest(this);
+            if (location.startsWith("/")) {
+                url = new URL(request.getScheme(), request.getServerName(),
+                        request.getServerPort(), location);
+            } else {
+                url = new URL(request.getScheme(), request.getServerName(),
+                        request.getServerPort(), request.getContextPath()
+                        + "/" + location);
+            }
+        }
+        setHeader("Location", url.toExternalForm());
+        flushBuffer();
+    }
+
+    /**
+     * Set the body only flag.
+     *
+     * @param bodyOnly flag.
+     */
+    public void setBodyOnly(boolean bodyOnly) {
+        this.bodyOnly = bodyOnly;
+    }
+
+    @Override
+    public void setBufferSize(int bufferSize) {
+        verifyNotCommitted("setBufferSize");
+        this.buffer = new byte[bufferSize];
+    }
+
+    @Override
+    public void setCharacterEncoding(String characterEncoding) {
+        if (isInclude()) {
+            return;
+        }
+        if (!gotWriter && !committed) {
+            this.characterEncoding = characterEncoding;
+            characterEncodingSet = true;
+        }
+    }
+
+    /**
+     * Set the committed.
+     *
+     * @param committed the committed flag.
+     */
+    public void setCommitted(boolean committed) {
+        this.committed = committed;
+    }
+
+    @Override
+    public void setContentLength(int contentLength) {
+        setContentLengthLong(contentLength);
+    }
+
+    @Override
+    public void setContentLengthLong(long contentLength) {
+        if (isInclude()) {
+            return;
+        }
+        this.contentLength = contentLength;
+        headerManager.addHeader("Content-Length", String.valueOf(contentLength));
+    }
+
+    @Override
+    public void setContentType(String type) {
+        if (isInclude()) {
+            return;
+        }
+        if (!isCommitted()) {
+            if (type != null) {
+                if (type.contains(";")) {
+                    contentType = type.substring(0, type.indexOf(";")).trim();
+                    String encoding = type.substring(type.indexOf(";") + 1).trim();
+                    if (encoding.contains("=")) {
+                        encoding = encoding.substring(encoding.indexOf("=") + 1).trim();
+                        setCharacterEncoding(encoding);
+                    }
+                } else {
+                    contentType = type;
+                }
+            } else {
+                contentType = type;
+            }
+            contentTypeSet = true;
+        }
+    }
+
+    @Override
+    public void setDateHeader(String name, long date) {
+        setHeader(name, formatDateToGMT(date));
+    }
+
+    @Override
+    public void setHeader(String name, String value) {
+        if (isInclude()) {
+            return;
+        }
+        headerManager.setHeader(name, value);
+    }
+
+    @Override
+    public void setIntHeader(String name, int value) {
+        setHeader(name, Integer.toString(value));
+    }
+
+    @Override
+    public void setLocale(Locale locale) {
+        if (isCommitted() || isInclude()) {
+            return;
+        }
+        this.locale = locale;
+        this.contentLanguage = locale.toLanguageTag();
+        if (webApplication == null) {
+            return;
+        }
+        LocaleEncodingManager localeEncodingManager = webApplication.getLocaleEncodingManager();
+        if (localeEncodingManager != null) {
+            String encoding = localeEncodingManager.getCharacterEncoding(locale.toString());
+            if (encoding != null) {
+                setCharacterEncoding(encoding);
+            }
+        }
+    }
+
+    /**
+     * Set the output stream.
+     *
+     * @param outputStream the output stream.
+     */
+    public void setOutputStream(ServletOutputStream outputStream) {
+        this.outputStream = outputStream;
+    }
+
+    @Override
+    public void setStatus(int status) {
+        if (isInclude()) {
+            return;
+        }
+        if (!isCommitted()) {
+            this.status = status;
+        }
+    }
+
+    @Deprecated
+    @Override
+    public void setStatus(int status, String statusMessage) {
+        setStatus(status);
+    }
+
+    @Override
+    public void setWebApplication(WebApplication webApplication) {
+        this.webApplication = webApplication;
+    }
+
+    /**
+     * Verify we are not committed.
+     *
+     * @param methodName the method we are checking for.
+     */
+    protected void verifyNotCommitted(String methodName) {
+        if (isCommitted()) {
+            throw new IllegalStateException("Response already committed in " + methodName);
+        }
+    }
+
+    private void setErrorMessageAttribute() {
+        if (webApplication != null) {
+            ServletRequest request = webApplication.getRequest(this);
+            if (request != null) {
+                request.setAttribute(RequestDispatcher.ERROR_MESSAGE, statusMessage);
+            }
+        }
+    }
+
+    @Override
+    public void close() throws IOException {
+        if (!isCommitted()) {
+            flush();
+        }
+    }
+
+    @Override
+    public void closeAsyncResponse() {
+        responseCloser.run();
+    }
+    
+    @Override
+    public void flush() throws IOException {
+        if (!isCommitted()) {
+            writeOut();
+        }
+
+        outputStream.flush();
+    }
+
+    /**
+     * Format the timestamp to a GMT string.
+     *
+     * @param timestamp the timestamp.
+     * @return the GMT string.
+     */
+    private String formatDateToGMT(long timestamp) {
+        return Instant.ofEpochMilli(timestamp).atZone(ZoneId.of("GMT"))
+                .format(DateTimeFormatter.RFC_1123_DATE_TIME);
+    }
+
+    @Override
+    public Collection<Cookie> getCookies() {
+        return cookies;
+    }
+
+    @Override
+    public OutputStream getUnderlyingOutputStream() {
+        return outputStream;
+    }
+
+    /**
+     * Is this an include dispatch.
+     *
+     * @return true if it is, false otherwise.
+     */
+    private boolean isInclude() {
+        if (webApplication == null) {
+            return false;
+        }
+        ServletRequest request = webApplication.getRequest(this);
+        return request != null && request.getDispatcherType() == DispatcherType.INCLUDE;
+    }
+
+    @Override
+    public boolean isReady() {
+        return true;
+    }
+
+    @Override
+    public final void setUnderlyingOutputStream(OutputStream outputStream) {
+        this.outputStream = outputStream;
+    }
+
+    @Override
+    public void setWriteListener(WriteListener listener) {
+    }
+
+    @Override
+    public void write(int integer) throws IOException {
+        if (index == buffer.length - 1) {
+            writeOut();
+            outputStream.write(integer);
+        } else if (index == buffer.length) {
+            outputStream.write(integer);
+        } else {
+            this.buffer[index] = (byte) integer;
+            this.index++;
+        }
+    }
+
+    /**
+     * Write the content language.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    private void writeContentLanguage() throws IOException {
+        if (contentLanguage == null) {
+            return;
+        }
+        outputStream.write("Content-Language: ".getBytes());
+        outputStream.write(contentLanguage.getBytes());
+        outputStream.write("\n".getBytes());
+    }
+
+    /**
+     * Write the content type.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    private void writeContentType() throws IOException {
+        if (contentType != null) {
+            outputStream.write("Content-Type: ".getBytes());
+            outputStream.write(contentType.getBytes());
+            if (characterEncoding != null) {
+                outputStream.write(";charset=".getBytes());
+                outputStream.write(characterEncoding.getBytes());
+            }
+            outputStream.write("\n".getBytes());
+        }
+    }
+
+    /**
+     * Write out a cookie.
+     *
+     * @param cookie the cookie.
+     * @throws IOException when an I/O error occurs.
+     */
+    private void writeCookie(Cookie cookie) throws IOException {
+        outputStream.write("Set-Cookie: ".getBytes());
+        outputStream.write(cookie.getName().getBytes());
+        outputStream.write("=".getBytes());
+        if (cookie.getValue() != null) {
+            outputStream.write(cookie.getValue().getBytes());
+        }
+        if (cookie.getMaxAge() > -1) {
+            Date expires = new Date();
+            expires.setTime(expires.getTime() + cookie.getMaxAge() * 1000);
+            outputStream.write(("; Expires=" + expires.toString()).getBytes());
+        }
+        if (cookie.getSecure()) {
+            outputStream.write("; Secure".getBytes());
+        }
+        if (cookie.isHttpOnly()) {
+            outputStream.write("; HttpOnly".getBytes());
+        }
+        if (cookie.getPath() != null) {
+            outputStream.write(("; Path=" + cookie.getPath()).getBytes());
+        }
+        outputStream.write(("; Version=" + cookie.getVersion()).getBytes());
+        outputStream.write("\n".getBytes());
+    }
+
+    /**
+     * Write the cookies.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    private void writeCookies() throws IOException {
+        for (Cookie cookie : cookies) {
+            writeCookie(cookie);
+        }
+    }
+
+    /**
+     * Write out a response header.
+     *
+     * @param name the name of the header.
+     * @throws IOException when an I/O error occurs.
+     */
+    private void writeHeader(String name) throws IOException {
+        Iterator<String> values = getHeaders(name).iterator();
+        outputStream.write(name.getBytes());
+        outputStream.write(": ".getBytes());
+        while (values.hasNext()) {
+            String value = values.next();
+            if (value != null) {
+                outputStream.write(value.getBytes());
+                if (values.hasNext()) {
+                    outputStream.write(",".getBytes());
+                }
+            }
+        }
+        outputStream.write("\n".getBytes());
+    }
+
+    @Override
+    public void writeHeaders() throws IOException {
+        writeContentType();
+        writeContentLanguage();
+        writeCookies();
+        Iterator<String> names = getHeaderNames().iterator();
+        while (names.hasNext()) {
+            String name = names.next();
+            writeHeader(name);
+        }
+        outputStream.write("\n".getBytes());
+    }
+
+    /**
+     * Write out the status-line, headers and the buffer.
+     *
+     * @throws IOException when an I/O error occurs.
+     */
+    private void writeOut() throws IOException {
+        if (!isBodyOnly()) {
+            writeStatusLine();
+            writeHeaders();
+        }
+        if (!isCommitted()) {
+            outputStream.write(buffer, 0, index);
+            index = buffer.length;
+        }
+        setCommitted(true);
+    }
+
+    @Override
+    public void writeStatusLine() throws IOException {
+        outputStream.write("HTTP/1.1".getBytes());
+        outputStream.write(" ".getBytes());
+        outputStream.write(Integer.toString(getStatus()).getBytes());
+        if (getStatusMessage() != null) {
+            outputStream.write(" ".getBytes());
+            outputStream.write(getStatusMessage().getBytes());
+        }
+        outputStream.write("\n".getBytes());
+    }
+
+    @Override
+    public Runnable getResponseCloser() {
+        return responseCloser;
+    }
+
+    @Override
+    public void setResponseCloser(Runnable responseCloser) {
+        this.responseCloser = responseCloser;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWelcomeFileFilter.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWelcomeFileFilter.java
new file mode 100644
index 00000000..ab256f2a
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWelcomeFileFilter.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+import java.io.IOException;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * The default WelcomeFile filter.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWelcomeFileFilter implements Filter {
+
+    @Override
+    public void doFilter(ServletRequest request, ServletResponse response, 
+            FilterChain chain) throws IOException, ServletException {
+        WebApplication webApplication = (WebApplication) request.getServletContext();
+        webApplication.getWelcomeFileManager().doFilter(request, response, chain);
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWelcomeFileManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWelcomeFileManager.java
new file mode 100644
index 00000000..108b5444
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/DefaultWelcomeFileManager.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.webapp.WelcomeFileManager;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * The default WelcomeFileManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class DefaultWelcomeFileManager implements WelcomeFileManager {
+
+    /**
+     * Stores the remove defaults flag.
+     */
+    private boolean removeDefaults;
+
+    /**
+     * Stores the welcome file list.
+     */
+    private final ArrayList<String> welcomeFileList;
+
+    /**
+     * Constructor.
+     */
+    public DefaultWelcomeFileManager() {
+        removeDefaults = true;
+        welcomeFileList = new ArrayList<>();
+        welcomeFileList.add("index.jsp");
+        welcomeFileList.add("index.html");
+        welcomeFileList.add("index.htm");
+    }
+
+    @Override
+    public void addWelcomeFile(String welcomeFile) {
+        /*
+         * Upon the first welcome-file added the default list is deleted.
+         */
+        if (removeDefaults) {
+            welcomeFileList.clear();
+            removeDefaults = false;
+        }
+        welcomeFileList.add(welcomeFile);
+    }
+
+    @Override
+    public void doFilter(ServletRequest request, ServletResponse response, 
+            FilterChain chain) throws IOException, ServletException {
+        chain.doFilter(request, response);
+    }
+    
+    @Override
+    public List<String> getWelcomeFileList() {
+        return welcomeFileList;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXml.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXml.java
new file mode 100644
index 00000000..b4c48220
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXml.java
@@ -0,0 +1,717 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+/**
+ * The web.xml in object format.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXml implements Serializable {
+
+    /**
+     * Stores the others tag.
+     */
+    public static final String OTHERS_TAG = WebXml.class.getName() + ".ordering.others";
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = 6143204024206508136L;
+
+    /**
+     * Stores the major version.
+     */
+    public int majorVersion;
+
+    /**
+     * Stores the minor version.
+     */
+    public int minorVersion;
+
+    /**
+     * Stores the security constraints
+     */
+    public List<SecurityConstraint> securityConstraints = new ArrayList<>();
+
+    /**
+     * Stores the metadata complete flag.
+     */
+    private boolean metadataComplete;
+
+    /**
+     * Stores the absolute ordering.
+     */
+    private List<String> absoluteOrdering;
+
+    /**
+     * Stores the locale encoding mapping.
+     */
+    private Map<String, String> localeEncodingMapping = new HashMap<>();
+
+    /**
+     * A class used to deal with before/after ordering.
+     */
+    public static class RelativeOrder {
+
+        /**
+         * Stores the before.
+         */
+        private List<String> before;
+
+        /**
+         * Stores the after.
+         */
+        private List<String> after;
+
+        /**
+         * Constructor.
+         */
+        public RelativeOrder() {
+            before = Collections.emptyList();
+            after = Collections.emptyList();
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param before the before.
+         * @param after the after.
+         */
+        public RelativeOrder(List<String> before, List<String> after) {
+            this.before = Objects.requireNonNullElseGet(before, Collections::emptyList);
+            this.after = Objects.requireNonNullElseGet(after, Collections::emptyList);
+        }
+
+        /**
+         * Get the before.
+         *
+         * @return the before.
+         */
+        public List<String> getBefore() {
+            return before;
+        }
+
+        /**
+         * Set the before.
+         *
+         * @param before the before.
+         */
+        public void setBefore(List<String> before) {
+            this.before = before;
+        }
+
+        /**
+         * Get the after.
+         *
+         * @return the after.
+         */
+        public List<String> getAfter() {
+            return after;
+        }
+
+        /**
+         * Set the after.
+         *
+         * @param after the after.
+         */
+        public void setAfter(List<String> after) {
+            this.after = after;
+        }
+    }
+
+    /**
+     * Stores the relative ordering.
+     */
+    private RelativeOrder relativeOrdering;
+
+    /**
+     * The &lt;security-constraint&gt; snippet inside a web.xml /
+     * webfragment.xml.
+     */
+    public static class SecurityConstraint {
+
+        // Example:
+        //  <security-constraint>
+        //      <web-resource-collection>
+        //          <web-resource-name>SecureServlet</web-resource-name>
+        //          <url-pattern>/SecureServlet</url-pattern>
+        //          <http-method>GET</http-method>
+        //          <http-method>POST</http-method>
+        //      </web-resource-collection>
+        //      <auth-constraint>
+        //          <role-name>someRole</role-name>
+        //      </auth-constraint>
+        //      <user-data-constraint>
+        //          <transport-guarantee>NONE</transport-guarantee>
+        //      </user-data-constraint>
+        //  </security-constraint>
+        /**
+         * Stores the web resource collections.
+         */
+        public List<WebResourceCollection> webResourceCollections = new ArrayList<>();
+
+        /**
+         * The list &lt;role-name&gt; snippets inside &lt;auth-constraint&gt;
+         *
+         * Note that we don't map the &lt;auth-constraint&gt; element separately
+         * here
+         */
+        public List<String> roleNames = new ArrayList<>();
+
+        /**
+         * The list &lt;transport-guarantee&gt; snippet inside
+         * &lt;user-data-constraint&gt;
+         *
+         * Note that we don't map the &lt;user-data-constraint&gt; element
+         * separately here
+         */
+        public String transportGuarantee;
+
+        /**
+         * The &lt;web-resource-collection&gt; snippet inside a web.xml /
+         * webfragment.xml.
+         */
+        public static class WebResourceCollection {
+
+            /**
+             * The list &lt;url-pattern&gt; snippets inside
+             * &lt;web-resource-collection&gt;
+             */
+            public List<String> urlPatterns = new ArrayList<>();
+
+            /**
+             * The list &lt;http-method&gt; snippets inside
+             * &lt;web-resource-collection&gt;
+             */
+            public List<String> httpMethods = new ArrayList<>();
+
+            /**
+             * The list &lt;http-method-omission&gt; snippets inside
+             * &lt;web-resource-collection&gt;
+             */
+            public List<String> httpMethodOmissions = new ArrayList<>();
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    /**
+     * Stores the context params.
+     */
+    private final List<WebXmlContextParam> contextParams = new ArrayList<>();
+
+    /**
+     * Stores the default context path.
+     */
+    private String defaultContextPath;
+
+    /**
+     * Store if we are denying uncovered HTTP methods.
+     */
+    private boolean denyUncoveredHttpMethods;
+
+    /**
+     * Store the display name.
+     */
+    private String displayName;
+
+    /**
+     * Store if we are distributable.
+     */
+    private boolean distributable;
+
+    /**
+     * Stores the error pages.
+     */
+    private final List<WebXmlErrorPage> errorPages = new ArrayList<>();
+
+    /**
+     * Stores the filters.
+     */
+    private final List<WebXmlFilter> filters = new ArrayList<>();
+
+    /**
+     * Stores the filter mappings.
+     */
+    private final List<WebXmlFilterMapping> filterMappings = new ArrayList<>();
+
+    /**
+     * Stores if we are a fragment.
+     */
+    private boolean fragment;
+
+    /**
+     * Stores the fragment name.
+     */
+    private String fragmentName;
+
+    /**
+     * Stores the listeners.
+     */
+    private final List<WebXmlListener> listeners = new ArrayList<>();
+
+    /**
+     * Stores the login config.
+     */
+    private WebXmlLoginConfig loginConfig;
+
+    /**
+     * Stores the mime mappings.
+     */
+    private final List<WebXmlMimeMapping> mimeMappings = new ArrayList<>();
+
+    /**
+     * Stores the request character encoding.
+     */
+    private String requestCharacterEncoding;
+
+    /**
+     * Stores the response character encoding.
+     */
+    private String responseCharacterEncoding;
+
+    /**
+     * Set of all unique role names that have either been explicitly declared,
+     * or used in a constraint.
+     */
+    private final Set<String> roleNames = new HashSet<>();
+
+    /**
+     * Stores the servlets.
+     */
+    private final List<WebXmlServlet> servlets = new ArrayList<>();
+
+    /**
+     * Stores the servlet mappings.
+     */
+    private final List<WebXmlServletMapping> servletMappings = new ArrayList<>();
+
+    /**
+     * Stores the session configuration.
+     */
+    private WebXmlSessionConfig sessionConfig;
+
+    /**
+     * Stores the welcome files.
+     */
+    private final List<String> welcomeFiles = new ArrayList<>();
+
+    /**
+     * Get the context params.
+     *
+     * @return the context params.
+     */
+    public List<WebXmlContextParam> getContextParams() {
+        return contextParams;
+    }
+
+    /**
+     * Get the default context path.
+     *
+     * @return the default context path.
+     */
+    public String getDefaultContextPath() {
+        return defaultContextPath;
+    }
+
+    /**
+     * Get if we are denying uncovered HTTP methods.
+     *
+     * @return true if we are, false otherwise.
+     */
+    public boolean getDenyUncoveredHttpMethods() {
+        return denyUncoveredHttpMethods;
+    }
+
+    /**
+     * Get the display name.
+     *
+     * @return the display name.
+     */
+    public String getDisplayName() {
+        return displayName;
+    }
+
+    /**
+     * Get the error pages.
+     *
+     * @return the error pages.
+     */
+    public List<WebXmlErrorPage> getErrorPages() {
+        return errorPages;
+    }
+
+    /**
+     * Get the filters.
+     *
+     * @return the filters.
+     */
+    public List<WebXmlFilter> getFilters() {
+        return filters;
+    }
+
+    /**
+     * Get the filter mappings.
+     *
+     * @return the filter mappings.
+     */
+    public List<WebXmlFilterMapping> getFilterMappings() {
+        return filterMappings;
+    }
+
+    /**
+     * Get the fragment name.
+     *
+     * @return the fragment name.
+     */
+    public String getFragmentName() {
+        return fragmentName;
+    }
+
+    /**
+     * Get the login config.
+     *
+     * @return the login config.
+     */
+    public WebXmlLoginConfig getLoginConfig() {
+        return loginConfig;
+    }
+
+    /**
+     * Get the listeners.
+     *
+     * @return the listeners.
+     */
+    public List<WebXmlListener> getListeners() {
+        return listeners;
+    }
+
+    /**
+     * Get the mime mappings.
+     *
+     * @return the mime mappings.
+     */
+    public List<WebXmlMimeMapping> getMimeMappings() {
+        return mimeMappings;
+    }
+
+    /**
+     * Get the request character encoding.
+     *
+     * @return the request character encoding.
+     */
+    public String getRequestCharacterEncoding() {
+        return requestCharacterEncoding;
+    }
+
+    /**
+     * Get the response character encoding.
+     *
+     * @return the response character encoding.
+     */
+    public String getResponseCharacterEncoding() {
+        return responseCharacterEncoding;
+    }
+
+    /**
+     * Get all the unique role names that have either been explicitly declared,
+     * or used in a constraint.
+     *
+     * @return the unique role names that have either been explicitly declared,
+     * or used in a constraint.
+     */
+    public Set<String> getRoleNames() {
+        return roleNames;
+    }
+
+    /**
+     * Get the servlets.
+     *
+     * @return the servlets.
+     */
+    public List<WebXmlServlet> getServlets() {
+        return servlets;
+    }
+
+    /**
+     * Get the servlet mappings.
+     *
+     * @return the servlet mappings.
+     */
+    public List<WebXmlServletMapping> getServletMappings() {
+        return servletMappings;
+    }
+
+    /**
+     * Get the session config.
+     *
+     * @return the session config.
+     */
+    public WebXmlSessionConfig getSessionConfig() {
+        return sessionConfig;
+    }
+
+    /**
+     * Get the welcome files.
+     *
+     * @return welcome files.
+     */
+    public List<String> getWelcomeFiles() {
+        return welcomeFiles;
+    }
+
+    /**
+     * Is the application distributable.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isDistributable() {
+        return distributable;
+    }
+
+    /**
+     * Is this a web-fragment.
+     *
+     * @return true if it, false otherwise.
+     */
+    public boolean isFragment() {
+        return fragment;
+    }
+
+    /**
+     * Set the default context path.
+     *
+     * @param defaultContextPath the default context path.
+     */
+    public void setDefaultContextPath(String defaultContextPath) {
+        this.defaultContextPath = defaultContextPath;
+    }
+
+    /**
+     * Set if we are denying uncovered HTTP methods.
+     *
+     * @param denyUncoveredHttpMethods the boolean value.
+     */
+    public void setDenyUncoveredHttpMethods(boolean denyUncoveredHttpMethods) {
+        this.denyUncoveredHttpMethods = denyUncoveredHttpMethods;
+    }
+
+    /**
+     * Set the display name.
+     *
+     * @param displayName the display name.
+     */
+    public void setDisplayName(String displayName) {
+        this.displayName = displayName;
+    }
+
+    /**
+     * Set if we are distributable.
+     *
+     * @param distributable the boolean value.
+     */
+    public void setDistributable(boolean distributable) {
+        this.distributable = distributable;
+    }
+
+    /**
+     * Set if we are a fragment.
+     *
+     * @param fragment the boolean value.
+     */
+    public void setFragment(boolean fragment) {
+        this.fragment = fragment;
+    }
+
+    /**
+     * Set the fragment name.
+     *
+     * @param fragmentName the fragment name.
+     */
+    public void setFragmentName(String fragmentName) {
+        this.fragmentName = fragmentName;
+    }
+
+    /**
+     * Set the login config.
+     *
+     * @param loginConfig the login config.
+     */
+    public void setLoginConfig(WebXmlLoginConfig loginConfig) {
+        this.loginConfig = loginConfig;
+    }
+
+    /**
+     * Set the request character encoding.
+     *
+     * @param requestCharacterEncoding the request character encoding.
+     */
+    public void setRequestCharacterEncoding(String requestCharacterEncoding) {
+        this.requestCharacterEncoding = requestCharacterEncoding;
+    }
+
+    /**
+     * Set the response character encoding.
+     *
+     * @param responseCharacterEncoding the response character encoding.
+     */
+    public void setResponseCharacterEncoding(String responseCharacterEncoding) {
+        this.responseCharacterEncoding = responseCharacterEncoding;
+    }
+
+    /**
+     * Set the session config.
+     *
+     * @param sessionConfig the session comfig.
+     */
+    public void setSessionConfig(WebXmlSessionConfig sessionConfig) {
+        this.sessionConfig = sessionConfig;
+    }
+
+    /**
+     * Gets the major version as set by the version attribute in the web app
+     * element
+     *
+     * @return the major version.
+     */
+    public int getMajorVersion() {
+        return majorVersion;
+    }
+
+    /**
+     * Sets the major version as set by the version attribute in the web app
+     * element
+     *
+     * @param majorVersion the major version.
+     */
+    public void setMajorVersion(int majorVersion) {
+        this.majorVersion = majorVersion;
+    }
+
+    /**
+     * Gets the minor version as set by the version attribute in the web app
+     * element
+     *
+     * @return the major version.
+     */
+    public int getMinorVersion() {
+        return minorVersion;
+    }
+
+    /**
+     * Sets the minor version as set by the version attribute in the web app
+     * element
+     *
+     * @param minorVersion the minor version.
+     */
+    public void setMinorVersion(int minorVersion) {
+        this.minorVersion = minorVersion;
+    }
+
+    /**
+     * Set the metadata complete flag.
+     *
+     * @param metadataComplete the metadata complete
+     */
+    public void setMetadataComplete(boolean metadataComplete) {
+        this.metadataComplete = metadataComplete;
+    }
+
+    /**
+     * Get the metadata complete flag.
+     *
+     * @return the metadata complete
+     */
+    public boolean getMetadataComplete() {
+        return metadataComplete;
+    }
+
+    /**
+     * Get the absolute ordering.
+     *
+     * @return the absolute ordering.
+     */
+    public List<String> getAbsoluteOrdering() {
+        return absoluteOrdering;
+    }
+
+    /**
+     * Get the relative ordering.
+     *
+     * @return the relative ordering.
+     */
+    public RelativeOrder getRelativeOrdering() {
+        return relativeOrdering;
+    }
+
+    /**
+     * Set the absolute ordering.
+     *
+     * @param absoluteOrdering the absolute ordering.
+     */
+    public void setAbsoluteOrdering(List<String> absoluteOrdering) {
+        this.absoluteOrdering = absoluteOrdering;
+    }
+
+    /**
+     * Set the relative ordering.
+     *
+     * @param relativeOrdering the relative ordering.
+     */
+    public void setRelativeOrdering(RelativeOrder relativeOrdering) {
+        this.relativeOrdering = relativeOrdering;
+    }
+
+    /**
+     * Get the locale encoding mapping.
+     *
+     * @return the locale encoding mapping.
+     */
+    public Map<String, String> getLocaleEncodingMapping() {
+        return this.localeEncodingMapping;
+    }
+
+    /**
+     * Set the locale encoding mapping.
+     *
+     * @param localeEncodingMapping the locale encoding mapping.
+     */
+    public void setLocaleEncodingMapping(Map<String, String> localeEncodingMapping) {
+        this.localeEncodingMapping = localeEncodingMapping;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlContextParam.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlContextParam.java
new file mode 100644
index 00000000..9f65ef76
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlContextParam.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml context-param.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlContextParam {
+
+    /**
+     * Stores the name.
+     */
+    private final String name;
+
+    /**
+     * Stores the value.
+     */
+    private final String value;
+
+    /**
+     * Constructor.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    public WebXmlContextParam(String name, String value) {
+        this.name = name;
+        this.value = value;
+    }
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    public String getValue() {
+        return value;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlCookieConfig.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlCookieConfig.java
new file mode 100644
index 00000000..ca05a65a
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlCookieConfig.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml session-config cookie-config.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlCookieConfig {
+
+    /**
+     * Stores the cookie name.
+     */
+    private String name;
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Set the name.
+     *
+     * @param name the name.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlErrorPage.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlErrorPage.java
new file mode 100644
index 00000000..e9c66885
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlErrorPage.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml error-page.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlErrorPage  {
+
+    /**
+     * Stores the error code.
+     */
+    private final String errorCode;
+
+    /**
+     * Stores the exception type.
+     */
+    private final String exceptionType;
+
+    /**
+     * Stores the location.
+     */
+    private final String location;
+
+    /**
+     * Constructor.
+     *
+     * @param errorCode the error code.
+     * @param exceptionType the exception type.
+     * @param location the location.
+     */
+    public WebXmlErrorPage(String errorCode, String exceptionType, String location) {
+        this.errorCode = errorCode;
+        this.exceptionType = exceptionType;
+        this.location = location;
+    }
+
+    /**
+     * Get the error code.
+     *
+     * @return the error code.
+     */
+    public String getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Get the exception type.
+     *
+     * @return the exception type.
+     */
+    public String getExceptionType() {
+        return exceptionType;
+    }
+
+    /**
+     * Get the location.
+     *
+     * @return the location.
+     */
+    public String getLocation() {
+        return location;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilter.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilter.java
new file mode 100644
index 00000000..4ccb263e
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilter.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The web.xml filter.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlFilter {
+
+    /**
+     * Stores the class name.
+     */
+    private String className;
+
+    /**
+     * Stores the filter name.
+     */
+    private String filterName;
+
+    /**
+     * Stores the init params.
+     */
+    private final List<WebXmlFilterInitParam> initParams = new ArrayList<>();
+
+    /**
+     * Stores the servlet name.
+     */
+    private String servletName;
+
+    /**
+     * Stores if async is supported.
+     */
+    private boolean asyncSupported;
+
+    /**
+     * Add init param.
+     *
+     * @param initParam the init param.
+     */
+    public void addInitParam(WebXmlFilterInitParam initParam) {
+        this.initParams.add(initParam);
+    }
+
+    /**
+     * Get the class name.
+     *
+     * @return the class name.
+     */
+    public String getClassName() {
+        return className;
+    }
+
+    /**
+     * Get the filter name.
+     *
+     * @return the filter name.
+     */
+    public String getFilterName() {
+        return filterName;
+    }
+
+    /**
+     * Get the init params.
+     *
+     * @return the init params.
+     */
+    public List<WebXmlFilterInitParam> getInitParams() {
+        return initParams;
+    }
+
+    /**
+     * Get the servlet name.
+     *
+     * @return the servlet name.
+     */
+    public String getServletName() {
+        return servletName;
+    }
+
+
+    /**
+     * Is async supported.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isAsyncSupported() {
+        return asyncSupported;
+    }
+
+    /**
+     * Set the class name.
+     *
+     * @param className the class name.
+     */
+    public void setClassName(String className) {
+        this.className = className;
+    }
+
+    /**
+     * Set the filter name.
+     *
+     * @param filterName the filter name.
+     */
+    public void setFilterName(String filterName) {
+        this.filterName = filterName;
+    }
+
+    /**
+     * Set the servlet name.
+     *
+     * @param servletName the servlet name.
+     */
+    public void setServletName(String servletName) {
+        this.servletName = servletName;
+    }
+
+    /**
+     * Set if async is supported.
+     *
+     * @param asyncSupported the boolean value.
+     */
+    public void setAsyncSupported(boolean asyncSupported) {
+        this.asyncSupported = asyncSupported;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilterInitParam.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilterInitParam.java
new file mode 100644
index 00000000..4cb4e8df
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilterInitParam.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml filter init-param.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlFilterInitParam {
+
+    /**
+     * Stores the name.
+     */
+    private String name;
+
+    /**
+     * Stores the value.
+     */
+    private String value;
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    public String getValue() {
+        return value;
+    }
+
+    /**
+     * Set the name.
+     *
+     * @param name the name.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Set the value.
+     *
+     * @param value the value.
+     */
+    public void setValue(String value) {
+        this.value = value;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilterMapping.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilterMapping.java
new file mode 100644
index 00000000..3db2c52b
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlFilterMapping.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The web.xml filter-mapping.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlFilterMapping {
+
+    /**
+     * Stores the filter name.
+     */
+    private String filterName;
+
+    /**
+     * Stores the URL pattern.
+     */
+    private final List<String> urlPatterns = new ArrayList<>();
+
+
+    /**
+     * Names of the Servlets to which a filter is mapped
+     */
+    private final List<String> servletNames = new ArrayList<>();
+
+    /**
+     * The type of dispatch on which the filter is invoked. Valid values:
+     * FORWARD
+     * INCLUDE
+     * REQUEST
+     * ERROR
+     */
+    private final List<String> dispatchers = new ArrayList<>();
+
+    /**
+     * Constructor.
+     *
+     * @param filterName the filter name.
+     */
+    public WebXmlFilterMapping(String filterName) {
+        this.filterName = filterName;
+    }
+
+    /**
+     * Get the filter name.
+     *
+     * @return the filter name.
+     */
+    public String getFilterName() {
+        return filterName;
+    }
+
+    /**
+     * Get the URL patterns.
+     *
+     * @return the URL patterns.
+     */
+    public List<String> getUrlPatterns() {
+        return urlPatterns;
+    }
+
+    /**
+     * Get the Servlet names.
+     *
+     * @return the Servlet names.
+     */
+    public List<String> getServletNames() {
+        return servletNames;
+    }
+
+    /**
+     * Get the dispatchers.
+     *
+     * @return the dispatchers.
+     */
+    public List<String> getDispatchers() {
+        return dispatchers;
+    }
+}
+
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlListener.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlListener.java
new file mode 100644
index 00000000..092cb627
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlListener.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml listener.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlListener {
+
+    /**
+     * Stores the class name.
+     */
+    String className;
+
+    /**
+     * Constructor.
+     *
+     * @param className the class name.
+     */
+    public WebXmlListener(String className) {
+        this.className = className;
+    }
+
+    /**
+     * Get the class name.
+     *
+     * @return the class name.
+     */
+    public String getClassName() {
+        return className;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlLoginConfig.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlLoginConfig.java
new file mode 100644
index 00000000..c294c3ac
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlLoginConfig.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml login-config.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlLoginConfig {
+
+    /**
+     * Stores the auth method.
+     */
+    private final String authMethod;
+
+    /**
+     * Stores the realm name.
+     */
+    private final String realmName;
+
+    /**
+     * Stores the form login page.
+     */
+    private final String formLoginPage;
+
+    /**
+     * Stores the form error page.
+     */
+    private final String formErrorPage;
+
+    /**
+     * Constructor.
+     *
+     * @param authMethod the auth method.
+     * @param realmName the realm name.
+     * @param formLoginPage the form login page.
+     * @param formErrorPage the form error page.
+     */
+    public WebXmlLoginConfig(String authMethod, String realmName, String formLoginPage, String formErrorPage) {
+        this.authMethod = authMethod;
+        this.realmName = realmName;
+        this.formLoginPage = formLoginPage;
+        this.formErrorPage = formErrorPage;
+    }
+
+    /**
+     * Get the auth method.
+     *
+     * @return the auth method.
+     */
+    public String getAuthMethod() {
+        return authMethod;
+    }
+
+    /**
+     * Get the realm name.
+     *
+     * @return the realm name.
+     */
+    public String getRealmName() {
+        return realmName;
+    }
+
+    /**
+     * Get the form login page.
+     *
+     * @return the form login page.
+     */
+    public String getFormLoginPage() {
+        return formLoginPage;
+    }
+
+    /**
+     * Get the form error page.
+     *
+     * @return the form error page.
+     */
+    public String getFormErrorPage() {
+        return formErrorPage;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlManager.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlManager.java
new file mode 100644
index 00000000..e4e5cfe6
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlManager.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+
+import static cloud.piranha.servlet4.impl.WebXml.OTHERS_TAG;
+
+/**
+ * The web.xml manager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlManager {
+
+    /**
+     * Stores the application scoped key.
+     */
+    public static final String KEY = WebXmlManager.class.getName();
+
+    /**
+     * Stores the initial web.xml
+     */
+    private WebXml initialWebXml;
+
+    /**
+     * Stores the web fragments.
+     */
+    private List<WebXml> webFragments = new ArrayList<>();
+
+    /**
+     * Stores the web.xml.
+     */
+    private WebXml webXml;
+
+    /**
+     * Get the initial web.xml.
+     *
+     * @return the initial web.xml.
+     */
+    public WebXml getInitialWebXml() {
+        return initialWebXml;
+    }
+
+    /**
+     * Set the initial web.xml.
+     *
+     * @param initialWebXml the initial web.xml.
+     */
+    public void setInitialWebXml(WebXml initialWebXml) {
+        this.initialWebXml = initialWebXml;
+    }
+
+    /**
+     * Get the web fragments.
+     *
+     * @return the web fragments.
+     */
+    public List<WebXml> getWebFragments() {
+        return webFragments;
+    }
+
+    /**
+     * Set the web fragments.
+     *
+     * @param webFragments the web fragments.
+     */
+    public void setWebFragments(List<WebXml> webFragments) {
+        this.webFragments = webFragments;
+    }
+
+    /**
+     * Get the web.xml.
+     *
+     * @return the web.xml.
+     */
+    public WebXml getWebXml() {
+        return webXml;
+    }
+
+    /**
+     * Set the web.xml.
+     *
+     * @param webXml the web.xml.
+     */
+    public void setWebXml(WebXml webXml) {
+        this.webXml = webXml;
+    }
+
+    /**
+     * Get the ordered fragments.
+     * 
+     * @return the ordered fragments.
+     */
+    public List<WebXml> getOrderedFragments() {
+        if (webXml == null)
+            return Collections.emptyList();
+        if (webXml.getAbsoluteOrdering() != null) {
+            return processAbsoluteOrdering();
+        }
+        return processRelativeOrdering();
+    }
+
+    private List<WebXml> processAbsoluteOrdering() {
+        List<String> absoluteOrdering = webXml.getAbsoluteOrdering().stream().distinct().collect(Collectors.toUnmodifiableList());
+        if (absoluteOrdering.isEmpty())
+            return Collections.emptyList();
+
+        if (!absoluteOrdering.contains(OTHERS_TAG)) {
+            return getWebFragments()
+                    .stream()
+                    .filter(x -> absoluteOrdering.contains(x.getFragmentName()))
+                    .sorted(Comparator.comparingInt(x -> absoluteOrdering.indexOf(x.getFragmentName())))
+                    .collect(Collectors.toUnmodifiableList());
+        }
+
+        int indexOfOthersTag = absoluteOrdering.indexOf(OTHERS_TAG);
+
+        List<String> fragmentsBeforeOthers = absoluteOrdering.stream()
+            .filter(x -> absoluteOrdering.indexOf(x) < indexOfOthersTag)
+            .collect(Collectors.toList());
+
+        List<String> fragmentsAfterOthers = absoluteOrdering.stream()
+            .filter(x -> absoluteOrdering.indexOf(x) > indexOfOthersTag)
+            .collect(Collectors.toList());
+
+        List<String> othersFragments = getWebFragments()
+                .stream()
+                .map(WebXml::getFragmentName)
+                .filter(x -> !fragmentsAfterOthers.contains(x) && !fragmentsBeforeOthers.contains(x))
+                .collect(Collectors.toList());
+
+        List<WebXml> orderedFragments = new ArrayList<>();
+        for (String fragmentName : absoluteOrdering) {
+            if (OTHERS_TAG.equals(fragmentName)) {
+                orderedFragments.addAll(toWebXml(othersFragments));
+                continue;
+            }
+            findWebFragment(fragmentName).ifPresent(orderedFragments::add);
+        }
+        return orderedFragments;
+    }
+
+    private List<WebXml> toWebXml(List<String> fragmentNames) {
+        return getWebFragments().stream().filter(x -> fragmentNames.contains(x.getFragmentName())).collect(Collectors.toList());
+    }
+
+    private Optional<WebXml> findWebFragment(String fragmentName) {
+        return getWebFragments().stream().filter(x -> fragmentName.equals(x.getFragmentName())).findFirst();
+    }
+
+    private List<WebXml> processRelativeOrdering() {
+        if (webFragments.stream().noneMatch(x -> x.getRelativeOrdering() != null)) {
+            return webFragments;
+        }
+
+        List<WebXml> sorted = new ArrayList<>(webFragments);
+        Set<WebXml> others = new LinkedHashSet<>();
+        Set<WebXml> beforeOthers = new LinkedHashSet<>();
+        Set<WebXml> afterOthers = new LinkedHashSet<>();
+
+        // Separate the fragments that are before/after others and the others
+        webFragments.forEach(webFragment -> {
+            WebXml.RelativeOrder relativeOrdering = webFragment.getRelativeOrdering();
+            if (relativeOrdering == null) {
+                others.add(webFragment);
+                return;
+            }
+            List<String> after = relativeOrdering.getAfter();
+            List<String> before = relativeOrdering.getBefore();
+            if (after.contains(OTHERS_TAG)) {
+                afterOthers.add(webFragment);
+                return;
+            }
+            if (before.contains(OTHERS_TAG)) {
+                beforeOthers.add(webFragment);
+                return;
+            }
+            others.add(webFragment);
+        });
+
+        TopologicalSort<WebXml> topologicalSort = new TopologicalSort<>();
+
+        // Add the dependencies of each fragment
+        Set<WebXml> referenced = new LinkedHashSet<>();
+        for (WebXml webFragment : webFragments) {
+            if (webFragment.getRelativeOrdering() != null) {
+                WebXml.RelativeOrder relativeOrdering = webFragment.getRelativeOrdering();
+
+                for (String afterName : relativeOrdering.getAfter()) {
+                    findWebFragment(afterName).ifPresent(fragment -> {
+                        topologicalSort.addDependency(webFragment, fragment);
+                        referenced.add(fragment);
+                    });
+                }
+
+                for (String beforeName : relativeOrdering.getBefore()) {
+                    findWebFragment(beforeName).ifPresent(fragment -> {
+                        topologicalSort.addDependency(fragment, webFragment);
+                        referenced.add(fragment);
+                    });
+                }
+
+                if (relativeOrdering.getBefore().contains(OTHERS_TAG)) {
+                    Consumer<WebXml> addBefore = other -> {
+                        if (!referenced.contains(other)) {
+                            topologicalSort.addDependency(other, webFragment);
+                        }
+                    };
+                    others.forEach(addBefore);
+                    afterOthers.forEach(addBefore);
+                }
+                if (relativeOrdering.getAfter().contains(OTHERS_TAG)) {
+                    Consumer<WebXml> addAfter = other -> {
+                        if (!referenced.contains(other)) {
+                            topologicalSort.addDependency(webFragment, other);
+                        }
+                    };
+                    beforeOthers.forEach(addAfter);
+                    others.forEach(addAfter);
+                }
+            }
+            referenced.clear();
+        }
+
+        return topologicalSort.sort(sorted);
+    }
+
+    private static class TopologicalSort<T> {
+
+        /**
+         * Stores the dependencies.
+         */
+        private final Map<T, Set<T>> dependencies = new HashMap<>();
+
+        public void addDependency(T dependant, T dependency) {
+            Set<T> set = dependencies.computeIfAbsent(dependant, k -> new LinkedHashSet<>());
+            Collections.addAll(set, dependency);
+        }
+        public List<T> sort(List<T> list) {
+            Set<T> visited = new HashSet<>();
+            List<T> sorted = new ArrayList<>();
+
+            for (T item : list) {
+                visit(item, visited, sorted);
+            }
+            return sorted;
+        }
+
+        private void visit(T item, Set<T> visited, List<T> sorted) {
+            if (!visited.contains(item)) {
+                visited.add(item);
+                Set<T> edges = this.dependencies.get(item);
+                if (edges != null)
+                    edges.forEach(dependency -> visit(dependency, visited, sorted));
+                sorted.add(item);
+            } else if (!sorted.contains(item))
+                throw new IllegalStateException("Invalid dependency cyclic");
+        }
+    }
+
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlMimeMapping.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlMimeMapping.java
new file mode 100644
index 00000000..e0be78e4
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlMimeMapping.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml mime-mapping.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlMimeMapping {
+
+    /**
+     * Stores the extension.
+     */
+    private final String extension;
+
+    /**
+     * Stores the mime type.
+     */
+    private final String mimeType;
+
+    /**
+     * Constructor.
+     *
+     * @param extension the extension.
+     * @param mimeType the mime type.
+     */
+    public WebXmlMimeMapping(String extension, String mimeType) {
+        this.extension = extension;
+        this.mimeType = mimeType;
+    }
+
+    /**
+     * Get the extension.
+     *
+     * @return the extension.
+     */
+    public String getExtension() {
+        return extension;
+    }
+
+    /**
+     * Get the mime type.
+     *
+     * @return the mime type.
+     */
+    public String getMimeType() {
+        return mimeType;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServlet.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServlet.java
new file mode 100644
index 00000000..60f4b8db
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServlet.java
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The web.xml servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlServlet {
+
+    /**
+     * Stores if async is supported.
+     */
+    private boolean asyncSupported;
+
+    /**
+     * Stores the class name.
+     */
+    private String className;
+
+    /**
+     * Stores the init params.
+     */
+    private final List<WebXmlServletInitParam> initParams = new ArrayList<>();
+
+    /**
+     * Stores the security role refs.
+     */
+    private final List<WebXmlServletSecurityRoleRef> securityRoleRefs = new ArrayList<>();
+
+    /**
+     * Stores the servlet name.
+     */
+    private String servletName;
+
+    /**
+     * Stores the JSP file
+     */
+    private String jspFile;
+
+    /**
+     * Add init param.
+     *
+     * @param initParam the init param.
+     */
+    public void addInitParam(WebXmlServletInitParam initParam) {
+        this.initParams.add(initParam);
+    }
+
+    /**
+     * Get the class name.
+     *
+     * @return the class name.
+     */
+    public String getClassName() {
+        return className;
+    }
+
+    /**
+     * Get the init params.
+     *
+     * @return the init params.
+     */
+    public List<WebXmlServletInitParam> getInitParams() {
+        return initParams;
+    }
+
+    /**
+     * Get the security role refs.
+     *
+     * @return the security role refs.
+     */
+    public List<WebXmlServletSecurityRoleRef> getSecurityRoleRefs() {
+        return securityRoleRefs;
+    }
+
+    /**
+     * Is async supported.
+     *
+     * @return true if it is, false otherwise.
+     */
+    public boolean isAsyncSupported() {
+        return asyncSupported;
+    }
+
+    /**
+     * Get the servlet name.
+     *
+     * @return the servlet name.
+     */
+    public String getServletName() {
+        return servletName;
+    }
+
+    /**
+     * Set the class name.
+     *
+     * @param className the class name.
+     */
+    public void setClassName(String className) {
+        this.className = className;
+    }
+
+    /**
+     * Set if async is supported.
+     *
+     * @param asyncSupported the boolean value.
+     */
+    public void setAsyncSupported(boolean asyncSupported) {
+        this.asyncSupported = asyncSupported;
+    }
+
+    /**
+     * Set the servlet name.
+     *
+     * @param servletName the servlet name.
+     */
+    public void setServletName(String servletName) {
+        this.servletName = servletName;
+    }
+
+    /**
+     * Get the jsp file
+     *
+     * @return the jsp file
+     */
+    public String getJspFile() {
+        return jspFile;
+    }
+
+    /**
+     * Set the JSP file
+     *
+     * @param jspFile - the JSP file
+     */
+    public void setJspFile(String jspFile) {
+        this.jspFile = jspFile;
+    }
+
+    /**
+     * Return string representation.
+     *
+     * @return the string representation.
+     */
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        builder.append("Servlet[");
+        builder.append("servletName=").append(servletName).append(",");
+        builder.append("className=").append(className).append(",");
+        builder.append("jspFile=").append(jspFile).append(",");
+        builder.append("asyncSupported=").append(asyncSupported).append("]");
+        return builder.toString();
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletInitParam.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletInitParam.java
new file mode 100644
index 00000000..f5ef39cb
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletInitParam.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml servlet init-param.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlServletInitParam {
+
+    /**
+     * Stores the name.
+     */
+    private String name;
+
+    /**
+     * Stores the value.
+     */
+    private String value;
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    public String getValue() {
+        return value;
+    }
+
+    /**
+     * Set the name.
+     *
+     * @param name the name.
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Set the value.
+     *
+     * @param value the value.
+     */
+    public void setValue(String value) {
+        this.value = value;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletMapping.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletMapping.java
new file mode 100644
index 00000000..413ead06
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletMapping.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml servlet-mapping
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlServletMapping {
+
+    /**
+     * Stores the servlet name.
+     */
+    private final String servletName;
+
+    /**
+     * Stores the URL pattern.
+     */
+    private final String urlPattern;
+
+    /**
+     * Constructor.
+     *
+     * @param servletName the servlet name.
+     * @param urlPattern the URL pattern.
+     */
+    public WebXmlServletMapping(String servletName, String urlPattern) {
+        this.servletName = servletName;
+        this.urlPattern = urlPattern;
+    }
+
+    /**
+     * Get the servlet name.
+     *
+     * @return the servlet name.
+     */
+    public String getServletName() {
+        return servletName;
+    }
+
+    /**
+     * Get the URL pattern.
+     *
+     * @return the URL pattern.
+     */
+    public String getUrlPattern() {
+        return urlPattern;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletSecurityRoleRef.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletSecurityRoleRef.java
new file mode 100644
index 00000000..1ac16763
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlServletSecurityRoleRef.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml servlet security-role-ref element.
+ *
+ * @author Arjan Tijms
+ */
+public class WebXmlServletSecurityRoleRef {
+
+    /**
+     * The role scoped to a specific servlet, and the role uses in <code>isUser/CallerInRole</code> methods.
+     */
+    private String roleName;
+
+    /**
+     * The "global" application role, as defined by <code>declareRoles</code> or <code>security-role</code>
+     */
+    private String roleLink;
+
+    /**
+     * Get the role name.
+     * 
+     * @return the role name.
+     */
+    public String getRoleName() {
+        return roleName;
+    }
+
+    /**
+     * Set the role name.
+     * 
+     * @param roleName the role name.
+     */
+    public void setRoleName(String roleName) {
+        this.roleName = roleName;
+    }
+
+    /**
+     * Get the role link.
+     * 
+     * @return the role link.
+     */
+    public String getRoleLink() {
+        return roleLink;
+    }
+
+    /**
+     * Set the role link.
+     * 
+     * @param roleLink the role link.
+     */
+    public void setRoleLink(String roleLink) {
+        this.roleLink = roleLink;
+    }
+}
diff --git a/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlSessionConfig.java b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlSessionConfig.java
new file mode 100644
index 00000000..b097c71b
--- /dev/null
+++ b/servlet4/impl/src/main/java/cloud/piranha/servlet4/impl/WebXmlSessionConfig.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+/**
+ * The web.xml session-config.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlSessionConfig {
+
+    /**
+     * Stores the session timeout.
+     */
+    private int sessionTimeout;
+
+    /**
+     * Get the session timeout.
+     *
+     * @return the session timeout.
+     */
+    public int getSessionTimeout() {
+        return sessionTimeout;
+    }
+
+    /**
+     * Set the session timeout.
+     *
+     * @param sessionTimeout the session timeout.
+     */
+    public void setSessionTimeout(int sessionTimeout) {
+        this.sessionTimeout = sessionTimeout;
+    }
+}
diff --git a/webapp/impl/src/test/java/module-info.java b/servlet4/impl/src/main/java/module-info.java
similarity index 83%
rename from webapp/impl/src/test/java/module-info.java
rename to servlet4/impl/src/main/java/module-info.java
index 5dee7756..a9964eb7 100644
--- a/webapp/impl/src/test/java/module-info.java
+++ b/servlet4/impl/src/main/java/module-info.java
@@ -26,23 +26,20 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-module cloud.piranha.webapp.impl.tests {
+module cloud.piranha.servlet4.impl {
     
-    exports cloud.piranha.webapp.impl.tests;
-    
-    opens cloud.piranha.webapp.impl.tests;
-    
-    requires cloud.piranha.http.api;
+    exports cloud.piranha.servlet4.impl;
+    opens cloud.piranha.servlet4.impl;
     requires cloud.piranha.naming.api;
     requires cloud.piranha.naming.impl;
     requires cloud.piranha.policy.api;
     requires cloud.piranha.policy.impl;
     requires cloud.piranha.resource.api;
     requires cloud.piranha.resource;
-    requires cloud.piranha.servlet.api;
-    requires cloud.piranha.webapp.api;
-    requires cloud.piranha.webapp.impl;
+    requires transitive cloud.piranha.servlet4.api;
+    requires transitive cloud.piranha.servlet4.webapp;
     requires java.logging;
-    requires jdk.security.auth;
-    requires org.junit.jupiter.api;
+
+    // Tests
+    requires static jdk.security.auth;
 }
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/AsyncContextTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/AsyncContextTest.java
new file mode 100644
index 00000000..589e33ca
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/AsyncContextTest.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequest;
+import cloud.piranha.servlet4.impl.DefaultAsyncContext;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationResponse;
+import org.junit.jupiter.api.Test;
+
+import java.io.ByteArrayOutputStream;
+
+/**
+ * The JUnit tests for the AsyncContext API.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class AsyncContextTest {
+    
+    /**
+     * Test dispatch method.
+     */
+    @Test
+    void testDispatch() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setWebApplication(webApp);
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+        response.setUnderlyingOutputStream(byteOutput);
+        response.setWebApplication(webApp);
+        DefaultAsyncContext context = new DefaultAsyncContext(request, response);
+        //context.dispatch();
+    }
+    
+    /**
+     * Test dispatch method.
+     */
+    @Test
+    void testDispatch2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setWebApplication(webApp);
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+        response.setUnderlyingOutputStream(byteOutput);
+        response.setWebApplication(webApp);
+        //DefaultAsyncContext context = new DefaultAsyncContext(request, response);
+        ///context.dispatch("/mypath");
+    }
+    
+    /**
+     * Test dispatch method.
+     */
+    @Test
+    void testDispatch3() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setWebApplication(webApp);
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+        response.setUnderlyingOutputStream(byteOutput);
+        response.setWebApplication(webApp);
+        //DefaultAsyncContext context = new DefaultAsyncContext(request, response);
+       /// context.dispatch(webApp, "/mypath");
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultAnnotationManagerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultAnnotationManagerTest.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultAnnotationManagerTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultAnnotationManagerTest.java
index 4c6cc98c..13d756a1 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultAnnotationManagerTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultAnnotationManagerTest.java
@@ -25,9 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultAnnotationManager;
+import cloud.piranha.servlet4.impl.DefaultAnnotationManager;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import org.junit.jupiter.api.Test;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultErrorPageManagerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultErrorPageManagerTest.java
similarity index 93%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultErrorPageManagerTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultErrorPageManagerTest.java
index 5d3efbca..bf4d28fe 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultErrorPageManagerTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultErrorPageManagerTest.java
@@ -1,10 +1,10 @@
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultErrorPageManager;
-import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
+import cloud.piranha.servlet4.impl.DefaultErrorPageManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationResponse;
 import org.junit.jupiter.api.Test;
 
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletException;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpHeaderManagerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpHeaderManagerTest.java
similarity index 98%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpHeaderManagerTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpHeaderManagerTest.java
index 33c22de1..396f077f 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpHeaderManagerTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpHeaderManagerTest.java
@@ -25,9 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultHttpHeaderManager;
+import cloud.piranha.servlet4.impl.DefaultHttpHeaderManager;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Enumeration;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpServletRequestTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpServletRequestTest.java
similarity index 96%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpServletRequestTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpServletRequestTest.java
index 65d93497..280aa1f5 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpServletRequestTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpServletRequestTest.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultSecurityManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequest;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequestMapper;
-import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequest;
+import cloud.piranha.servlet4.impl.DefaultSecurityManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequestMapper;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationResponse;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
@@ -41,12 +41,12 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpUpgradeHandler;
-import jakarta.servlet.http.WebConnection;
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpUpgradeHandler;
+import javax.servlet.http.WebConnection;
 
 import org.junit.jupiter.api.Test;
 
@@ -589,10 +589,7 @@ class DefaultHttpServletRequestTest {
         assertThrows(ServletException.class, () -> request.upgrade(TestThrowingHandler.class));
     }
 
-    public static class TestHandler implements HttpUpgradeHandler {
-
-        public TestHandler() {
-        }
+    static class TestHandler implements HttpUpgradeHandler {
 
         @Override
         public void init(WebConnection wc) {
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpServletResponseTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpServletResponseTest.java
similarity index 98%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpServletResponseTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpServletResponseTest.java
index 80f34c60..871d8c3f 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpServletResponseTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpServletResponseTest.java
@@ -25,11 +25,11 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
-import jakarta.servlet.http.HttpServletResponse;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationResponse;
+import javax.servlet.http.HttpServletResponse;
 import java.util.Locale;
 
 import org.junit.jupiter.api.Test;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpSessionManagerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpSessionManagerTest.java
similarity index 97%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpSessionManagerTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpSessionManagerTest.java
index cb3534ae..2adfc423 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpSessionManagerTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpSessionManagerTest.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import jakarta.servlet.SessionTrackingMode;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpSession;
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpSession;
 import static org.junit.jupiter.api.Assertions.*;
 import org.junit.jupiter.api.Test;
 
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpSessionTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpSessionTest.java
new file mode 100644
index 00000000..db5a997c
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultHttpSessionTest.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultHttpSession;
+import static org.junit.jupiter.api.Assertions.*;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the DefaultHttpSession class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultHttpSessionTest {
+
+    /**
+     * Test getAttribute method.
+     */
+    @Test
+    void testGetAttribute() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setSessionManager(new DefaultHttpSessionManager());
+        session.setAttribute("TEST", "TEST");
+        assertEquals("TEST", session.getAttribute("TEST"));
+        session.removeAttribute("TEST");
+        assertNull(session.getAttribute("TEST"));
+    }
+
+    /**
+     * Test getAttributeNames method.
+     */
+    @Test
+    void testGetAttributeNames() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        assertFalse(session.getAttributeNames().hasMoreElements());
+    }
+
+    /**
+     * Test getCreationTime method.
+     */
+    @Test
+    void testGetCreationTime() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        assertTrue(session.getCreationTime() > 0);
+    }
+
+    /**
+     * Test getId method.
+     */
+    @Test
+    void testGetId() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setId("ID");
+        assertEquals("ID", session.getId());
+    }
+
+    /**
+     * Test getLastAccessedTime method.
+     */
+    @Test
+    void testGetLastAccessedTime() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        assertTrue(session.getCreationTime() > 0);
+        assertTrue(session.getLastAccessedTime() >= session.getCreationTime());
+    }
+
+    /**
+     * Test getMaxInactiveInterval method.
+     */
+    @Test
+    void testGetMaxInactiveInterval() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setMaxInactiveInterval(1000);
+        assertEquals(1000, session.getMaxInactiveInterval());
+    }
+
+    /**
+     * Test getServletContext method.
+     */
+    @Test
+    void testGetServletContext() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setSessionManager(webApp.getHttpSessionManager());
+        assertNotNull(session.getServletContext());
+    }
+
+    /**
+     * Test getSessionContext method.
+     */
+    @Test
+    void testGetSessionContext() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        assertNull(session.getSessionContext());
+    }
+
+    /**
+     * Test getSessionManager method.
+     */
+    @Test
+    void testGetSessionManager() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setSessionManager(new DefaultHttpSessionManager());
+    }
+
+    /**
+     * Test getValue method.
+     */
+    @Test
+    void testGetValue() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setSessionManager(new DefaultHttpSessionManager());
+        session.putValue("TEST", "TEST");
+        assertEquals("TEST", session.getValue("TEST"));
+        session.removeValue("TEST");
+        assertNull(session.getValue("TEST"));
+    }
+
+    /**
+     * Test getValueNames method.
+     */
+    @Test
+    void testGetValueNames() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        assertTrue(session.getValueNames().length == 0);
+    }
+
+    /**
+     * Test invalidate method.
+     */
+    @Test
+    void testInvalidate() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setSessionManager(new DefaultHttpSessionManager());
+        session.invalidate();
+    }
+
+    /**
+     * Test invalidate method.
+     *
+     * @throws IllegalStateException when the session is invalid.
+     */
+    @Test
+    void testInvalidate2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setSessionManager(new DefaultHttpSessionManager());
+        session.invalidate();
+        assertThrows(IllegalStateException.class, () -> session.setAttribute("TEST", "TEST"));
+    }
+
+    /**
+     * Test isNew method.
+     */
+    @Test
+    void testIsNew() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setNew(true);
+        assertTrue(session.isNew());
+        session.setNew(false);
+        assertFalse(session.isNew());
+    }
+
+    /**
+     * Test setAttribute method.
+     */
+    @Test
+    void testSetAttribute() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSession session = new DefaultHttpSession(webApp);
+        session.setSessionManager(new DefaultHttpSessionManager());
+        session.setAttribute("TEST", "TEST");
+        session.setAttribute("TEST", null);
+        assertNull(session.getAttribute("TEST"));
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultMultiPartManagerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultMultiPartManagerTest.java
similarity index 92%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultMultiPartManagerTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultMultiPartManagerTest.java
index bf617aff..d6ec6c06 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultMultiPartManagerTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultMultiPartManagerTest.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultMultiPartManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequest;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequest;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultMultiPartManager;
 import java.util.Collection;
-import jakarta.servlet.http.Part;
+import javax.servlet.http.Part;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import org.junit.jupiter.api.Test;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultSecurityManagerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultSecurityManagerTest.java
similarity index 96%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultSecurityManagerTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultSecurityManagerTest.java
index d9179698..ba75c5d1 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultSecurityManagerTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultSecurityManagerTest.java
@@ -25,15 +25,15 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultSecurityManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultSecurityManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
 import com.sun.security.auth.UserPrincipal;
 import java.io.IOException;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletRequestWrapper;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
 
 import org.junit.jupiter.api.Test;
 
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultSecurityPrincipalTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultSecurityPrincipalTest.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultSecurityPrincipalTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultSecurityPrincipalTest.java
index dab6f96c..c945054f 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultSecurityPrincipalTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultSecurityPrincipalTest.java
@@ -25,9 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultSecurityPrincipal;
+import cloud.piranha.servlet4.impl.DefaultSecurityPrincipal;
 import org.junit.jupiter.api.Test;
 
 import static org.junit.jupiter.api.Assertions.*;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultServletEnvironmentTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultServletEnvironmentTest.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultServletEnvironmentTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultServletEnvironmentTest.java
index 4178d815..9fcc13fd 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultServletEnvironmentTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultServletEnvironmentTest.java
@@ -25,10 +25,10 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultServletEnvironment;
-import jakarta.servlet.MultipartConfigElement;
+import cloud.piranha.servlet4.impl.DefaultServletEnvironment;
+import javax.servlet.MultipartConfigElement;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultServletRequestDispatcherTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultServletRequestDispatcherTest.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultServletRequestDispatcherTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultServletRequestDispatcherTest.java
index 4525671f..a2ded718 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultServletRequestDispatcherTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultServletRequestDispatcherTest.java
@@ -25,18 +25,18 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequest;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequestMapper;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequest;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequestMapper;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
 import java.io.IOException;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.UnavailableException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.UnavailableException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.junit.jupiter.api.Test;
 
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationClassLoaderTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationClassLoaderTest.java
similarity index 96%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationClassLoaderTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationClassLoaderTest.java
index e168ca2a..8a96cdff 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationClassLoaderTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationClassLoaderTest.java
@@ -25,9 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplicationClassLoader;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationClassLoader;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationExtensionContextTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationExtensionContextTest.java
new file mode 100644
index 00000000..4f81256c
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationExtensionContextTest.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationExtensionContext;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import java.util.Set;
+
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationExtension;
+import cloud.piranha.servlet4.webapp.WebApplicationExtensionContext;
+
+/**
+ * The JUnit tests for the DefaultWebApplicationExtensionContext.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultWebApplicationExtensionContextTest {
+
+    /**
+     * Test add method.
+     */
+    @Test
+    void testAdd() {
+        DefaultWebApplicationExtensionContext context = new DefaultWebApplicationExtensionContext();
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        context.add(TestExtension.class);
+        context.configure(webApplication);
+        webApplication.initialize();
+        assertNotNull(webApplication.getAttribute(TestInitializer.class.getName()));
+    }
+
+    /**
+     * Test remove method.
+     */
+    @Test
+    void testRemove() {
+        DefaultWebApplicationExtensionContext context = new DefaultWebApplicationExtensionContext();
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        context.add(Test3Extension.class);
+        context.configure(webApplication);
+        webApplication.initialize();
+        assertNull(webApplication.getAttribute(TestInitializer.class.getName()));
+    }
+
+    /**
+     * A test extension.
+     */
+    static class TestExtension implements WebApplicationExtension {
+
+        /**
+         * Configure the web application.
+         *
+         * @param webApplication the web application.
+         */
+        @Override
+        public void configure(WebApplication webApplication) {
+            webApplication.addInitializer(TestInitializer.class.getName());
+        }
+    }
+
+    /**
+     * A test extension.
+     */
+    static class Test2Extension implements WebApplicationExtension {
+
+        /**
+         * Extend the web application.
+         *
+         * @param context the context.
+         */
+        @Override
+        public void extend(WebApplicationExtensionContext context) {
+            context.remove(TestExtension.class);
+        }
+    }
+
+    /**
+     * A test extension.
+     */
+    static class Test3Extension implements WebApplicationExtension {
+
+        /**
+         * Extend the web application.
+         *
+         * @param context the context.
+         */
+        @Override
+        public void extend(WebApplicationExtensionContext context) {
+            context.add(TestExtension.class);
+            context.add(Test2Extension.class);
+        }
+    }
+
+    /**
+     * A test servlet container initializer.
+     */
+    static class TestInitializer implements ServletContainerInitializer {
+
+        /**
+         * On startup.
+         *
+         * @param classes the list of annotated classes.
+         * @param servletContext the Servlet context.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
+            servletContext.setAttribute(TestInitializer.class.getName(), true);
+        }
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapperTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapperTest.java
new file mode 100644
index 00000000..8d79c161
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationRequestMapperTest.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequestMapper;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequestMapping;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.Collection;
+import java.util.Set;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * The tests for the ServletRequestMapper class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultWebApplicationRequestMapperTest {
+
+    /**
+     * Test findExactServletMatch method.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testFindExactServletMatch() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("echo", new TestEcho1Servlet());
+        webApp.addServletMapping("echo", "/echo");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setBodyOnly(true);
+        webApp.service(request, response);
+        assertEquals("ECHO", new String(response.getResponseBytes()));
+    }
+
+    /**
+     * Test findExtensionServletMatch method.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testFindExtensionServletMatch() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("echo", new TestEcho1Servlet());
+        webApp.addServletMapping("echo", "*.echo");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo.echo");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setBodyOnly(true);
+        webApp.service(request, response);
+        assertEquals("ECHO", new String(response.getResponseBytes()));
+    }
+
+    /**
+     * Test findServletPrefixMatch method.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testFindPrefixServletMatch3() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("echo", new TestEcho1Servlet());
+        webApp.addServletMapping("echo", "/echo/*");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo2/test.echo");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setBodyOnly(true);
+        webApp.service(request, response);
+        assertEquals(404, response.getStatus());
+    }
+
+    /**
+     * Test findServletPrefixMatch method.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testFindPrefixServletMatch4() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("echo", new TestEcho1Servlet());
+        webApp.addServletMapping("echo", "/echo/*");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setBodyOnly(true);
+        webApp.service(request, response);
+        assertEquals("ECHO", new String(response.getResponseBytes()));
+    }
+
+    @Test
+    void testFindPrefixServletMatch5() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("echo", new TestEcho1Servlet());
+        webApp.addServletMapping("echo", "/echo/*");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo2");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setBodyOnly(true);
+        webApp.service(request, response);
+        assertEquals(404, response.getStatus());
+    }
+
+    /**
+     * Test findExtensionServletMatch method.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testFindExtensionServletMatch2() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("echo2", new TestEcho1Servlet());
+        webApp.addServletMapping("echo2", "*.echo2");
+        webApp.initialize();
+        webApp.start();
+
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo.echo");
+        request.setWebApplication(new DefaultWebApplication());
+
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        webApp.service(request, response);
+
+        assertTrue(response.getStatus() != 200);
+    }
+
+    /**
+     * Test findPrefixServletMatch method.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testFindPrefixServletMatch() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("echo", new TestEcho1Servlet());
+        webApp.addServletMapping("echo", "/echo/*");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo/test.echo");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setBodyOnly(true);
+        webApp.service(request, response);
+        assertEquals("ECHO", new String(response.getResponseBytes()));
+    }
+
+    /**
+     * Test findPrefixServletMatch method.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testFindPrefixServletMatch2() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("echo", new TestEcho1Servlet());
+        webApp.addServletMapping("echo", "/*");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo/test.echo");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setBodyOnly(true);
+        webApp.service(request, response);
+        assertEquals("ECHO", new String(response.getResponseBytes()));
+    }
+
+    /**
+     * Test addFilterMapping method.
+     */
+    @Test
+    void testAddFilterMapping() {
+        DefaultWebApplicationRequestMapper requestMapper = new DefaultWebApplicationRequestMapper();
+        Set<String> result = requestMapper.addFilterMapping("filter", "/*");
+        assertTrue(result.isEmpty());
+        Collection<String> filters = requestMapper.findFilterMappings("/one_two");
+        assertFalse(filters.isEmpty());
+    }
+
+    /**
+     * Test addFilterMapping method.
+     */
+    @Test
+    void testAddFilterMapping2() {
+        DefaultWebApplicationRequestMapper requestMapper = new DefaultWebApplicationRequestMapper();
+        Set<String> result = requestMapper.addFilterMapping("filter", "/exactly_this");
+        assertTrue(result.isEmpty());
+        Collection<String> filters = requestMapper.findFilterMappings("/exactly_this");
+        assertFalse(filters.isEmpty());
+    }
+
+    /**
+     * Test addFilterMapping method.
+     */
+    @Test
+    void testAddFilterMapping3() {
+        DefaultWebApplicationRequestMapper requestMapper = new DefaultWebApplicationRequestMapper();
+        Set<String> result = requestMapper.addFilterMapping("filter", "*.html");
+        assertTrue(result.isEmpty());
+        Collection<String> filters = requestMapper.findFilterMappings("/index.html");
+        assertFalse(filters.isEmpty());
+    }
+
+    /**
+     * Test addFilterMapping method.
+     */
+    @Test
+    void testAddFilterMapping4() {
+        DefaultWebApplicationRequestMapper requestMapper = new DefaultWebApplicationRequestMapper();
+        Set<String> result = requestMapper.addFilterMapping("filter", "*.html");
+        assertTrue(result.isEmpty());
+        result = requestMapper.addFilterMapping("filter", "*.html");
+        assertFalse(result.isEmpty());
+        Collection<String> filters = requestMapper.findFilterMappings("/index.html");
+        assertFalse(filters.isEmpty());
+    }
+
+    /**
+     * Test addFilterMapping method.
+     */
+    @Test
+    void testAddFilterMapping5() {
+        DefaultWebApplicationRequestMapper requestMapper = new DefaultWebApplicationRequestMapper();
+        Set<String> result = requestMapper.addFilterMapping("filter", "*.html");
+        assertTrue(result.isEmpty());
+        result = requestMapper.addFilterMapping("filter", "*.html");
+        assertFalse(result.isEmpty());
+        Collection<String> filters = requestMapper.findFilterMappings("/index.html?q=keyword");
+        assertFalse(filters.isEmpty());
+    }
+
+    /**
+     * Test addServletMapping method.
+     */
+    @Test
+    void testAddServletMapping() {
+        DefaultWebApplicationRequestMapper requestMapper = new DefaultWebApplicationRequestMapper();
+        Set<String> result = requestMapper.addServletMapping("servlet", "*.html");
+        assertTrue(result.isEmpty());
+        result = requestMapper.addServletMapping("servlet", "*.html");
+        assertTrue(result.isEmpty());
+        DefaultWebApplicationRequestMapping mapping = requestMapper.findServletMapping("/index.html?q=keyword");
+        assertNotNull(mapping);
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationTest.java
similarity index 97%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationTest.java
index 49b04c79..72b8566c 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/DefaultWebApplicationTest.java
@@ -25,8 +25,14 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
-
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultSecurityManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequestMapper;
+import cloud.piranha.servlet4.impl.DefaultServlet;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultMimeTypeManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationResponse;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
@@ -43,27 +49,21 @@ import java.util.Enumeration;
 import java.util.Locale;
 import java.util.Set;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.ServletContextEvent;
-import jakarta.servlet.ServletContextListener;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.ServletRegistration.Dynamic;
-import jakarta.servlet.ServletRequestEvent;
-import jakarta.servlet.ServletRequestListener;
-import jakarta.servlet.SessionTrackingMode;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.DispatcherType;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.ServletRegistration.Dynamic;
+import javax.servlet.ServletRequestEvent;
+import javax.servlet.ServletRequestListener;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.HttpServletRequest;
 
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.resource.DefaultResourceManager;
 import cloud.piranha.resource.DirectoryResource;
-import cloud.piranha.webapp.impl.DefaultMimeTypeManager;
-import cloud.piranha.webapp.impl.DefaultSecurityManager;
-import cloud.piranha.webapp.impl.DefaultServlet;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequestMapper;
-import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
 
 /**
  * The JUnit tests for the DefaultWebApplication class.
@@ -688,7 +688,7 @@ class DefaultWebApplicationTest {
         DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
         DefaultWebApplication webApp = new DefaultWebApplication();
         webApp.setWebApplicationRequestMapper(webAppRequestMapper);
-        ServletRegistration.Dynamic dynamic = webApp.addServlet("session", "cloud.piranha.webapp.impl.tests.TestSessionServlet");
+        ServletRegistration.Dynamic dynamic = webApp.addServlet("session", "cloud.piranha.servlet4.impl.TestSessionServlet");
         assertNotNull(dynamic);
         dynamic.addMapping("/session");
         webApp.initialize();
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/FilterRegistrationTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/FilterRegistrationTest.java
new file mode 100644
index 00000000..4b892787
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/FilterRegistrationTest.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.IOException;
+import java.util.HashMap;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for testing everything related to the FilterRegistration API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class FilterRegistrationTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApp;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApp = new DefaultWebApplication();
+    }
+
+    /**
+     * Test getFilterRegistration method.
+     */
+    @Test
+    void testGetFilterRegistration() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        assertNotNull(webApp.getFilterRegistration("filter"));
+    }
+
+    /**
+     * Test getFilterRegistration method.
+     */
+    @Test
+    void testGetFilterRegistration2() {
+        webApp.addFilter("filter", "doesnotexist");
+        assertNotNull(webApp.getFilterRegistration("filter"));
+    }
+
+    /**
+     * Test getFilterRegistrations method.
+     */
+    @Test
+    void testGetFilterRegistrations() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        assertFalse(webApp.getFilterRegistrations().isEmpty());
+    }
+
+    /**
+     * Test getName method.
+     */
+    @Test
+    void testGetName() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        assertEquals("filter", registration.getName());
+    }
+
+    /**
+     * Test getClassName method.
+     */
+    @Test
+    void testGetClassName() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        assertEquals(TestFilterRegistrationFilter.class.getCanonicalName(),
+                registration.getClassName());
+    }
+
+    /**
+     * Test getInitParameters method.
+     */
+    @Test
+    void testGetInitParameters() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        assertNotNull(registration.getInitParameters());
+    }
+
+    /**
+     * Test getUrlPatternMappings method.
+     */
+    @Test
+    void testGetUrlPatternMappings() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        assertTrue(registration.getUrlPatternMappings().isEmpty());
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        registration.setInitParameter("name", "value");
+        assertTrue(registration.setInitParameters(new HashMap<>()).isEmpty());
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters2() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        HashMap<String, String> parameters = new HashMap<>();
+        parameters.put(null, null);
+        assertThrows(IllegalArgumentException.class, () -> registration.setInitParameters(parameters));
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters3() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        HashMap<String, String> parameters = new HashMap<>();
+        parameters.put("name", null);
+        assertThrows(IllegalArgumentException.class, () -> registration.setInitParameters(parameters));
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters4() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        HashMap<String, String> parameters = new HashMap<>();
+        parameters.put("name", "value");
+        assertTrue(registration.setInitParameters(parameters).isEmpty());
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters5() {
+        webApp.addFilter("filter", TestFilterRegistrationFilter.class);
+        FilterRegistration registration = webApp.getFilterRegistration("filter");
+        HashMap<String, String> parameters = new HashMap<>();
+        parameters.put("name", "value");
+        assertTrue(registration.setInitParameters(parameters).isEmpty());
+        assertFalse(registration.setInitParameters(parameters).isEmpty());
+    }
+
+    /**
+     * Test filter used in a test which tests adding a filter registration.
+     */
+    class TestFilterRegistrationFilter implements Filter {
+
+        /**
+         * Destroy the filter.
+         */
+        @Override
+        public void destroy() {
+        }
+
+        /**
+         * Process the filter.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @param chain the chain.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
+        }
+
+        /**
+         * Initialize the filter.
+         *
+         * @param filterConfig the filter configuration.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void init(FilterConfig filterConfig) throws ServletException {
+        }
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/FilterTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/FilterTest.java
new file mode 100644
index 00000000..1e794fd5
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/FilterTest.java
@@ -0,0 +1,373 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.io.IOException;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for testing everything related to the addFilter method and
+ * the Filter API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class FilterTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApp;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApp = new DefaultWebApplication();
+    }
+
+    /**
+     * Test addFilter method.
+     */
+    @Test
+    void testAddFilter() {
+        webApp.addFilter("Broken Filter", new TestBrokenFilter());
+        webApp.initialize();
+        assertNotNull(webApp.getAttribute("Broken Filter"));
+    }
+
+    /**
+     * Test addFilter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddFilter2() throws Exception {
+        webApp.addFilter("Filter 1", new TestMultiple1Filter());
+        webApp.addFilterMapping("Filter 1", "/*");
+        webApp.addFilter("Filter 2", new TestMultiple2Filter());
+        webApp.addFilterMapping("Filter 2", "/*");
+        webApp.addServlet("End Servlet", new TestEndServlet());
+        webApp.addServletMapping("End Servlet", "/multipleFilters");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/multipleFilters");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.service(request, response);
+        assertEquals(200, response.getStatus());
+    }
+
+    /**
+     * Test addFilter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddFilter4() throws Exception {
+        webApp.initialize();
+        webApp.start();
+        assertThrows(IllegalStateException.class, () -> webApp.addFilter("filter", new TestMultiple1Filter()));
+    }
+
+    /**
+     * Test addFilter method.
+     */
+    @Test
+    void testAddFilter5() {
+        assertNotNull(webApp.addFilter("filter", TestMultiple1Filter.class));
+        assertNotNull(webApp.getFilterRegistration("filter"));
+        assertEquals(TestMultiple1Filter.class.getCanonicalName(), webApp.getFilterRegistration("filter").getClassName());
+    }
+
+    /**
+     * Test addFilter method.
+     */
+    @Test
+    void testAddFilter6() {
+        assertNotNull(webApp.addFilter("filter", "doesnotexit"));
+    }
+
+    /**
+     * Test addFilter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddFilter7() throws Exception {
+        webApp.initialize();
+        webApp.start();
+        assertThrows(IllegalStateException.class, () -> webApp.addFilter("filter", "should throw IllegalStateException"));
+    }
+
+    /**
+     * Test addFilter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddFilter8() throws Exception {
+        webApp.initialize();
+        assertThrows(IllegalArgumentException.class, () -> webApp.addFilter(null, "filter name is null so throw IllegalArgumentException"));
+    }
+
+    /**
+     * Test addFilter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddFilter9() throws Exception {
+        webApp.initialize();
+        assertThrows(IllegalArgumentException.class, () -> webApp.addFilter(null, Filter.class));
+    }
+
+    /**
+     * Test addFilter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddFilter10() throws Exception {
+        webApp.initialize();
+        assertNotNull(webApp.addFilter("filter", Filter.class));
+        assertNull(webApp.addFilter("filter", Filter.class));
+    }
+
+    /**
+     * Test addFilter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddFilter11() throws Exception {
+        webApp.initialize();
+        webApp.addFilter("filter", "InCompleteRegistrationFilter");
+        webApp.addFilter("filter", "InCompleteRegistrationFilter");
+    }
+
+    /**
+     * Test addFilter method.
+     */
+    @Test
+    void testAddFilter12() {
+        assertNotNull(webApp.addFilter("filter", "InCompleteRegistrationFilter"));
+        assertNotNull(webApp.getFilterRegistration("filter"));
+    }
+
+    /**
+     * Test doFilter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testDoFilter() throws Exception {
+        webApp.addFilter("Filter 1", new TestMultiple1Filter());
+        webApp.addFilterMapping("Filter 1", "/*");
+        webApp.addServlet("End Servlet", new TestEndServlet());
+        webApp.addServletMapping("End Servlet", "/doFilter");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/doFilter");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.service(request, response);
+        assertEquals(200, response.getStatus());
+    }
+
+    @Test
+    void testAddFilterGetClassName() throws Exception{
+        Filter filter = new TestMultiple1Filter();
+        FilterRegistration.Dynamic registration = webApp.addFilter("filter", filter);
+        assertEquals(TestMultiple1Filter.class.getName(), registration.getClassName());
+    }
+
+    /**
+     * Test broken filter.
+     */
+    class TestBrokenFilter implements Filter {
+
+        /**
+         * Initialize the filter.
+         *
+         * @param filterConfig the filter config.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void init(FilterConfig filterConfig) throws ServletException {
+            ServletContext servletContext = filterConfig.getServletContext();
+            servletContext.setAttribute("Broken Filter", true);
+            throw new ServletException("Broken Filter");
+        }
+
+        /**
+         * Do the filter processing.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @param chain the chain.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
+        }
+
+        /**
+         * Destroy the filter.
+         */
+        @Override
+        public void destroy() {
+        }
+    }
+
+    /**
+     * Test filter used in a test with multiple filters.
+     */
+    class TestMultiple1Filter implements Filter {
+
+        /**
+         * Destroy the filter.
+         */
+        @Override
+        public void destroy() {
+        }
+
+        /**
+         * Process the filter.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @param chain the chain.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
+            request.setAttribute("TestMultiple1Filter", "true");
+            chain.doFilter(request, response);
+        }
+
+        /**
+         * Initialize the filter.
+         *
+         * @param filterConfig the filter configuration.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void init(FilterConfig filterConfig) throws ServletException {
+        }
+    }
+
+    /**
+     * Test filter used in a test with multiple filters.
+     */
+    class TestMultiple2Filter implements Filter {
+
+        /**
+         * Destroy the filter.
+         */
+        @Override
+        public void destroy() {
+        }
+
+        /**
+         * Process the filter.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @param chain the chain.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
+            request.setAttribute("TestMultiple2Filter", "true");
+            chain.doFilter(request, response);
+        }
+
+        /**
+         * Initialize the filter.
+         *
+         * @param filterConfig the filter configuration.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void init(FilterConfig filterConfig) throws ServletException {
+        }
+    }
+
+    /**
+     * Test servlet to end a filter chain with a 200 response code.
+     */
+    class TestEndServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Handles the GET request.
+         *
+         * @param request the servlet request.
+         * @param response the servlet response.
+         * @throws IOException when an I/O error occurs
+         * @throws ServletException when a servlet error occurs
+         */
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            response.setStatus(200);
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpServletRequestTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpServletRequestTest.java
similarity index 97%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpServletRequestTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpServletRequestTest.java
index d0704722..42ec56c2 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpServletRequestTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpServletRequestTest.java
@@ -25,10 +25,10 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.UnsupportedEncodingException;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequest;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpServletResponseTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpServletResponseTest.java
new file mode 100644
index 00000000..e493d120
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpServletResponseTest.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import java.io.IOException;
+import java.io.PrintWriter;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * The JUnit tests for testing everything related to the HttpServletResponse
+ * API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class HttpServletResponseTest {
+
+    /**
+     * Stores the HTTP servlet request.
+     */
+    private TestWebApplicationRequest request;
+
+    /**
+     * Stores the HTTP servlet response.
+     */
+    private TestWebApplicationResponse response;
+
+    /**
+     * Stores the web application.
+     */
+    private WebApplication webApplication;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        request = new TestWebApplicationRequest();
+        response = new TestWebApplicationResponse();
+        webApplication = new DefaultWebApplication();
+        request.setWebApplication(webApplication);
+        response.setWebApplication(webApplication);
+    }
+
+    /**
+     * Test sendRedirect method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testRedirect() throws Exception {
+        webApplication.addServlet("Servlet", TestRedirectAfterFlushServlet.class);
+        webApplication.addServletMapping("Servlet", "/servlet");
+        request.setServletPath("/servlet");
+        webApplication.initialize();
+        webApplication.start();
+        assertThrows(IllegalStateException.class, () -> webApplication.service(request, response));
+    }
+
+    /**
+     * Test sendRedirect method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testRedirect2() throws Exception {
+        webApplication.addServlet("Servlet2a", TestRedirect2aServlet.class);
+        webApplication.addServlet("Servlet2b", TestRedirect2bServlet.class);
+        webApplication.addServletMapping("Servlet2a", "/servlet2a");
+        webApplication.addServletMapping("Servlet2b", "/servlet2a/servlet2b");
+        request.setServletPath("/servlet2a");
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertEquals(302, response.getStatus());
+        assertNotNull(response.getHeader("Location"));
+        assertEquals("http://localhost:80/servlet2b", response.getHeader("Location"));
+    }
+
+    /**
+     * Test sendRedirect method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testRedirect3() throws Exception {
+        webApplication.addServlet("Servlet3", TestRedirect3Servlet.class);
+        webApplication.addServletMapping("Servlet3", "/servlet3");
+        request.setServletPath("/servlet3");
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertEquals(302, response.getStatus());
+        assertNotNull(response.getHeader("Location"));
+        assertEquals("http://localhost:80/relative_to_root", response.getHeader("Location"));
+    }
+
+    /**
+     * Test sendRedirect method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testRedirect4() throws Exception {
+        webApplication.addServlet("Servlet4", TestRedirect4Servlet.class);
+        webApplication.addServletMapping("Servlet4", "/servlet4");
+        request.setServletPath("/servlet4");
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertEquals(302, response.getStatus());
+        assertNotNull(response.getHeader("Location"));
+        assertEquals("http://this.is.outside/and_absolute", response.getHeader("Location"));
+    }
+
+
+    /**
+     * Test sendRedirect method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testRedirect5() throws Exception {
+        webApplication.addServlet("Servlet2a", TestRedirect2aServlet.class);
+        webApplication.addServlet("Servlet2b", TestRedirect2bServlet.class);
+        webApplication.setContextPath("/app");
+        webApplication.addServletMapping("Servlet2a", "/servlet2a");
+        webApplication.addServletMapping("Servlet2b", "/servlet2a/servlet2b");
+        request.setContextPath("/app");
+        request.setServletPath("/servlet2a");
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertEquals(302, response.getStatus());
+        assertNotNull(response.getHeader("Location"));
+        assertEquals("http://localhost:80/app/servlet2b", response.getHeader("Location"));
+    }
+
+    /**
+     * Test setDateHeader method.
+     */
+    @Test
+    void testSetDateHeader() {
+        response.setDateHeader("header", 1000);
+        response.setDateHeader("header", 2000);
+        assertEquals("Thu, 1 Jan 1970 00:00:02 GMT", response.getHeader("header"));
+    }
+
+    /**
+     * Test setDateHeader method.
+     */
+    @Test
+    void testSetDateHeader2() {
+        response.setDateHeader("header", 1000);
+        assertEquals("Thu, 1 Jan 1970 00:00:01 GMT", response.getHeader("header"));
+    }
+
+    /**
+     * Test setHeader method.
+     */
+    @Test
+    void testSetHeader() {
+        response.setHeader("header", "value1");
+        response.addHeader("header", "value2");
+        response.setHeader("header", "value3");
+        assertEquals("value3", response.getHeader("header"));
+    }
+
+    /**
+     * Test setHeader method.
+     */
+    @Test
+    void testSetHeader2() {
+        response.setHeader("header", "value1");
+        response.setHeader("header", "value2");
+        assertEquals("value2", response.getHeader("header"));
+    }
+
+    /**
+     * Test setHeader method.
+     */
+    @Test
+    void testSetHeader3() {
+        response.setHeader("header", "value1");
+        assertEquals("value1", response.getHeader("header"));
+    }
+
+    /**
+     * Test setIntHeader method.
+     */
+    @Test
+    void testSetIntHeader() {
+        response.setIntHeader("header", 1);
+        assertEquals("1", response.getHeader("header"));
+    }
+
+    /**
+     * Test setStatus method.
+     */
+    @Test
+    void testSetStatus() {
+        response.setStatus(500);
+        assertEquals(500, response.getStatus());
+    }
+
+    /**
+     * Test setStatus method.
+     */
+    @Test
+    void testSetStatus2() {
+        response.setStatus(HttpServletResponse.SC_NOT_FOUND, "Not found");
+        assertEquals(404, response.getStatus());
+    }
+
+    /**
+     * Test servlet that sends a redirect.
+     */
+    static class TestRedirect2aServlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request,
+                HttpServletResponse response) throws IOException, ServletException {
+            response.sendRedirect("servlet2b");
+        }
+    }
+
+    /**
+     * Test servlet that receives the redirect.
+     */
+    static class TestRedirect2bServlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request,
+                HttpServletResponse response) throws IOException, ServletException {
+            response.setStatus(200);
+            PrintWriter writer = response.getWriter();
+            writer.print("SUCCESS");
+            writer.flush();
+        }
+    }
+
+    /**
+     * Test servlet that sends a redirect.
+     */
+    static class TestRedirect3Servlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request,
+                HttpServletResponse response) throws IOException, ServletException {
+            response.sendRedirect("/relative_to_root");
+        }
+    }
+
+    /**
+     * Test servlet that sends a redirect.
+     */
+    static class TestRedirect4Servlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request,
+                HttpServletResponse response) throws IOException, ServletException {
+            response.sendRedirect("http://this.is.outside/and_absolute");
+        }
+    }
+
+    /**
+     * Test servlet that tries to send a redirect after flushing the buffer.
+     */
+    static class TestRedirectAfterFlushServlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request,
+                HttpServletResponse response) throws IOException, ServletException {
+            response.flushBuffer();
+            response.sendRedirect("/this_should_throw_an_illegal_state_exception");
+        }
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionAttributeListenerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionAttributeListenerTest.java
new file mode 100644
index 00000000..1dcf5da1
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionAttributeListenerTest.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionAttributeListener;
+import javax.servlet.http.HttpSessionBindingEvent;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for the HttpSessionAttributeListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class HttpSessionAttributeListenerTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        webApplication.setHttpSessionManager(sessionManager);
+    }
+
+    /**
+     * Test attributeAdded method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeAdded() throws Exception {
+        webApplication.addListener(new TestHttpSessionAttributeListener());
+        webApplication.addServlet("httpSessionAttributeServlet",
+                new TestHttpSessionAttributeServlet());
+        webApplication.addServletMapping("httpSessionAttributeServlet",
+                "/httpSessionAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/httpSessionAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeAdded"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test attributeRemoved method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeRemoved() throws Exception {
+        webApplication.addListener(new TestHttpSessionAttributeListener());
+        webApplication.addServlet("httpSessionAttributeServlet",
+                new TestHttpSessionAttributeServlet());
+        webApplication.addServletMapping("httpSessionAttributeServlet",
+                "/httpSessionAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/httpSessionAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeRemoved"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test attributeReplaced method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeReplaced() throws Exception {
+        webApplication.addListener(new TestHttpSessionAttributeListener());
+        webApplication.addServlet("httpSessionAttributeServlet",
+                new TestHttpSessionAttributeServlet());
+        webApplication.addServletMapping("httpSessionAttributeServlet",
+                "/httpSessionAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/httpSessionAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeReplaced"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test HttpServlet to validate the HTTP session attributes where added,
+     * remove and replaced.
+     */
+    class TestHttpSessionAttributeServlet extends HttpServlet {
+
+        /**
+         * Process GET method.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            HttpSession session = request.getSession();
+            session.setAttribute("attributeAdded", true);
+            session.setAttribute("attributeRemoved", true);
+            session.removeAttribute("attributeRemoved");
+            session.setAttribute("attributeReplaced", false);
+            session.setAttribute("attributeReplaced", true);
+        }
+    }
+
+    /**
+     * Test HttpSessionAttributeListener to validate attributeAdded,
+     * attributeRemoved and attributeReplaced are properly called.
+     */
+    class TestHttpSessionAttributeListener
+            implements HttpSessionAttributeListener {
+
+        /**
+         * Handle attribute added event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeAdded(HttpSessionBindingEvent event) {
+            if (event.getName().equals("attributeAdded")) {
+                event.getSession().getServletContext().setAttribute("attributeAdded", true);
+            }
+        }
+
+        /**
+         * Handle attribute removed event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeRemoved(HttpSessionBindingEvent event) {
+            if (event.getName().equals("attributeRemoved")) {
+                event.getSession().getServletContext().setAttribute("attributeRemoved", true);
+            }
+        }
+
+        /**
+         * Handle attribute replaced event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeReplaced(HttpSessionBindingEvent event) {
+            if (event.getName().equals("attributeReplaced")) {
+                event.getSession().getServletContext().setAttribute("attributeReplaced", true);
+            }
+        }
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionIdListenerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionIdListenerTest.java
new file mode 100644
index 00000000..4de11ea7
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionIdListenerTest.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionEvent;
+import javax.servlet.http.HttpSessionIdListener;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for testing everything related to the HttpSessionIdListener
+ * API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class HttpSessionIdListenerTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager httpSessionManager = new DefaultHttpSessionManager();
+        httpSessionManager.setWebApplication(webApplication);
+        webApplication.setHttpSessionManager(httpSessionManager);
+    }
+
+    /**
+     * Test sessionIdChanged method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSessionIdChanged() throws Exception {
+        webApplication.addListener(new TestHttpSessionIdListener());
+        webApplication.addServlet("sessionIdChangedServlet",
+                new TestHttpSessionIdChangedServlet());
+        webApplication.addServletMapping("sessionIdChangedServlet", "/sessionIdChanged");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/sessionIdChanged");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("originalSessionId"));
+        assertNotNull(webApplication.getAttribute("oldSessionId"));
+        assertNotNull(webApplication.getAttribute("newSessionId"));
+        assertEquals(webApplication.getAttribute("originalSessionId"),
+                webApplication.getAttribute("oldSessionId"));
+        assertNotEquals(webApplication.getAttribute("oldSessionId"),
+                webApplication.getAttribute("newSessionId"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test HttpServlet to validate the session was actually created.
+     */
+    class TestHttpSessionIdChangedServlet extends HttpServlet {
+
+        /**
+         * Process GET method.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            request.getServletContext().setAttribute("originalSessionId",
+                    request.getSession().getId());
+            request.changeSessionId();
+        }
+    }
+
+    /**
+     * Test HttpSessionIdListener to validate sessionIdChanged is properly
+     * called.
+     */
+    class TestHttpSessionIdListener implements HttpSessionIdListener {
+
+        /**
+         * Handle the session id changed event.
+         *
+         * @param event the event.
+         * @param oldSessionId the old session id.
+         */
+        @Override
+        public void sessionIdChanged(HttpSessionEvent event, String oldSessionId) {
+            HttpSession session = event.getSession();
+            session.getServletContext().setAttribute("newSessionId", session.getId());
+            session.getServletContext().setAttribute("oldSessionId", oldSessionId);
+        }
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionListenerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionListenerTest.java
new file mode 100644
index 00000000..aa329ce2
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/HttpSessionListenerTest.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionEvent;
+import javax.servlet.http.HttpSessionListener;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for the HttpSessionListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class HttpSessionListenerTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        webApplication.setHttpSessionManager(sessionManager);
+    }
+
+    /**
+     * Test sessionCreated method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSessionCreated() throws Exception {
+        webApplication.addListener(new TestHttpSessionListener());
+        webApplication.addServlet("sessionCreatedServlet", new TestHttpSessionCreatedServlet());
+        webApplication.addServletMapping("sessionCreatedServlet", "/sessionCreated");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/sessionCreated");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("sessionCreated"));
+        assertTrue(webApplication.getAttribute("session") instanceof HttpSession);
+        webApplication.stop();
+    }
+
+    /**
+     * Test sessionDestroyed method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSessionDestroyed() throws Exception {
+        webApplication.addListener(new TestHttpSessionListener());
+        webApplication.addServlet("sessionDestroyedServlet", new TestHttpSessionDestroyedServlet());
+        webApplication.addServletMapping("sessionDestroyedServlet", "/sessionDestroyed");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/sessionDestroyed");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("sessionDestroyed"));
+        webApplication.stop();
+        webApplication.destroy();
+    }
+
+    /**
+     * Test HttpServlet to validate the session was actually created.
+     */
+    class TestHttpSessionCreatedServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Process GET method.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            request.getServletContext().setAttribute("session", request.getSession());
+        }
+    }
+
+    /**
+     * Test HttpServlet to validate the session was actually destroyed.
+     */
+    class TestHttpSessionDestroyedServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Process GET method.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            HttpSession session = request.getSession();
+            session.invalidate();
+        }
+    }
+
+    /**
+     * Test HttpSessionListener to validate sessionCreated and sessionDestroyed
+     * are properly called.
+     */
+    class TestHttpSessionListener implements HttpSessionListener {
+
+        /**
+         * Handle the session created event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void sessionCreated(HttpSessionEvent event) {
+            event.getSession().getServletContext().setAttribute("sessionCreated", true);
+        }
+
+        /**
+         * Handle the session destroyed event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void sessionDestroyed(HttpSessionEvent event) {
+            event.getSession().getServletContext().setAttribute("sessionDestroyed", true);
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ListenerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ListenerTest.java
similarity index 88%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ListenerTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ListenerTest.java
index 2c7c2d93..b768c366 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ListenerTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ListenerTest.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
 import java.util.EventListener;
-import jakarta.servlet.ServletContextListener;
-import jakarta.servlet.ServletRequestListener;
-import jakarta.servlet.http.HttpSessionListener;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletRequestListener;
+import javax.servlet.http.HttpSessionListener;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
@@ -150,48 +150,48 @@ class ListenerTest {
     /**
      * Test HTTP session listener.
      */
-    public static class TestHttpSessionListener implements HttpSessionListener {
+    static class TestHttpSessionListener implements HttpSessionListener {
 
         /**
          * Constructor.
          */
-        public TestHttpSessionListener() {
+        TestHttpSessionListener() {
         }
     }
 
     /**
      * Test event listener.
      */
-    public static class TestInvalidTypeOfListener implements EventListener {
+    static class TestInvalidTypeOfListener implements EventListener {
 
         /**
          * Constructor.
          */
-        public TestInvalidTypeOfListener() {
+        TestInvalidTypeOfListener() {
         }
     }
 
     /**
      * Test Servlet context listener.
      */
-    public static class TestServletContextListener implements ServletContextListener {
+    static class TestServletContextListener implements ServletContextListener {
 
         /**
          * Constructor.
          */
-        public TestServletContextListener() {
+        TestServletContextListener() {
         }
     }
 
     /**
      * Test Servlet request listener.
      */
-    public static class TestServletRequestListener implements ServletRequestListener {
+    static class TestServletRequestListener implements ServletRequestListener {
 
         /**
          * Constructor.
          */
-        public TestServletRequestListener() {
+        TestServletRequestListener() {
         }
     }
 
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/MimeTypeManagerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/MimeTypeManagerTest.java
new file mode 100644
index 00000000..9dcb9e74
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/MimeTypeManagerTest.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultMimeTypeManager;
+import cloud.piranha.servlet4.webapp.MimeTypeManager;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the MimeTypeManager API.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class MimeTypeManagerTest {
+    
+    /**
+     * Stores the mime type manager.
+     */
+    protected MimeTypeManager manager;
+    
+    /**
+     * Before testing.
+     */
+    @BeforeEach
+    void before() {
+        manager = new DefaultMimeTypeManager();
+    }
+    
+    /**
+     * Test addMimeType method.
+     */
+    @Test
+    void testAddMimeType() {
+        assertNull(manager.getMimeType("my.class"));
+        manager.addMimeType("class", "application/x-java-class");
+        assertEquals("application/x-java-class", manager.getMimeType("my.class"));
+    }
+    
+    /**
+     * Test getMimeType method.
+     */
+    @Test
+    void testGetMimeType() {
+        assertEquals("text/css", manager.getMimeType("TEST.CSS"));
+        assertEquals("text/javascript", manager.getMimeType("TEST.JS"));
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContainerInitializerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContainerInitializerTest.java
new file mode 100644
index 00000000..ba036413
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContainerInitializerTest.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultAnnotationManager;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.lang.annotation.Retention;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.HandlesTypes;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for testing everything related to the
+ * ServletContainerInitializer API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletContainerInitializerTest {
+
+    /**
+     * Test addInitializer method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddInitializer() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addInitializer(new TestInitializer());
+        webApp.initialize();
+        assertNotNull(webApp.getAttribute("initializerCalled"));
+    }
+
+    /**
+     * Test addInitializer method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddInitializer2() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addInitializer("this.does.not.exist");
+        webApp.initialize();
+    }
+
+    /**
+     * Test addInitializer method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddInitializer3() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addInitializer(TestInitializer.class.getName());
+        webApp.initialize();
+        assertNotNull(webApp.getAttribute("initializerCalled"));
+    }
+
+    @Test
+    void testInitializerWithHandlesTypes () {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addInitializer(InitializerWithHandlesTypes.class.getName());
+        webApp.initialize();
+        assertTrue(webApp.getAttribute("object_class") instanceof Boolean);
+        assertFalse((Boolean) webApp.getAttribute("object_class"));
+
+        assertTrue(webApp.getAttribute("someannotation_class") instanceof Boolean);
+        assertFalse((Boolean) webApp.getAttribute("someannotation_class"));
+    }
+
+    @Test
+    void testInitializerWithHandlesTypes2 () {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addInitializer(InitializerWithHandlesTypes.class.getName());
+        DefaultAnnotationManager annotationManager = (DefaultAnnotationManager) webApp.getAnnotationManager();
+        annotationManager.addInstance(Set.class, Collections.emptySet().getClass());
+        annotationManager.addAnnotation(
+            new DefaultAnnotationManager.DefaultAnnotationInfo<>(
+                ClassAnnotated.class.getAnnotation(SomeAnnotation.class),
+                ClassAnnotated.class
+            )
+        );
+
+        webApp.initialize();
+        assertTrue(webApp.getAttribute("object_class") instanceof Boolean);
+        assertTrue((Boolean) webApp.getAttribute("object_class"));
+
+        assertTrue(webApp.getAttribute("someannotation_class") instanceof Boolean);
+        assertTrue((Boolean) webApp.getAttribute("someannotation_class"));
+    }
+
+    /**
+     * A test ServletContainerInitializer used to make sure they are called when
+     * the web application initializes.
+     */
+    static class TestInitializer implements ServletContainerInitializer {
+
+        /**
+         * Constructor.
+         */
+        TestInitializer() {
+        }
+
+        /**
+         * Handle on startup.
+         *
+         * @param classes the classes.
+         * @param servletContext the servlet context.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
+            servletContext.setAttribute("initializerCalled", true);
+        }
+    }
+
+    @HandlesTypes({Set.class, SomeAnnotation.class})
+    static class InitializerWithHandlesTypes implements ServletContainerInitializer{
+        @Override
+        public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
+            Optional<Class<?>> classInstance = classes.stream().filter(Set.class::isAssignableFrom).findFirst();
+            servletContext.setAttribute("object_class", classInstance.isPresent());
+
+            Optional<Class<?>> classWithAnnotation = classes.stream().filter(x -> x.getAnnotation(SomeAnnotation.class) != null).findFirst();
+            servletContext.setAttribute("someannotation_class", classWithAnnotation.isPresent());
+        }
+    }
+
+    @SomeAnnotation
+    static class ClassAnnotated {
+    }
+
+    @Retention(RUNTIME)
+    @interface SomeAnnotation {
+    }
+
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContextAttributeListenerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContextAttributeListenerTest.java
new file mode 100644
index 00000000..70c02cd3
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContextAttributeListenerTest.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+import java.io.IOException;
+
+import javax.servlet.ServletContextAttributeEvent;
+import javax.servlet.ServletContextAttributeListener;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for the ServletContextAttributeListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletContextAttributeListenerTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApplication = new DefaultWebApplication();
+        webApplication.setHttpSessionManager(new DefaultHttpSessionManager());
+    }
+
+    /**
+     * Test attributeAdded method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeAdded() throws Exception {
+        webApplication.addListener(new TestServletContextAttributeListener());
+        webApplication.addServlet("servletContextAttributeServlet",
+                new TestServletContextAttributeServlet());
+        webApplication.addServletMapping("servletContextAttributeServlet",
+                "/servletContextAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/servletContextAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeAdded2"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test attributeRemoved method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeRemoved() throws Exception {
+        webApplication.addListener(new TestServletContextAttributeListener());
+        webApplication.addServlet("servletContextAttributeServlet",
+                new TestServletContextAttributeServlet());
+        webApplication.addServletMapping("servletContextAttributeServlet",
+                "/servletContextAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/servletContextAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeRemoved2"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test attributeReplaced method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeReplaced() throws Exception {
+        webApplication.addListener(new TestServletContextAttributeListener());
+        webApplication.addServlet("servletContextAttributeServlet",
+                new TestServletContextAttributeServlet());
+        webApplication.addServletMapping("servletContextAttributeServlet",
+                "/servletContextAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/servletContextAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeReplaced2"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test HttpServlet to validate the servlet context attributes where added,
+     * remove and replaced.
+     */
+    class TestServletContextAttributeServlet extends HttpServlet {
+
+        /**
+         * Process GET method.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            request.getServletContext().setAttribute("attributeAdded", true);
+            request.getServletContext().setAttribute("attributeRemoved", true);
+            request.getServletContext().removeAttribute("attributeRemoved");
+            request.getServletContext().setAttribute("attributeReplaced", false);
+            request.getServletContext().setAttribute("attributeReplaced", true);
+        }
+    }
+
+    /**
+     * Test ServletContextAttributeListener to validate attributeAdded,
+     * attributeRemoved and attributeReplaced are properly called.
+     */
+    class TestServletContextAttributeListener
+            implements ServletContextAttributeListener {
+
+        /**
+         * Handle attribute added event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeAdded(ServletContextAttributeEvent event) {
+            if (event.getName().equals("attributeAdded")) {
+                event.getServletContext().setAttribute("attributeAdded2", true);
+            }
+        }
+
+        /**
+         * Handle attribute removed event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeRemoved(ServletContextAttributeEvent event) {
+            if (event.getName().equals("attributeRemoved")) {
+                event.getServletContext().setAttribute("attributeRemoved2", true);
+            }
+        }
+
+        /**
+         * Handle attribute replaced event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeReplaced(ServletContextAttributeEvent event) {
+            if (event.getName().equals("attributeReplaced")) {
+                event.getServletContext().setAttribute("attributeReplaced2", true);
+            }
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContextListenerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContextListenerTest.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContextListenerTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContextListenerTest.java
index 937d187f..18167ab0 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContextListenerTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletContextListenerTest.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 
-import jakarta.servlet.ServletContextEvent;
-import jakarta.servlet.ServletContextListener;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
 
 import org.junit.jupiter.api.Test;
 
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRegistrationTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRegistrationTest.java
new file mode 100644
index 00000000..76a663b0
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRegistrationTest.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import java.util.HashMap;
+import javax.servlet.ServletRegistration;
+import javax.servlet.http.HttpServlet;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * The JUnit tests for testing everything related to the ServletRegistration
+ * API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletRegistrationTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApp;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApp = new DefaultWebApplication();
+    }
+
+    /**
+     * Test getClassName method.
+     */
+    @Test
+    void testGetClassName() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration registration = webApp.getServletRegistration("servlet");
+        assertNotNull(TestServlet.class.getCanonicalName(), registration.getClassName());
+    }
+
+    /**
+     * Test getInitParameter method.
+     */
+    @Test
+    void testGetInitParameter() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration registration = webApp.getServletRegistration("servlet");
+        registration.setInitParameter("name", "value");
+        assertEquals("value", registration.getInitParameter("name"));
+    }
+    /**
+     * Test getInitParameters method.
+     */
+    @Test
+    void testGetInitParameters() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration registration = webApp.getServletRegistration("servlet");
+        assertNotNull(registration.getInitParameters());
+    }
+
+    /**
+     * Test getName method.
+     */
+    @Test
+    void testGetName() {
+        webApp.addServlet("servlet", TestServlet.class);
+        assertNotNull("servlet", webApp.getServletRegistration("servlet").getName());
+    }
+
+    /**
+     * Test getRunAsRole method.
+     */
+    @Test
+    void testGetRunAsRole() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration.Dynamic registration = (ServletRegistration.Dynamic) webApp.getServletRegistration("servlet");
+        registration.setRunAsRole("role");
+        assertNotNull(registration.getRunAsRole());
+        assertEquals("role", registration.getRunAsRole());
+    }
+
+    /**
+     * Test getServletRegistrations method.
+     */
+    @Test
+    void testGetServletRegistration() {
+        webApp.addServlet("servlet", TestServlet.class);
+        assertNotNull(webApp.getServletRegistration("servlet"));
+    }
+
+    /**
+     * Test getFilterRegistration method.
+     */
+    @Test
+    void testGetServletRegistration2() {
+        webApp.addServlet("servlet", "doesnotexist");
+        assertNotNull(webApp.getServletRegistration("servlet"));
+    }
+
+    /**
+     * Test getFilterRegistrations method.
+     */
+    @Test
+    void testGetServletRegistration3() {
+        webApp.addServlet("servlet", TestServlet.class);
+        assertFalse(webApp.getServletRegistrations().isEmpty());
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration registration = webApp.getServletRegistration("servlet");
+        registration.setInitParameter("name", "value");
+        assertTrue(registration.setInitParameters(new HashMap<>()).isEmpty());
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters2() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration registration = webApp.getServletRegistration("servlet");
+        HashMap<String, String> parameters = new HashMap<>();
+        parameters.put(null, null);
+        assertThrows(IllegalArgumentException.class, () -> registration.setInitParameters(parameters));
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters3() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration registration = webApp.getServletRegistration("servlet");
+        HashMap<String, String> parameters = new HashMap<>();
+        parameters.put("name", null);
+        assertThrows(IllegalArgumentException.class, () -> registration.setInitParameters(parameters));
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters4() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration registration = webApp.getServletRegistration("servlet");
+        HashMap<String, String> parameters = new HashMap<>();
+        parameters.put("name", "value");
+        assertTrue(registration.setInitParameters(parameters).isEmpty());
+    }
+
+    /**
+     * Test setInitParameters method.
+     */
+    @Test
+    void testSetInitParameters5() {
+        webApp.addServlet("servlet", TestServlet.class);
+        ServletRegistration registration = webApp.getServletRegistration("servlet");
+        HashMap<String, String> parameters = new HashMap<>();
+        parameters.put("name", "value");
+        assertTrue(registration.setInitParameters(parameters).isEmpty());
+        assertFalse(registration.setInitParameters(parameters).isEmpty());
+    }
+
+    /**
+     * Test servlet used in a test which tests adding a servlet registration.
+     */
+    static class TestServlet extends HttpServlet {
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestAttributeListenerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestAttributeListenerTest.java
new file mode 100644
index 00000000..07d4df1e
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestAttributeListenerTest.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequestAttributeEvent;
+import javax.servlet.ServletRequestAttributeListener;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for the ServletRequestAttributeListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletRequestAttributeListenerTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApplication = new DefaultWebApplication();
+        webApplication.setHttpSessionManager(new DefaultHttpSessionManager());
+    }
+
+    /**
+     * Test attributeAdded method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeAdded() throws Exception {
+        webApplication.addListener(new TestServletRequestAttributeListener());
+        webApplication.addServlet("servletRequestAttributeServlet",
+                new TestServletRequestAttributeServlet());
+        webApplication.addServletMapping("servletRequestAttributeServlet",
+                "/servletRequestAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/servletRequestAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeAdded"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test attributeRemoved method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeRemoved() throws Exception {
+        webApplication.addListener(new TestServletRequestAttributeListener());
+        webApplication.addServlet("servletRequestAttributeServlet",
+                new TestServletRequestAttributeServlet());
+        webApplication.addServletMapping("servletRequestAttributeServlet",
+                "/servletRequestAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/servletRequestAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeRemoved"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test attributeReplaced method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAttributeReplaced() throws Exception {
+        webApplication.addListener(new TestServletRequestAttributeListener());
+        webApplication.addServlet("servletRequestAttributeServlet",
+                new TestServletRequestAttributeServlet());
+        webApplication.addServletMapping("servletRequestAttributeServlet",
+                "/servletRequestAttribute");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/servletRequestAttribute");
+        request.setWebApplication(webApplication);
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("attributeReplaced"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test HttpServlet to validate the servlet request attributes where added,
+     * remove and replaced.
+     */
+    class TestServletRequestAttributeServlet extends HttpServlet {
+
+        /**
+         * Process GET method.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            request.setAttribute("attributeAdded", true);
+            request.setAttribute("attributeRemoved", true);
+            request.removeAttribute("attributeRemoved");
+            request.setAttribute("attributeReplaced", false);
+            request.setAttribute("attributeReplaced", true);
+        }
+    }
+
+    /**
+     * Test ServletRequestAttributeListener to validate attributeAdded,
+     * attributeRemoved and attributeReplaced are properly called.
+     */
+    class TestServletRequestAttributeListener implements ServletRequestAttributeListener {
+
+        /**
+         * Handle attribute added event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeAdded(ServletRequestAttributeEvent event) {
+            if (event.getName().equals("attributeAdded")) {
+                event.getServletContext().setAttribute("attributeAdded", true);
+            }
+        }
+
+        /**
+         * Handle attribute removed event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeRemoved(ServletRequestAttributeEvent event) {
+            if (event.getName().equals("attributeRemoved")) {
+                event.getServletContext().setAttribute("attributeRemoved", true);
+            }
+        }
+
+        /**
+         * Handle attribute replaced event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void attributeReplaced(ServletRequestAttributeEvent event) {
+            if (event.getName().equals("attributeReplaced")) {
+                event.getServletContext().setAttribute("attributeReplaced", true);
+            }
+        }
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestListenerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestListenerTest.java
new file mode 100644
index 00000000..c661ed6b
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestListenerTest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+import javax.servlet.ServletRequestEvent;
+import javax.servlet.ServletRequestListener;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for ServletRequestListener API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletRequestListenerTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApplication = new DefaultWebApplication();
+        webApplication.setHttpSessionManager(new DefaultHttpSessionManager());
+    }
+
+    /**
+     * Test requestDestroyed method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testRequestDestroyed() throws Exception {
+        webApplication.addListener(new TestServletRequestListener());
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("requestDestroyed"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test requestInitialized method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testRequestInitialized() throws Exception {
+        webApplication.addListener(new TestServletRequestListener());
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertNotNull(webApplication.getAttribute("requestInitialized"));
+        webApplication.stop();
+    }
+
+    class TestServletRequestListener implements ServletRequestListener {
+
+        /**
+         * Handle request destroyed event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void requestDestroyed(ServletRequestEvent event) {
+            event.getServletContext().setAttribute("requestDestroyed", true);
+        }
+
+        /**
+         * Handle request initialized event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void requestInitialized(ServletRequestEvent event) {
+            event.getServletContext().setAttribute("requestInitialized", true);
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestTest.java
similarity index 97%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestTest.java
index c4602fe0..06eace6c 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletRequestTest.java
@@ -25,9 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import jakarta.servlet.ServletRequest;
+import javax.servlet.ServletRequest;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletTest.java
new file mode 100644
index 00000000..53faef9f
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/ServletTest.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultHttpSessionManager;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.io.IOException;
+
+import javax.servlet.Servlet;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The JUnit tests for the Servlet API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletTest {
+
+    /**
+     * Stores the web application.
+     */
+    protected WebApplication webApplication;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        webApplication = new DefaultWebApplication();
+        webApplication.setHttpSessionManager(new DefaultHttpSessionManager());
+    }
+
+    /**
+     * Test addServlet method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddServlet() throws Exception {
+        webApplication.addServlet("Broken Servlet", new TestBrokenServlet());
+        webApplication.addServletMapping("Broken Servlet", "/echo");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo");
+        webApplication.initialize();
+        webApplication.start();
+        try {
+            webApplication.service(request, response);
+            fail();
+        } catch(RuntimeException ue) {
+        }
+        assertNotNull(webApplication.getAttribute("Broken Servlet"));
+        webApplication.stop();
+    }
+
+    /**
+     * Test addServlet method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddServlet2() throws Exception {
+        try {
+            assertNotNull(webApplication.addServlet("Echo", TestServlet.class));
+            webApplication.addServletMapping("Echo", "/echo");
+            TestWebApplicationResponse response = new TestWebApplicationResponse();
+            response.setBodyOnly(false);
+            TestWebApplicationRequest request = new TestWebApplicationRequest();
+            request.setServletPath("/echo");
+            webApplication.initialize();
+            webApplication.start();
+            webApplication.service(request, response);
+            assertTrue(new String(response.getResponseBytes()).contains("200"));
+            assertTrue(new String(response.getResponseBytes()).contains("SUCCESS"));
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw e;
+        }
+    }
+
+    /**
+     * Test addServlet method.
+     */
+    @Test
+    void testAddServlet3() {
+        ServletRegistration.Dynamic dynamic = webApplication.addServlet("bogus", Servlet.class);
+        assertNotNull(dynamic);
+    }
+
+    /**
+     * Test addServlet method.
+     */
+    @Test
+    void testAddServlet4() {
+        ServletRegistration.Dynamic dynamic = webApplication.addServlet("echo", "servlet.EchoServlet");
+        assertNotNull(dynamic);
+    }
+
+    /**
+     * Test addServlet method.
+     */
+    @Test
+    void testAddServlet5() {
+        ServletRegistration.Dynamic dynamic = webApplication.addServlet("bogus", "servlet.BogusServlet");
+        assertNotNull(dynamic);
+    }
+
+    /**
+     * Test service method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testService() throws Exception {
+        assertNotNull(webApplication.addServlet("Echo", TestServlet.class));
+        webApplication.addServletMapping("Echo", "/echo");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setBodyOnly(false);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setServletPath("/echo");
+        webApplication.initialize();
+        webApplication.start();
+        webApplication.service(request, response);
+        assertTrue(new String(response.getResponseBytes()).contains("200"));
+        assertTrue(new String(response.getResponseBytes()).contains("SUCCESS"));
+    }
+
+    /**
+     * Test to verify instantiating a broken servlet fails.
+     */
+    class TestBrokenServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Initialize the servlet.
+         *
+         * @param servletConfig the servlet config.
+         * @throws ServletException when a servlet error occurs.
+         */
+        @Override
+        public void init(ServletConfig servletConfig) throws ServletException {
+            servletConfig.getServletContext().setAttribute("Broken Servlet", true);
+            throw new RuntimeException("Broken Servlet");
+        }
+    }
+
+    /**
+     * Test to verify instantiating a servlet succeeds.
+     */
+    static class TestServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            response.getWriter().println("SUCCESS");
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/SessionCookieConfigTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/SessionCookieConfigTest.java
similarity index 93%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/SessionCookieConfigTest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/SessionCookieConfigTest.java
index abcd7dba..899d68ca 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/SessionCookieConfigTest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/SessionCookieConfigTest.java
@@ -25,19 +25,19 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequest;
-import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequest;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationResponse;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import jakarta.servlet.ServletContextEvent;
-import jakarta.servlet.ServletContextListener;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import static org.junit.jupiter.api.Assertions.fail;
 import org.junit.jupiter.api.Test;
 
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestChat1Servlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestChat1Servlet.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestChat1Servlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestChat1Servlet.java
index f6676040..955a14c4 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestChat1Servlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestChat1Servlet.java
@@ -25,20 +25,20 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.LinkedBlockingQueue;
-import jakarta.servlet.AsyncContext;
-import jakarta.servlet.AsyncEvent;
-import jakarta.servlet.AsyncListener;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.AsyncContext;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A test chat servlet.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestChat2Servlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestChat2Servlet.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestChat2Servlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestChat2Servlet.java
index 7d9e364e..6f825737 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestChat2Servlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestChat2Servlet.java
@@ -25,20 +25,20 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.LinkedBlockingQueue;
-import jakarta.servlet.AsyncContext;
-import jakarta.servlet.AsyncEvent;
-import jakarta.servlet.AsyncListener;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.AsyncContext;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A test chat servlet.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestEcho1Servlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestEcho1Servlet.java
similarity index 91%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestEcho1Servlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestEcho1Servlet.java
index 296d9629..034bfbb1 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestEcho1Servlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestEcho1Servlet.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A test echo servlet.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestEcho2Servlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestEcho2Servlet.java
similarity index 91%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestEcho2Servlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestEcho2Servlet.java
index ec47cfb7..4fd7329d 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestEcho2Servlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestEcho2Servlet.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A test echo servlet.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestHttpServerRequest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestHttpServerRequest.java
similarity index 99%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestHttpServerRequest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestHttpServerRequest.java
index 2c4cf404..c5379c3f 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestHttpServerRequest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestHttpServerRequest.java
@@ -25,7 +25,7 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import cloud.piranha.http.api.HttpServerRequest;
 import java.io.ByteArrayInputStream;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestHttpServerResponse.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestHttpServerResponse.java
similarity index 98%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestHttpServerResponse.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestHttpServerResponse.java
index f82f5b60..13948a48 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestHttpServerResponse.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestHttpServerResponse.java
@@ -25,7 +25,7 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import cloud.piranha.http.api.HttpServerResponse;
 import java.io.ByteArrayOutputStream;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestIOExceptionServlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestIOExceptionServlet.java
similarity index 91%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestIOExceptionServlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestIOExceptionServlet.java
index 840d97a6..0e259d5c 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestIOExceptionServlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestIOExceptionServlet.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A test I/O exception servlet.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude2Servlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude2Servlet.java
similarity index 91%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude2Servlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude2Servlet.java
index 525658c8..696e1ddc 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude2Servlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude2Servlet.java
@@ -25,14 +25,14 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A servlet testing includes (performing the actual include).
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude3Servlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude3Servlet.java
similarity index 89%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude3Servlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude3Servlet.java
index 73a14a39..a05b72a2 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude3Servlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude3Servlet.java
@@ -25,15 +25,15 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A servlet testing includes (performing the actual include).
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude4Servlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude4Servlet.java
similarity index 90%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude4Servlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude4Servlet.java
index 8b15e129..e9cbd335 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestInclude4Servlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestInclude4Servlet.java
@@ -25,15 +25,15 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A servlet testing includes (performing the actual include).
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestIncludeServlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestIncludeServlet.java
similarity index 89%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestIncludeServlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestIncludeServlet.java
index 868ba616..a8bbecf4 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestIncludeServlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestIncludeServlet.java
@@ -25,15 +25,15 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A servlet testing includes.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestRuntimeExceptionServlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestRuntimeExceptionServlet.java
similarity index 91%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestRuntimeExceptionServlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestRuntimeExceptionServlet.java
index 360c7d54..bf6def82 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestRuntimeExceptionServlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestRuntimeExceptionServlet.java
@@ -25,13 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A test runtime exception servlet.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestSessionServlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestSessionServlet.java
similarity index 93%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestSessionServlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestSessionServlet.java
index c601ac20..3db9aa66 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestSessionServlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestSessionServlet.java
@@ -25,15 +25,15 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
 import java.io.PrintWriter;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
 
 /**
  * A test HTTP session Servlet.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestSnoopServlet.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestSnoopServlet.java
similarity index 97%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestSnoopServlet.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestSnoopServlet.java
index 9ed8ad6a..30590bed 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestSnoopServlet.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestSnoopServlet.java
@@ -25,18 +25,18 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Enumeration;
 import java.util.Locale;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * A test Snoop Servlet.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestWebApplicationRequest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestWebApplicationRequest.java
similarity index 94%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestWebApplicationRequest.java
rename to servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestWebApplicationRequest.java
index b8d20e48..9327758c 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestWebApplicationRequest.java
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestWebApplicationRequest.java
@@ -25,9 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.servlet4.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequest;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequest;
 
 /**
  * A test WebApplicationRequest.
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestWebApplicationResponse.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestWebApplicationResponse.java
new file mode 100644
index 00000000..cbc00df5
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/TestWebApplicationResponse.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplicationResponse;
+import java.io.ByteArrayOutputStream;
+
+/**
+ * A Test WebApplicationResponse.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestWebApplicationResponse extends DefaultWebApplicationResponse {
+
+    /**
+     * Constructor.
+     */
+    public TestWebApplicationResponse() {
+        super();
+        this.bodyOnly = true;
+        this.outputStream = new ByteArrayOutputStream();
+    }
+
+    /**
+     * Get the bytes in the buffer.
+     *
+     * @return the bytes in the buffer.
+     */
+    public byte[] getResponseBytes() {
+        ByteArrayOutputStream output = (ByteArrayOutputStream) this.outputStream;
+        return output.toByteArray();
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/WebXmlManagerTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/WebXmlManagerTest.java
new file mode 100644
index 00000000..663bbd06
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/WebXmlManagerTest.java
@@ -0,0 +1,250 @@
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.WebXml;
+import cloud.piranha.servlet4.impl.WebXmlManager;
+import org.junit.jupiter.api.Test;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static cloud.piranha.servlet4.impl.WebXml.OTHERS_TAG;
+import static org.junit.jupiter.api.Assertions.*;
+
+class WebXmlManagerTest {
+
+    private static WebXml toWebFragment(String fragmentName) {
+        WebXml fragment = new WebXml();
+        fragment.setFragmentName(fragmentName);
+        return fragment;
+    }
+
+    @Test
+    void testNoOrdering() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        List<String> fragmentNames = Arrays.asList("a", "b", "c", "d", "e");
+        Collections.shuffle(fragmentNames);
+
+        manager.setWebFragments(fragmentNames.stream().map(WebXmlManagerTest::toWebFragment).collect(Collectors.toUnmodifiableList()));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(5, orderedFragments.size());
+        assertAll(() -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("a"::equals)),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("b"::equals)),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("c"::equals)),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("d"::equals)),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("e"::equals)));
+    }
+
+    @Test
+    void testAbsoluteOrdering() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        webXml.setAbsoluteOrdering(List.of("a", "c", "e"));
+
+        List<String> fragmentNames = Arrays.asList("a", "b", "c", "d", "e");
+        Collections.shuffle(fragmentNames);
+
+        manager.setWebFragments(fragmentNames.stream().map(WebXmlManagerTest::toWebFragment).collect(Collectors.toUnmodifiableList()));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(3, orderedFragments.size());
+        assertAll(() -> assertEquals("a", orderedFragments.get(0).getFragmentName()),
+                () -> assertEquals("c", orderedFragments.get(1).getFragmentName()),
+                () -> assertEquals("e", orderedFragments.get(2).getFragmentName()));
+    }
+
+    @Test
+    void testAbsoluteOrdering2() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        webXml.setAbsoluteOrdering(List.of("a", "c", "a", "e"));
+
+        List<String> fragmentNames = Arrays.asList("a", "b", "c", "d", "e");
+        Collections.shuffle(fragmentNames);
+
+        manager.setWebFragments(fragmentNames.stream().map(WebXmlManagerTest::toWebFragment).collect(Collectors.toUnmodifiableList()));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(3, orderedFragments.size());
+        assertAll(() -> assertEquals("a", orderedFragments.get(0).getFragmentName()),
+                () -> assertEquals("c", orderedFragments.get(1).getFragmentName()),
+                () -> assertEquals("e", orderedFragments.get(2).getFragmentName()));
+    }
+
+    @Test
+    void testAbsoluteOrdering3() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        webXml.setAbsoluteOrdering(List.of("a", OTHERS_TAG, "c"));
+
+        List<String> fragmentNames = Arrays.asList("a", "b", "c", "d", "e");
+        Collections.shuffle(fragmentNames);
+
+        manager.setWebFragments(fragmentNames.stream().map(WebXmlManagerTest::toWebFragment).collect(Collectors.toUnmodifiableList()));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(5, orderedFragments.size());
+        assertAll(() -> assertEquals("a", orderedFragments.get(0).getFragmentName()),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("c"::equals)),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("d"::equals)),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("e"::equals)),
+                () -> assertEquals("c", orderedFragments.get(4).getFragmentName()));
+    }
+
+    @Test
+    void testAbsoluteOrdering4() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        webXml.setAbsoluteOrdering(List.of(OTHERS_TAG, "a", "c", "d"));
+
+        List<String> fragmentNames = Arrays.asList("a", "b", "c", "d", "e");
+        Collections.shuffle(fragmentNames);
+
+        manager.setWebFragments(fragmentNames.stream().map(WebXmlManagerTest::toWebFragment).collect(Collectors.toUnmodifiableList()));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(5, orderedFragments.size());
+        assertAll(() -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("b"::equals)),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("e"::equals)),
+                () -> assertEquals("a", orderedFragments.get(2).getFragmentName()),
+                () -> assertEquals("c", orderedFragments.get(3).getFragmentName()),
+                () -> assertEquals("d", orderedFragments.get(4).getFragmentName()));
+    }
+
+    @Test
+    void testAbsoluteOrdering5() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        webXml.setAbsoluteOrdering(List.of("a", "c", "d", OTHERS_TAG));
+
+        List<String> fragmentNames = Arrays.asList("a", "b", "c", "d", "e");
+        Collections.shuffle(fragmentNames);
+
+        manager.setWebFragments(fragmentNames.stream().map(WebXmlManagerTest::toWebFragment).collect(Collectors.toUnmodifiableList()));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(5, orderedFragments.size());
+        assertAll(() -> assertEquals("a", orderedFragments.get(0).getFragmentName()),
+                () -> assertEquals("c", orderedFragments.get(1).getFragmentName()),
+                () -> assertEquals("d", orderedFragments.get(2).getFragmentName()),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("b"::equals)),
+                () -> assertTrue(orderedFragments.stream().map(WebXml::getFragmentName).anyMatch("e"::equals)));
+    }
+
+    @Test
+    void testRelativeOrdering() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        WebXml fragmentA = toWebFragment("a");
+        fragmentA.setRelativeOrdering(new WebXml.RelativeOrder(null, List.of(OTHERS_TAG, "c")));
+
+        WebXml fragmentB = toWebFragment("b");
+        fragmentB.setRelativeOrdering(new WebXml.RelativeOrder(List.of(OTHERS_TAG), null));
+
+        WebXml fragmentC = toWebFragment("c");
+        fragmentC.setRelativeOrdering(new WebXml.RelativeOrder(null, List.of(OTHERS_TAG)));
+
+        WebXml fragmentD = toWebFragment("d");
+        WebXml fragmentE = toWebFragment("e");
+
+        WebXml fragmentF = toWebFragment("f");
+        fragmentF.setRelativeOrdering(new WebXml.RelativeOrder(List.of(OTHERS_TAG, "b"), null));
+
+        manager.setWebFragments(Arrays.asList(fragmentA, fragmentB, fragmentC, fragmentD, fragmentE, fragmentF));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(6, orderedFragments.size());
+        assertAll(() -> assertEquals("f", orderedFragments.get(0).getFragmentName()),
+                () -> assertEquals("b", orderedFragments.get(1).getFragmentName()),
+                () -> assertEquals("d", orderedFragments.get(2).getFragmentName()),
+                () -> assertEquals("e", orderedFragments.get(3).getFragmentName()),
+                () -> assertEquals("c", orderedFragments.get(4).getFragmentName()),
+                () -> assertEquals("a", orderedFragments.get(5).getFragmentName()));
+    }
+
+    @Test
+    void testRelativeOrdering2() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        WebXml fragmentNoID = new WebXml();
+        fragmentNoID.setRelativeOrdering(new WebXml.RelativeOrder(List.of("c"), List.of(OTHERS_TAG)));
+
+        WebXml fragmentB = toWebFragment("b");
+        fragmentB.setRelativeOrdering(new WebXml.RelativeOrder(List.of(OTHERS_TAG), null));
+
+        WebXml fragmentC = toWebFragment("c");
+
+        WebXml fragmentD = toWebFragment("d");
+        fragmentD.setRelativeOrdering(new WebXml.RelativeOrder(null, List.of(OTHERS_TAG)));
+
+        WebXml fragmentE = toWebFragment("e");
+        fragmentE.setRelativeOrdering(new WebXml.RelativeOrder(List.of(OTHERS_TAG), null));
+
+        WebXml fragmentF = toWebFragment("f");
+
+        manager.setWebFragments(Arrays.asList(fragmentNoID, fragmentB, fragmentC, fragmentD, fragmentE, fragmentF));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(6, orderedFragments.size());
+
+        List<String> validOrderings = List.of(
+            "befnullcd",
+            "befnulldc",
+            "ebfnullcd",
+            "ebfnulldc",
+            "ebfdnullc",
+            "ebfdnulld" // the spec example repeats the d fragment
+        );
+
+        assertTrue(validOrderings.contains(orderedFragments.stream().map(WebXml::getFragmentName).collect(Collectors.joining(""))));
+    }
+
+    @Test
+    void testRelativeOrdering3() {
+        WebXmlManager manager = new WebXmlManager();
+        WebXml webXml = new WebXml();
+        manager.setWebXml(webXml);
+
+        WebXml fragmentA = toWebFragment("a");
+        fragmentA.setRelativeOrdering(new WebXml.RelativeOrder(null, List.of("b")));
+
+        WebXml fragmentB = toWebFragment("b");
+
+        WebXml fragmentC = toWebFragment("c");
+        fragmentC.setRelativeOrdering(new WebXml.RelativeOrder(List.of(OTHERS_TAG), null));
+
+        WebXml fragmentD = toWebFragment("d");
+
+        manager.setWebFragments(Arrays.asList(fragmentA, fragmentB, fragmentC, fragmentD));
+
+        List<WebXml> orderedFragments = manager.getOrderedFragments();
+        assertEquals(4, orderedFragments.size());
+
+        List<String> validOrderings = List.of(
+                "cbda",
+                "cdba",
+                "cbad"
+        );
+
+        assertTrue(validOrderings.contains(orderedFragments.stream().map(WebXml::getFragmentName).collect(Collectors.joining(""))));
+    }
+}
diff --git a/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/WelcomeFileTest.java b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/WelcomeFileTest.java
new file mode 100644
index 00000000..069b8a2c
--- /dev/null
+++ b/servlet4/impl/src/test/java/cloud/piranha/servlet4/impl/WelcomeFileTest.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.impl;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplicationRequest;
+import cloud.piranha.servlet4.impl.DefaultServlet;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationResponse;
+import cloud.piranha.resource.DirectoryResource;
+import org.junit.jupiter.api.Test;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+/**
+ * The JUnit tests to test the welcome-file functionality.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class WelcomeFileTest {
+    
+    /**
+     * Test an index.html file.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testIndexHtml() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addResource(new DirectoryResource(new File("src/test/webapp/default")));
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setWebApplication(webApp);
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setWebApplication(webApp);
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+        response.setUnderlyingOutputStream(byteOutput);
+        webApp.setDefaultServlet(new DefaultServlet());
+        webApp.initialize();
+        webApp.start();
+        webApp.service(request, response);
+        assertEquals(200, response.getStatus());
+        assertTrue(byteOutput.toString().contains("index.html"));
+        webApp.stop();
+    }
+    
+    
+    /**
+     * Test a custom welcome file.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testCustomWelcomeFilel() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.getWelcomeFileManager().addWelcomeFile("custom.html");
+        webApp.addResource(new DirectoryResource(new File("src/test/webapp/custom")));
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setWebApplication(webApp);
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setWebApplication(webApp);
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+        response.setUnderlyingOutputStream(byteOutput);
+        webApp.setDefaultServlet(new DefaultServlet());
+        webApp.initialize();
+        webApp.start();
+        webApp.service(request, response);
+        assertEquals(200, response.getStatus());
+        assertTrue(byteOutput.toString().contains("custom.html"));
+        webApp.stop();
+    }
+}
diff --git a/servlet4/impl/src/test/webapp/custom/custom.html b/servlet4/impl/src/test/webapp/custom/custom.html
new file mode 100644
index 00000000..c82d7532
--- /dev/null
+++ b/servlet4/impl/src/test/webapp/custom/custom.html
@@ -0,0 +1,6 @@
+<html>
+    <head></head>
+    <body>
+        custom.html
+    </body>
+</html>
diff --git a/servlet4/impl/src/test/webapp/default/index.html b/servlet4/impl/src/test/webapp/default/index.html
new file mode 100644
index 00000000..3688d459
--- /dev/null
+++ b/servlet4/impl/src/test/webapp/default/index.html
@@ -0,0 +1,6 @@
+<html>
+    <head></head>
+    <body>
+        index.html
+    </body>
+</html>
diff --git a/servlet4/impl/src/test/webapp/resourcepaths/catalog/index.html b/servlet4/impl/src/test/webapp/resourcepaths/catalog/index.html
new file mode 100644
index 00000000..e69de29b
diff --git a/servlet4/impl/src/test/webapp/resourcepaths/catalog/offers/books.html b/servlet4/impl/src/test/webapp/resourcepaths/catalog/offers/books.html
new file mode 100644
index 00000000..e69de29b
diff --git a/servlet4/impl/src/test/webapp/resourcepaths/catalog/offers/music.html b/servlet4/impl/src/test/webapp/resourcepaths/catalog/offers/music.html
new file mode 100644
index 00000000..e69de29b
diff --git a/servlet4/impl/src/test/webapp/resourcepaths/catalog/products.html b/servlet4/impl/src/test/webapp/resourcepaths/catalog/products.html
new file mode 100644
index 00000000..e69de29b
diff --git a/servlet4/impl/src/test/webapp/resourcepaths/customer/login.jsp b/servlet4/impl/src/test/webapp/resourcepaths/customer/login.jsp
new file mode 100644
index 00000000..e69de29b
diff --git a/servlet4/impl/src/test/webapp/resourcepaths/welcome.html b/servlet4/impl/src/test/webapp/resourcepaths/welcome.html
new file mode 100644
index 00000000..e69de29b
diff --git a/servlet4/pom.xml b/servlet4/pom.xml
new file mode 100644
index 00000000..61b92e50
--- /dev/null
+++ b/servlet4/pom.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <groupId>cloud.piranha.servlet4</groupId>
+    <artifactId>project</artifactId>
+    <packaging>pom</packaging>
+
+    <name>Piranha Servlet 4 - Project</name>
+
+    <modules>
+        <module>annotationscan</module>
+        <module>api</module>
+        <module>impl</module>
+	<module>scinitializer</module>
+        <module>tempdir</module>
+	<module>webannotation</module>
+        <module>webapp</module>
+        <module>webxml</module>
+    </modules>
+
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>cloud.piranha</groupId>
+                <artifactId>bom</artifactId>
+                <version>${project.version}</version>
+                <type>pom</type>
+                <scope>import</scope>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+</project>
diff --git a/servlet4/scinitializer/pom.xml b/servlet4/scinitializer/pom.xml
new file mode 100644
index 00000000..c141b976
--- /dev/null
+++ b/servlet4/scinitializer/pom.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha.servlet4</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>piranha-servlet4-scinitializer</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Piranha Servlet 4 - ServletContainerInitializer Integration</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-webapp</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-impl</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish</groupId>
+            <artifactId>jakarta.faces</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/servlet4/scinitializer/src/main/java/cloud/piranha/servlet4/scinitializer/ServletContainerInitializerExtension.java b/servlet4/scinitializer/src/main/java/cloud/piranha/servlet4/scinitializer/ServletContainerInitializerExtension.java
new file mode 100644
index 00000000..34645602
--- /dev/null
+++ b/servlet4/scinitializer/src/main/java/cloud/piranha/servlet4/scinitializer/ServletContainerInitializerExtension.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.scinitializer;
+
+import static java.util.Collections.emptyList;
+import static java.util.logging.Level.FINE;
+import static java.util.logging.Level.FINER;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ServiceLoader;
+import java.util.logging.Logger;
+
+import javax.servlet.ServletContainerInitializer;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationExtension;
+
+/**
+ * The WebApplication extension that enables ServletContainerInitializer
+ * processing.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class ServletContainerInitializerExtension implements WebApplicationExtension {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(
+            ServletContainerInitializerExtension.class.getPackage().getName());
+
+    /**
+     * Stores the exclude existing initializers flag.
+     */
+    private final boolean excludeExistingInitializers;
+    
+    /**
+     * Stores the initializers to be ignored.
+     */
+    private final List<String> ignoreInitializers;
+
+    /**
+     * Constructor.
+     */
+    public ServletContainerInitializerExtension() {
+        this(false, emptyList());
+    }
+
+    /**
+     * Constructor.
+     * 
+     * @param excludeExistingInitializers the exclude existing initializers flag.
+     * @param ignoreInitializers ignore the given initializers.
+     */
+    public ServletContainerInitializerExtension(boolean excludeExistingInitializers, List<String> ignoreInitializers) {
+        this.excludeExistingInitializers = excludeExistingInitializers;
+        this.ignoreInitializers = new ArrayList<>(ignoreInitializers);
+    }
+
+    /**
+     * Configure the web application.
+     *
+     * @param webApplication the web application.
+     */
+    @Override
+    public void configure(WebApplication webApplication) {
+        LOGGER.log(FINER, "Starting ServletContainerInitializer processing");
+        ServiceLoader<ServletContainerInitializer> serviceLoader = ServiceLoader.load(
+                ServletContainerInitializer.class, webApplication.getClassLoader());
+
+        for (ServletContainerInitializer initializer : serviceLoader) {
+            LOGGER.log(FINE, () -> "Adding initializer: " + initializer.getClass().getName());
+
+            if (shouldAdd(webApplication, initializer)) {
+                webApplication.addInitializer(initializer);
+            }
+        }
+
+        if (this.getClass().getModule().isNamed()) {
+            // We are running in a modular environment,
+            // the providers from modules aren't available in the webApplication classloader
+            serviceLoader = ServiceLoader.load(ServletContainerInitializer.class);
+            for (ServletContainerInitializer initializer : serviceLoader) {
+                LOGGER.log(FINE, () -> "Adding initializer: " + initializer.getClass().getName());
+
+                if (shouldAdd(webApplication, initializer)) {
+                    webApplication.addInitializer(initializer);
+                }
+            }
+        }
+
+        LOGGER.log(FINER, "Finished ServletContainerInitializer processing");
+    }
+
+    private boolean shouldAdd(WebApplication webApplication, ServletContainerInitializer initializer) {
+        if (isIgnored(initializer)) {
+            return false;
+        }
+
+        if (!excludeExistingInitializers) {
+            return true;
+        }
+
+        return !containsInstance(webApplication, initializer);
+    }
+
+    private boolean containsInstance(WebApplication webApplication, ServletContainerInitializer initializer) {
+        return webApplication.getInitializers()
+                             .stream()
+                             .anyMatch(e -> e.getClass().equals(initializer.getClass()));
+    }
+
+    private boolean isIgnored(ServletContainerInitializer initializer) {
+        return ignoreInitializers
+                             .stream()
+                             .anyMatch(e -> e.equals(initializer.getClass().getName()));
+    }
+
+
+}
diff --git a/servlet4/scinitializer/src/main/java/module-info.java b/servlet4/scinitializer/src/main/java/module-info.java
new file mode 100644
index 00000000..d39bdfd2
--- /dev/null
+++ b/servlet4/scinitializer/src/main/java/module-info.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+import javax.servlet.ServletContainerInitializer;
+
+module cloud.piranha.servlet4.scinitializer {
+
+    exports cloud.piranha.servlet4.scinitializer;
+    opens cloud.piranha.servlet4.scinitializer;
+    requires cloud.piranha.servlet4.api;
+    requires cloud.piranha.servlet4.webapp;
+    requires java.logging;
+    uses ServletContainerInitializer;
+}
diff --git a/servlet4/scinitializer/src/test/java/cloud/piranha/servlet4/scinitializer/ServletContainerInitializerExtensionTest.java b/servlet4/scinitializer/src/test/java/cloud/piranha/servlet4/scinitializer/ServletContainerInitializerExtensionTest.java
new file mode 100644
index 00000000..f00f30a5
--- /dev/null
+++ b/servlet4/scinitializer/src/test/java/cloud/piranha/servlet4/scinitializer/ServletContainerInitializerExtensionTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.scinitializer;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the ServletContainerInitializerExtension class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletContainerInitializerExtensionTest {
+
+    /**
+     * Test configure method.
+     */
+    @Test
+    void testConfigure() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        ServletContainerInitializerExtension extension = new ServletContainerInitializerExtension();
+        extension.configure(webApplication);
+    }
+}
diff --git a/servlet4/tempdir/pom.xml b/servlet4/tempdir/pom.xml
new file mode 100644
index 00000000..779680b2
--- /dev/null
+++ b/servlet4/tempdir/pom.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha.servlet4</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>piranha-servlet4-tempdir</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Piranha Servlet 4 - TEMPDIR Integration</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-impl</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-webapp</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/servlet4/tempdir/src/main/java/cloud/piranha/servlet4/tempdir/TempDirExtension.java b/servlet4/tempdir/src/main/java/cloud/piranha/servlet4/tempdir/TempDirExtension.java
new file mode 100644
index 00000000..a7a0d7d7
--- /dev/null
+++ b/servlet4/tempdir/src/main/java/cloud/piranha/servlet4/tempdir/TempDirExtension.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.tempdir;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.servlet.ServletContainerInitializer;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationExtension;
+
+/**
+ * The TEMPDIR WebApplicationExtension.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TempDirExtension implements WebApplicationExtension {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(
+            TempDirExtension.class.getPackage().getName());
+
+    /**
+     * Configure the web application.
+     *
+     * @param webApplication the web application.
+     */
+    @Override
+    public void configure(WebApplication webApplication) {
+        try {
+            ClassLoader classLoader = webApplication.getClassLoader();
+
+            Class<? extends ServletContainerInitializer> clazz
+                    = classLoader.
+                            loadClass(TempDirInitializer.class.getName())
+                            .asSubclass(ServletContainerInitializer.class);
+
+            ServletContainerInitializer initializer
+                    = clazz.getDeclaredConstructor().newInstance();
+
+            webApplication.addInitializer(initializer);
+
+        } catch (ClassNotFoundException | NoSuchMethodException | SecurityException
+                | InstantiationException | IllegalAccessException
+                | IllegalArgumentException | InvocationTargetException ex) {
+            LOGGER.log(Level.WARNING, "Unable to enable TEMPDIR WebApplicationExtension", ex);
+        }
+    }
+}
diff --git a/servlet4/tempdir/src/main/java/cloud/piranha/servlet4/tempdir/TempDirInitializer.java b/servlet4/tempdir/src/main/java/cloud/piranha/servlet4/tempdir/TempDirInitializer.java
new file mode 100644
index 00000000..0f393561
--- /dev/null
+++ b/servlet4/tempdir/src/main/java/cloud/piranha/servlet4/tempdir/TempDirInitializer.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.tempdir;
+
+import static java.util.logging.Level.FINE;
+import static javax.servlet.ServletContext.TEMPDIR;
+
+import java.io.File;
+import java.util.Set;
+import java.util.logging.Logger;
+
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+
+/**
+ * The ServletContext temporary directory initializer.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TempDirInitializer implements ServletContainerInitializer {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(TempDirInitializer.class.getName());
+
+    /**
+     * On startup.
+     *
+     * @param classes the classes.
+     * @param servletContext the servlet context.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
+        File baseDir = new File("tmp");
+        String name = servletContext.getContextPath();
+        name = name.replaceAll("/", "_");
+        if (name.trim().equals("")) {
+            name = "ROOT";
+        }
+        File tempDir = new File(baseDir, name);
+        if (!tempDir.exists()) {
+            tempDir.mkdirs();
+        }
+        LOGGER.log(FINE, "Setting TEMPDIR for context ''{0}'' to ''{1}''",
+                new Object[]{servletContext.getContextPath(), tempDir});
+        servletContext.setAttribute(TEMPDIR, tempDir);
+    }
+}
diff --git a/servlet4/tempdir/src/main/java/module-info.java b/servlet4/tempdir/src/main/java/module-info.java
new file mode 100644
index 00000000..9ff6f58d
--- /dev/null
+++ b/servlet4/tempdir/src/main/java/module-info.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+module cloud.piranha.servlet4.tempdir {
+    
+    exports cloud.piranha.servlet4.tempdir;
+    opens cloud.piranha.servlet4.tempdir;
+    requires cloud.piranha.servlet4.api;
+    requires cloud.piranha.servlet4.webapp;
+    requires java.logging;
+}
diff --git a/servlet4/tempdir/src/test/java/cloud/piranha/servlet4/tempdir/tests/TempDirInitializerTest.java b/servlet4/tempdir/src/test/java/cloud/piranha/servlet4/tempdir/tests/TempDirInitializerTest.java
new file mode 100644
index 00000000..34137134
--- /dev/null
+++ b/servlet4/tempdir/src/test/java/cloud/piranha/servlet4/tempdir/tests/TempDirInitializerTest.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.tempdir.tests;
+
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.tempdir.TempDirInitializer;
+import java.io.File;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit test for the TempDirInitializer class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class TempDirInitializerTest {
+
+    /**
+     * Test of onStartup method, of class TempDirInitializer.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testOnStartup() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.setContextPath("my_servlet_context_name");
+        TempDirInitializer initializer = new TempDirInitializer();
+        initializer.onStartup(null, webApplication);
+        File tempDir = new File("tmp/my_servlet_context_name");
+        assertTrue(tempDir.exists());
+        tempDir.delete();
+        tempDir.getParentFile().delete();
+    }
+}
diff --git a/pages/jasper/src/test/java/module-info.java b/servlet4/tempdir/src/test/java/module-info.java
similarity index 76%
rename from pages/jasper/src/test/java/module-info.java
rename to servlet4/tempdir/src/test/java/module-info.java
index ab657ecf..0bbef3c4 100644
--- a/pages/jasper/src/test/java/module-info.java
+++ b/servlet4/tempdir/src/test/java/module-info.java
@@ -26,21 +26,11 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-module cloud.piranha.pages.jasper.tests {
+module cloud.piranha.servlet4.tempdir.tests {
     
-    exports cloud.piranha.pages.jasper.tests;
-
-    opens cloud.piranha.pages.jasper.tests;
-
-    requires cloud.piranha.embedded;
-    requires cloud.piranha.pages.jasper;
-    requires cloud.piranha.resource;
-    requires cloud.piranha.servlet.api;
-    requires cloud.piranha.webapp.api;
-    requires cloud.piranha.webapp.impl;
-    requires jakarta.el;
-    requires jakarta.servlet.jsp.api;
-    requires jakarta.servlet.jsp;
-    requires java.logging;
+    exports cloud.piranha.servlet4.tempdir.tests;
+    opens cloud.piranha.servlet4.tempdir.tests;
+    requires cloud.piranha.servlet4.impl;
+    requires cloud.piranha.servlet4.tempdir;
     requires org.junit.jupiter.api;
 }
diff --git a/servlet4/webannotation/pom.xml b/servlet4/webannotation/pom.xml
new file mode 100644
index 00000000..acec1254
--- /dev/null
+++ b/servlet4/webannotation/pom.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha.servlet4</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>piranha-servlet4-webannotation</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Piranha Servlet 4 - Web Annotation Integration</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-webapp</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>jakarta.annotation</groupId>
+            <artifactId>jakarta.annotation-api</artifactId>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/servlet4/webannotation/src/main/java/cloud/piranha/servlet4/webannotation/WebAnnotationExtension.java b/servlet4/webannotation/src/main/java/cloud/piranha/servlet4/webannotation/WebAnnotationExtension.java
new file mode 100644
index 00000000..2676ba39
--- /dev/null
+++ b/servlet4/webannotation/src/main/java/cloud/piranha/servlet4/webannotation/WebAnnotationExtension.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webannotation;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.servlet.ServletContainerInitializer;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationExtension;
+
+/**
+ * The extension for WebAnnotation processing.
+ *
+ * @author Thiago Henrique Hupner
+ */
+public class WebAnnotationExtension implements WebApplicationExtension {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(WebAnnotationExtension.class.getName());
+
+    /**
+     * Configure the web application.
+     *
+     * @param webApplication the web application.
+     */
+    @Override
+    public void configure(WebApplication webApplication) {
+        try {
+            ClassLoader classLoader = webApplication.getClassLoader();
+            Class<? extends ServletContainerInitializer> clazz
+                    = classLoader
+                        .loadClass(WebAnnotationInitializer.class.getName())
+                        .asSubclass(ServletContainerInitializer.class);
+            ServletContainerInitializer initializer = clazz.getDeclaredConstructor().newInstance();
+            webApplication.addInitializer(initializer);
+        } catch (ClassNotFoundException | NoSuchMethodException | SecurityException
+                | InstantiationException | IllegalAccessException
+                | IllegalArgumentException | InvocationTargetException ex) {
+            LOGGER.log(Level.WARNING, "Unable to enable the WebAnnotationExtension", ex);
+        }
+    }
+}
diff --git a/servlet4/webannotation/src/main/java/cloud/piranha/servlet4/webannotation/WebAnnotationInitializer.java b/servlet4/webannotation/src/main/java/cloud/piranha/servlet4/webannotation/WebAnnotationInitializer.java
new file mode 100644
index 00000000..4e68b214
--- /dev/null
+++ b/servlet4/webannotation/src/main/java/cloud/piranha/servlet4/webannotation/WebAnnotationInitializer.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webannotation;
+
+import static java.util.Arrays.asList;
+import static java.util.Arrays.stream;
+import static java.util.EnumSet.noneOf;
+import static java.util.stream.Collectors.toCollection;
+
+import java.util.AbstractMap.SimpleImmutableEntry;
+import java.util.ArrayList;
+import java.util.EventListener;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.logging.Logger;
+
+import javax.annotation.security.DeclareRoles;
+import javax.annotation.security.RolesAllowed;
+import javax.servlet.DispatcherType;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration.Dynamic;
+import javax.servlet.annotation.ServletSecurity;
+import javax.servlet.annotation.WebFilter;
+import javax.servlet.annotation.WebListener;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+
+import cloud.piranha.servlet4.webapp.AnnotationManager;
+import cloud.piranha.servlet4.webapp.AnnotationManager.AnnotationInfo;
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The web annotations initializer.
+ *
+ * <p>
+ * This class initializes web artifacts based on annotations in a similar way as
+ *
+ *
+ *
+ *
+ * @author Arjan Tijms
+ */
+public class WebAnnotationInitializer implements ServletContainerInitializer {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(WebAnnotationInitializer.class.getName());
+
+    /**
+     * On startup.
+     *
+     * @param classes the classes.
+     * @param servletContext the servlet context.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
+        WebApplication webApp = (WebApplication) servletContext;
+
+        AnnotationManager annotationManager = webApp.getAnnotationManager();
+
+        // Process @WebServlet
+
+        for (AnnotationInfo<WebServlet> annotationInfo : annotationManager.getAnnotations(WebServlet.class)) {
+
+            WebServlet webServlet = annotationInfo.getInstance();
+
+            String servletName = webServlet.name();
+            if ("".equals(servletName)) {
+                servletName = annotationInfo.getTargetType().getName(); // WebServlet only has target Type
+            }
+
+            // Add the Servlet
+            Dynamic registration = webApp.addServlet(servletName, annotationInfo.getTargetType().getName());
+
+            // Add params
+            if (webServlet.initParams().length != 0) {
+                stream(webServlet.initParams()).forEach(initParam -> registration.setInitParameter(initParam.name(), initParam.value()));
+            }
+
+            if (registration != null)
+                registration.setAsyncSupported(webServlet.asyncSupported());
+
+            String[] urlPatterns = webServlet.value();
+            if (urlPatterns.length == 0) {
+                urlPatterns = webServlet.urlPatterns();
+            }
+
+            // Add mapping
+            webApp.addServletMapping(servletName, urlPatterns);
+        }
+
+        // Process @WebFilter
+
+        for (AnnotationInfo<WebFilter> annotationInfo : annotationManager.getAnnotations(WebFilter.class)) {
+
+            WebFilter webFilter = annotationInfo.getInstance();
+
+            String filterName = webFilter.filterName();
+            if ("".equals(filterName)) {
+                filterName = annotationInfo.getTargetType().getName(); // WebServlet only has target Type
+            }
+
+            // Add the Filter
+            FilterRegistration.Dynamic registration = webApp.addFilter(filterName, annotationInfo.getTargetType().getName());
+
+            // Add params
+            if (webFilter.initParams().length != 0) {
+                stream(webFilter.initParams()).forEach(initParam ->
+                    registration.setInitParameter(initParam.name(), initParam.value())
+                );
+            }
+
+            if (registration != null)
+                registration.setAsyncSupported(webFilter.asyncSupported());
+
+            String[] urlPatterns = webFilter.value();
+            if (urlPatterns.length == 0) {
+                urlPatterns = webFilter.urlPatterns();
+            }
+
+            // Add mapping for URL patterns, if any
+            if (urlPatterns.length > 0) {
+                webApp.addFilterMapping(filterName, urlPatterns);
+            }
+
+            // Add mapping for Servlet names, if any
+            if (webFilter.servletNames().length > 0) {
+                registration.addMappingForServletNames(
+                    stream(webFilter.dispatcherTypes())
+                        .collect(toCollection(() -> noneOf(DispatcherType.class))),
+                    true,
+                    webFilter.servletNames());
+            }
+        }
+
+        // Process @ServletSecurity
+        List<Entry<List<String>, ServletSecurity>> securityAnnotations = new ArrayList<>();
+        for (AnnotationInfo<ServletSecurity> annotationInfo : annotationManager.getAnnotations(ServletSecurity.class)) {
+
+            Class<?> servlet = getTargetServlet(annotationInfo);
+
+            // Take into account mixed mapped (annotation + web.xml later)
+            WebServlet webServlet = servlet.getAnnotation(WebServlet.class);
+
+            if (webServlet != null) {
+                String[] urlPatterns = webServlet.value();
+                if (urlPatterns.length == 0) {
+                    urlPatterns = webServlet.urlPatterns();
+                }
+
+                securityAnnotations.add(new SimpleImmutableEntry<>(
+                    asList(urlPatterns),
+                    annotationInfo.getInstance()));
+            } else {
+                LOGGER.warning(
+                    "@ServletSecurity encountered on Servlet " + servlet +
+                    "but no @WebServlet encountered");
+            }
+        }
+        webApp.setAttribute(
+            "cloud.piranha.authorization.exousia.AuthorizationPreInitializer.security.annotations",
+            securityAnnotations
+        );
+
+        // Collect the roles from various annotations
+        for (AnnotationInfo<RolesAllowed> rolesAllowedInfo : annotationManager.getAnnotations(RolesAllowed.class)) {
+            webApp.declareRoles(rolesAllowedInfo.getInstance().value());
+        }
+
+        for (AnnotationInfo<DeclareRoles> declareRolesInfo : annotationManager.getAnnotations(DeclareRoles.class)) {
+            webApp.declareRoles(declareRolesInfo.getInstance().value());
+        }
+
+        // Process @WebListener
+        for (AnnotationInfo<WebListener> annotationInfo : annotationManager.getAnnotations(WebListener.class)) {
+            webApp.addListener(getTargetListener(annotationInfo));
+        }
+
+        webApp.initializeDeclaredFinish();
+    }
+
+    @SuppressWarnings("unchecked")
+    private Class<? extends EventListener> getTargetListener(AnnotationInfo<WebListener> annotationInfo) {
+        return (Class<? extends EventListener>) annotationInfo.getTargetType();
+    }
+
+    @SuppressWarnings("unchecked")
+    private Class<? extends HttpServlet> getTargetServlet(AnnotationInfo<ServletSecurity> annotationInfo) {
+        return (Class<? extends HttpServlet>) annotationInfo.getTargetType();
+    }
+
+}
diff --git a/servlet4/webannotation/src/main/java/module-info.java b/servlet4/webannotation/src/main/java/module-info.java
new file mode 100644
index 00000000..d7e513d3
--- /dev/null
+++ b/servlet4/webannotation/src/main/java/module-info.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+module cloud.piranha.servlet4.webannotation {
+    
+    exports cloud.piranha.servlet4.webannotation;
+    requires cloud.piranha.servlet4.api;
+    requires cloud.piranha.servlet4.webapp;
+    requires java.annotation;
+    requires java.logging;
+}
diff --git a/servlet4/webapp/pom.xml b/servlet4/webapp/pom.xml
new file mode 100644
index 00000000..8f87b811
--- /dev/null
+++ b/servlet4/webapp/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha.servlet4</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>piranha-servlet4-webapp</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Piranha Servlet 4 - Webapplication API</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>cloud.piranha.http</groupId>
+            <artifactId>piranha-http-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.naming</groupId>
+            <artifactId>piranha-naming-api</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.policy</groupId>
+            <artifactId>piranha-policy-api</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.resource</groupId>
+            <artifactId>piranha-resource-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AnnotationManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AnnotationManager.java
new file mode 100644
index 00000000..da4f3b9f
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AnnotationManager.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.lang.reflect.AnnotatedElement;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * The AnnotationManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ * @author Arjan Tijms
+ */
+public interface AnnotationManager {
+
+    /**
+     * The annotation information.
+     * 
+     * @param <T> the type.
+     */
+    interface AnnotationInfo<T> {
+        
+        /**
+         * Get the instance.
+         * 
+         * @return the instance.
+         */
+        T getInstance();
+        
+        /**
+         * Get the target.
+         * 
+         * @return the target.
+         */
+        AnnotatedElement getTarget();
+
+        /**
+         * Get the target.
+         * 
+         * @return the class.
+         */
+        default Class<?> getTargetType() {
+            AnnotatedElement element = getTarget();
+            if (element instanceof Class<?>) {
+                return (Class<?>) element;
+            }
+
+            return null;
+        }
+    }
+
+    /**
+     * Get the annotations.
+     * 
+     * @param <T> the type.
+     * @param annotationClass the annotation class.
+     * @return the typed list of annotations.
+     */
+    <T> List<AnnotationInfo<T>> getAnnotations(Class<T> annotationClass);
+    
+    /**
+     * Get the annotations.
+     * 
+     * @param annotationClasses the annotation classes.
+     * @return the list of annotations.
+     */
+    List<AnnotationInfo<?>> getAnnotations(Class<?>... annotationClasses);
+
+    /**
+     * Get the instances.
+     * 
+     * @param <T> the type.
+     * @param instanceClass the instance class.
+     * @return the typed list of instances.
+     */
+    <T> List<Class<T>> getInstances(Class<T> instanceClass);
+    
+    /**
+     * Get the instances.
+     * 
+     * @param instanceClasses the instance classes.
+     * @return the list of instances.
+     */
+    List<Class<?>> getInstances(Class<?>... instanceClasses);
+
+
+    /**
+     * Get the set of all annotated classes.
+     *
+     * @return the set of all annotated classes
+     */
+    Set<Class<?>> getAnnotatedClasses();
+    
+    /**
+     * Get the annotation for the annotation class and annotated element type.
+     * 
+     * @param <T> the type.
+     * @param annotationClass the annotation class.
+     * @param type the annotated element type.
+     * @return the list of annotations.
+     */
+    <T> List<AnnotationInfo<T>> getAnnotationsByTarget(Class<T> annotationClass, AnnotatedElement type);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AsyncDispatcher.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AsyncDispatcher.java
new file mode 100644
index 00000000..1b10a10e
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AsyncDispatcher.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+/**
+ * The AsyncDispatcher API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface AsyncDispatcher {
+
+    /**
+     * Dispatch.
+     */
+    void dispatch();
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AsyncManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AsyncManager.java
new file mode 100644
index 00000000..135b9a50
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AsyncManager.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * The AsyncManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface AsyncManager {
+
+    /**
+     * Get the async dispatcher.
+     *
+     * @param webApplication the web application.
+     * @param path the path.
+     * @param asyncStartRequest the servlet request coming from a call to request.asyncStart.
+     * @param asyncStartResponse the servlet response coming from a call to request.asyncStart.
+     * @return the async dispatcher.
+     */
+    AsyncDispatcher getDispatcher(WebApplication webApplication, String path, ServletRequest asyncStartRequest, ServletResponse asyncStartResponse);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AttributeManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AttributeManager.java
new file mode 100644
index 00000000..729bbc2d
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AttributeManager.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.util.Enumeration;
+
+/**
+ * The AttributeManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface AttributeManager {
+
+    /**
+     * Get the attribute.
+     *
+     * @param name the name.
+     * @return the value.
+     */
+    Object getAttribute(String name);
+
+    /**
+     * Get the attribute names.
+     *
+     * @return the attribute names.
+     */
+    Enumeration<String> getAttributeNames();
+
+    /**
+     * Remove the attribute.
+     *
+     * @param name the name.
+     */
+    void removeAttribute(String name);
+
+    /**
+     * Set the attribute.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    void setAttribute(String name, Object value);
+    
+    /**
+     * Checks if this manager has the given attribute
+     * @param name the name of the attribute to check for
+     * @return true if this manager contains the attribute, false otherwise
+     */
+    default boolean containsAttribute(String name) {
+        return getAttribute(name) != null;
+    }
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AuthenticatedIdentity.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AuthenticatedIdentity.java
new file mode 100644
index 00000000..34f741b1
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/AuthenticatedIdentity.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.security.Principal;
+import java.util.Set;
+
+/**
+ * This interface is implemented by classes that represent the current authenticated identity.
+ *
+ * <p>
+ * What current means here is context dependent. In a Jakarta Servlet application this refers
+ * to the caller (user) details during a single HTTP request.
+ *
+ * @author Arjan Tijms
+ *
+ */
+public interface AuthenticatedIdentity extends Principal {
+
+    @Override
+    default String getName() {
+        if (getCallerPrincipal() == null) {
+            return null;
+        }
+
+        return getCallerPrincipal().getName();
+    }
+
+    /**
+     * Returns the caller principal, which represents the primary name of the calling entity (aka the "caller")
+     * to a server.
+     *
+     * @return the caller principal, or null if authentication has not (yet) completed successfully.
+     */
+    Principal getCallerPrincipal();
+
+    /**
+     * The groups the caller is in.
+     *
+     * <p>
+     * If group to role mapping is not active (the default) groups are equal to roles.
+     *
+     * @return the set of groups the caller is in, never null.
+     */
+    Set<String> getGroups();
+
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/CurrentRequestHolder.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/CurrentRequestHolder.java
new file mode 100644
index 00000000..fe561018
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/CurrentRequestHolder.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import javax.servlet.http.HttpServletRequest;
+
+/**
+ * A holder that references the current <code>HttpServletRequest </code>in the request processing
+ * pipeline.
+ *
+ * <p>
+ * This structure allows the runtime to set what constitutes this <em>current</em> at any given
+ * time.
+ *
+ * @author Arjan Tijms
+ *
+ */
+public interface CurrentRequestHolder {
+
+    /**
+     * The request attribute under a holder implementation is stored in the request
+     */
+    String CURRENT_REQUEST_ATTRIBUTE = CurrentRequestHolder.class.getName();
+
+    /**
+     * Gets the current HttpServletRequest
+     *
+     * @param <T> the actual implementation of the current HttpServletRequest
+     * @return the current HttpServletRequest
+     */
+    <T extends HttpServletRequest> T getRequest();
+
+    /**
+     * Sets the current HttpServletRequest
+     *
+     * @param request the current HttpServletRequest
+     */
+    void setRequest(HttpServletRequest request);
+
+
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterEnvironment.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterEnvironment.java
new file mode 100644
index 00000000..19b39e6e
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterEnvironment.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterConfig;
+import javax.servlet.FilterRegistration.Dynamic;
+import javax.servlet.ServletException;
+
+/**
+ *
+ * @author Arjan Tijms
+ *
+ */
+public interface FilterEnvironment extends Dynamic, FilterConfig {
+
+    /**
+     * Defines the UNAVAILABLE constant.
+     */
+    int UNAVAILABLE = -1;
+
+    /**
+     * Get the filter.
+     *
+     * @return the filter.
+     */
+    Filter getFilter();
+
+    /**
+     * Initialize the filter.
+     *
+     * @throws ServletException when a servlet error occurs.
+     */
+    void initialize() throws ServletException;
+
+    /**
+     * Set the class name.
+     *
+     * @param className the class name.
+     */
+    void setClassName(String className);
+
+    /**
+     * Set the filter name.
+     *
+     * @param filterName the filter name.
+     */
+    void setFilterName(String filterName);
+
+    /**
+     * Set status.
+     *
+     * @param status the status.
+     */
+    void setStatus(int status);
+
+    /**
+     * Get the web application.
+     *
+     * @return the web application.
+     */
+    WebApplication getWebApplication();
+
+    /**
+     * Set the web application.
+     *
+     * @param webApplication the web application.
+     */
+    void setWebApplication(WebApplication webApplication);
+
+    /**
+     * Is async supported.
+     *
+     * @return true if it is, false otherwise.
+     */
+    boolean isAsyncSupported();
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterMapping.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterMapping.java
new file mode 100644
index 00000000..45f5ca7f
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterMapping.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import static javax.servlet.DispatcherType.REQUEST;
+
+import javax.servlet.DispatcherType;
+
+/**
+ * The FilterMapping API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface FilterMapping {
+
+    /**
+     * Get the filter name.
+     *
+     * @return the filter name.
+     */
+    String getFilterName();
+
+    /**
+     * Get the URL pattern.
+     *
+     * @return the URL pattern.
+     */
+    String getUrlPattern();
+
+    /**
+     * Get the dispatcher type.
+     *
+     * <p>
+     * The dispatcher type is the kind of dispatch that the filter
+     * mapping applies to. Default is REQUEST, which represents
+     * the request from the user to the system.
+     *
+     * @return the dispatcher type
+     */
+    default DispatcherType getDispatcherType() {
+        return REQUEST;
+    }
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterPriority.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterPriority.java
new file mode 100644
index 00000000..c3f065cf
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/FilterPriority.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+/**
+ * The Filter Priority API allows filters that implement this interface to be given priority
+ * depending on their priority value.
+ *
+ * <p>
+ * Filters with a lower priority are called before filters with a higher priority. Filters
+ * with an explicit priority are called before filters with no priority at all.
+ *
+ * @author Arjan Tijms
+ *
+ */
+public interface FilterPriority {
+
+    /**
+     * Returns the priority of this filter in the filter chain.
+     *
+     * @return the priority value
+     */
+    int getPriority();
+
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpHeader.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpHeader.java
new file mode 100644
index 00000000..12d9a9bb
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpHeader.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.util.Enumeration;
+
+/**
+ * The HttpHeader API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpHeader {
+
+    /**
+     * Add the value.
+     *
+     * @param value the value to add.
+     */
+    void addValue(String value);
+
+    /**
+     * Get the name.
+     *
+     * @return the name.
+     */
+    String getName();
+
+    /**
+     * Get the value.
+     *
+     * @return the value.
+     */
+    String getValue();
+
+    /**
+     * Get the values.
+     *
+     * @return the values.
+     */
+    Enumeration<String> getValues();
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpHeaderManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpHeaderManager.java
new file mode 100644
index 00000000..b10bef5c
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpHeaderManager.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.util.Enumeration;
+
+/**
+ * The HttpHeaderManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpHeaderManager {
+
+    /**
+     * Add the header.
+     *
+     * @param name the name.
+     * @param value the value.
+     */
+    void addHeader(String name, String value);
+
+    /**
+     * Contains the given header.
+     *
+     * @param name the header name.
+     * @return true if there, false otherwise.
+     */
+    boolean containsHeader(String name);
+
+    /**
+     * Get the date header.
+     *
+     * @param name the header name.
+     * @return the date header.
+     * @throws IllegalArgumentException when the header could not be converted
+     * to a date.
+     */
+    long getDateHeader(String name) throws IllegalArgumentException;
+
+    /**
+     * Get the header.
+     *
+     * @param name the header name.
+     * @return the header value.
+     */
+    String getHeader(String name);
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    Enumeration<String> getHeaderNames();
+
+    /**
+     * Get the headers.
+     *
+     * @param name the header name.
+     * @return the header values.
+     */
+    Enumeration<String> getHeaders(String name);
+
+    /**
+     * Get the int header.
+     *
+     * @param name the header name.
+     * @return the int value.
+     * @throws NumberFormatException when the value could not be converted to an
+     * int.
+     */
+    int getIntHeader(String name) throws NumberFormatException;
+
+    /**
+     * Set the header.
+     *
+     * @param name the name.
+     * @param value the value (string).
+     */
+    void setHeader(String name, String value);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpRequestManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpRequestManager.java
new file mode 100644
index 00000000..03581489
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpRequestManager.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.util.EventListener;
+
+import javax.servlet.http.HttpServletRequest;
+
+/**
+ *
+ * @author Arjan Tijms
+ */
+public interface HttpRequestManager {
+
+    /**
+     * Add a listener.
+     *
+     * @param <T> the type.
+     * @param listener the listener.
+     */
+    <T extends EventListener> void addListener(T listener);
+
+    /**
+     * Attribute added.
+     *
+     * @param request the HTTP request.
+     * @param name the name.
+     * @param value the value.
+     */
+    void attributeAdded(HttpServletRequest request, String name, Object value);
+
+    /**
+     * Attribute removed.
+     *
+     * @param request the HTTP request.
+     * @param name the name.
+     * @param value the value
+     */
+    void attributeRemoved(HttpServletRequest request, String name, Object value);
+
+    /**
+     * Attribute replaced.
+     *
+     * @param request the HTTP request.
+     * @param name the name.
+     * @param value the value.
+     */
+    void attributeReplaced(HttpServletRequest request, String name, Object value);
+
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpSessionManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpSessionManager.java
new file mode 100644
index 00000000..75922d0c
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/HttpSessionManager.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.util.EventListener;
+import java.util.Set;
+import javax.servlet.SessionCookieConfig;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+
+/**
+ * The HttpSessionManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface HttpSessionManager {
+
+    /**
+     * Add a listener.
+     *
+     * @param <T> the type.
+     * @param listener the listener.
+     */
+    <T extends EventListener> void addListener(T listener);
+
+    /**
+     * Attribute added.
+     *
+     * @param session the HTTP session.
+     * @param name the name.
+     * @param value the value.
+     */
+    void attributeAdded(HttpSession session, String name, Object value);
+
+    /**
+     * Attribute removed.
+     *
+     * @param session the HTTP session.
+     * @param name the name.
+     * @param value the value.
+     */
+    void attributeRemoved(HttpSession session, String name, Object value);
+
+    /**
+     * Attribute replaced.
+     *
+     * @param session the HTTP session.
+     * @param name the name.
+     * @param oldValue the old value.
+     * @param newValue the new value.
+     */
+    void attributeReplaced(HttpSession session, String name, Object oldValue, Object newValue);
+
+    /**
+     * Change the session id and return it.
+     *
+     * @param request the request.
+     * @return the session id.
+     */
+    String changeSessionId(HttpServletRequest request);
+
+    /**
+     * Create a session.
+     *
+     * @param request the request.
+     * @return the session.
+     */
+    HttpSession createSession(HttpServletRequest request);
+
+    /**
+     * Destroys a session.
+     *
+     * @param session the HTTP session.
+     */
+    void destroySession(HttpSession session);
+
+    /**
+     * Encode the redirect URL.
+     *
+     * @param response the HTTP servlet response.
+     * @param url the URL.
+     * @return the encode URL.
+     */
+    String encodeRedirectURL(HttpServletResponse response, String url);
+
+    /**
+     * Encode the URL.
+     *
+     * @param response the HTTP servlet response.
+     * @param url the URL.
+     * @return the encoded URL.
+     */
+    String encodeURL(HttpServletResponse response, String url);
+
+    /**
+     * Get the default session tracking modes.
+     *
+     * @return the default session tracking modes.
+     */
+    Set<SessionTrackingMode> getDefaultSessionTrackingModes();
+
+    /**
+     * Get the effective session tracking modes.
+     *
+     * @return the effective session tracking modes.
+     */
+    Set<SessionTrackingMode> getEffectiveSessionTrackingModes();
+
+    /**
+     * Get the session.
+     *
+     * @param request the request.
+     * @param currentSessionId the current session id.
+     * @return the session.
+     */
+    HttpSession getSession(HttpServletRequest request, String currentSessionId);
+
+    /**
+     * Get the session cookie config.
+     *
+     * @return the session cookie config.
+     */
+    SessionCookieConfig getSessionCookieConfig();
+
+    /**
+     * Get the session timeout (in minutes).
+     *
+     * @return the session timeout.
+     */
+    int getSessionTimeout();
+
+    /**
+     * Is the session manager handling this session?
+     *
+     * @param sessionId the session id.
+     * @return true if there is a session with the given session id.
+     */
+    boolean hasSession(String sessionId);
+
+    /**
+     * Set the session timeout (in minutes).
+     *
+     * @param timeout the timeout.
+     */
+    void setSessionTimeout(int timeout);
+
+    /**
+     * Set the session tracking modes.
+     *
+     * @param sessionTrackingModes the session tracking modes.
+     */
+    void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes);
+
+    /**
+     * Set the web application.
+     * 
+     * @param webApplication the web application.
+     */
+    void setWebApplication(WebApplication webApplication);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/JspManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/JspManager.java
new file mode 100644
index 00000000..6a2d42eb
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/JspManager.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import javax.servlet.ServletRegistration;
+import javax.servlet.descriptor.JspConfigDescriptor;
+
+/**
+ * The JspManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface JspManager {
+
+    /**
+     * Add the JSP file.
+     *
+     * @param webApplication the web application.
+     * @param servletName the servlet name.
+     * @param jspFile the jsp file.
+     * @return the servlet registration.
+     */
+    ServletRegistration.Dynamic addJspFile(WebApplication webApplication, String servletName, String jspFile);
+
+    /**
+     * Get the JSP config descriptor.
+     *
+     * @return the JSP config descriptor.
+     */
+    JspConfigDescriptor getJspConfigDescriptor();
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/LocaleEncodingManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/LocaleEncodingManager.java
new file mode 100644
index 00000000..2397ddcb
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/LocaleEncodingManager.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+/**
+ * The LocaleEncodingManager API.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface LocaleEncodingManager {
+
+    /**
+     * Add a mapping between a locale and an encoding
+     * @param locale the locale to be the key
+     * @param encoding the encoding to be the value
+     */
+    void addCharacterEncoding(String locale, String encoding);
+
+
+    /**
+     * Get the encoding for the locale
+     * @param locale the locale
+     * @return the encoding for the locale, null otherwise
+     */
+    String getCharacterEncoding(String locale);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/LoggingManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/LoggingManager.java
new file mode 100644
index 00000000..b4cf89ad
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/LoggingManager.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+/**
+ * The LoggingManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface LoggingManager {
+
+    /**
+     * Log the message.
+     *
+     * @param message the message.
+     * @param throwable the throwable.
+     */
+    void log(String message, Throwable throwable);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/MimeTypeManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/MimeTypeManager.java
new file mode 100644
index 00000000..d01166e1
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/MimeTypeManager.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+/**
+ * The MimeTypeManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface MimeTypeManager {
+
+    /**
+     * Add the mime type.
+     *
+     * @param extension the extension (without the dot).
+     * @param mimeType the mime type to return.
+     */
+    void addMimeType(String extension, String mimeType);
+
+    /**
+     * Get the mime type.
+     *
+     * @param filename the filename.
+     * @return the mime type or null if not found.
+     */
+    String getMimeType(String filename);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/MultiPartManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/MultiPartManager.java
new file mode 100644
index 00000000..15529393
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/MultiPartManager.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.util.Collection;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Part;
+
+/**
+ * The multi-part manager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface MultiPartManager {
+
+    /**
+     * Get the parts.
+     *
+     * @param webApplication the web application.
+     * @param request the web application request.
+     * @return the parts.
+     * @throws ServletException when the request is not a multipart/form-data request.
+     */
+    Collection<Part> getParts(WebApplication webApplication, WebApplicationRequest request) throws ServletException;
+
+    /**
+     * Get the part.
+     *
+     * @param webApplication the web application.
+     * @param request the web application request.
+     * @param name the name of the part.
+     * @return the part, or null if not found.
+     * @throws ServletException when the request is not a multipart/form-data request.
+     */
+    Part getPart(WebApplication webApplication, WebApplicationRequest request, String name) throws ServletException;
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ObjectInstanceManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ObjectInstanceManager.java
new file mode 100644
index 00000000..f8a4437b
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ObjectInstanceManager.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.util.EventListener;
+
+import javax.servlet.Filter;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
+
+/**
+ * The object instance manager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ObjectInstanceManager {
+
+    /**
+     * Create the filter.
+     *
+     * @param <T> the type.
+     * @param filterClass the Filter class.
+     * @return the Filter.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    <T extends Filter> T createFilter(Class<T> filterClass) throws ServletException;
+
+    /**
+     * Create the listener.
+     *
+     * @param <T> the type.
+     * @param clazz the class.
+     * @return the Listener.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    <T extends EventListener> T createListener(Class<T> clazz) throws ServletException;
+
+    /**
+     * Create the servlet.
+     *
+     * @param <T> the type.
+     * @param clazz the Servlet class.
+     * @return the Servlet.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException;
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/SecurityManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/SecurityManager.java
new file mode 100644
index 00000000..f543d644
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/SecurityManager.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Set;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * The SecurityManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ * @author Arjan Tijms
+ */
+public interface SecurityManager {
+
+    /**
+     * The enum that qualifies the source of the authentication.
+     */
+    enum AuthenticateSource {
+        /**
+         * The container / runtime calls authenticate before a request
+         */
+        PRE_REQUEST_CONTAINER,
+        /**
+         * The user (code) has programmatically called authenticate
+         */
+        MID_REQUEST_USER
+    }
+
+    /**
+     * Method that bypasses the authentication mechanism installed by the
+     * authentication manager and directly invokes an identity store.
+     */
+    interface UsernamePasswordLoginHandler {
+
+        /**
+         * Login.
+         * 
+         * @param request the request.
+         * @param username the username.
+         * @param password the password.
+         * @return the authenticated identity.
+         */
+        AuthenticatedIdentity login(HttpServletRequest request, String username, String password);
+    }
+
+    /**
+     * Get if we are denying uncovered HTTP methods.
+     *
+     * @return true if we are, false otherwise.
+     */
+    boolean getDenyUncoveredHttpMethods();
+
+    /**
+     * Check if the current request adheres to the user data constraint, if any.
+     *
+     * <p>
+     * In practice this means checking if HTTPS is used when so required by the
+     * application.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @return true if request adheres to constraints, false otherwise
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    default boolean isRequestSecurityAsRequired(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        return true;
+    }
+
+    /**
+     * Check if the requested resource, represented by the request, is public or
+     * not.
+     *
+     * @param request the request.
+     * @return true if the requested resource can be accessed by public
+     * (unauthenticated) callers, otherwise false
+     */
+    default boolean isRequestedResourcePublic(HttpServletRequest request) {
+        return true;
+    }
+
+    /**
+     * Check if the current caller (which can be the anonymous caller) is
+     * authorized to access the requested resource.
+     *
+     * <p>
+     * If the unauthenticated caller is authorized, then this means the resource
+     * is public (aka unconstrained, aka unchecked), and the outcome of this
+     * method MUST be consistent with
+     * {@link #isRequestedResourcePublic(HttpServletRequest)}.
+     *
+     *
+     * @param request the request.
+     * @return true if the current caller is allowed to access the requested
+     * resource, false otherwise
+     */
+    default boolean isCallerAuthorizedForResource(HttpServletRequest request) {
+        return true;
+    }
+
+    /**
+     * Authenticate the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @return true if authenticated.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    boolean authenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;
+
+    /**
+     * Gets the request object the security system wants to put in place.
+     *
+     * <p>
+     * This method allows the security system (or authentication module being
+     * delegated to) a custom or, more likely, wrapped request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @return a request object that the runtime should put into service
+     */
+    default HttpServletRequest getAuthenticatedRequest(HttpServletRequest request, HttpServletResponse response) {
+        return request;
+    }
+
+    /**
+     * Gets the response object the security system wants to put in place.
+     *
+     * <p>
+     * This method allows the security system (or authentication module being
+     * delegated to) a custom or, more likely, wrapped response.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @return a response object that the runtime should put into service
+     */
+    default HttpServletResponse getAuthenticatedResponse(HttpServletRequest request, HttpServletResponse response) {
+        return response;
+    }
+
+    /**
+     * Authenticate the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @param source the source or moment from where this authenticate method is
+     * called
+     * @return true if authenticated.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    default boolean authenticate(HttpServletRequest request, HttpServletResponse response, AuthenticateSource source) throws IOException, ServletException {
+        // By default, source and mandatory directive are ignored, and semantics for the 2 parameter
+        // version hold.
+        // The 2 parameter version is expected to be essentially source = MID_REQUEST_USER
+        return authenticate(request, response);
+    }
+
+    /**
+     * Gives the security system the opportunity to process the response after
+     * the request (after the target resource has been invoked).
+     *
+     * <p>
+     * Although this may be rare to used in practice, it allows for encryption
+     * of the response, inserting security tokens, signing the response, etc.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    default void postRequestProcess(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+    }
+
+    /**
+     * Declare roles.
+     *
+     * @param roles the roles.
+     */
+    void declareRoles(String[] roles);
+
+    /**
+     * Declare roles.
+     *
+     * @param roles the roles.
+     */
+    default void declareRoles(Collection<String> roles) {
+        if (roles == null) {
+            return;
+        }
+
+        declareRoles(roles.toArray(String[]::new));
+    }
+
+    /**
+     * Get the declared roles
+     *
+     * @return the roles
+     */
+    Set<String> getRoles();
+
+    /**
+     * Get the web application.
+     *
+     * @return the web application.
+     */
+    WebApplication getWebApplication();
+
+    /**
+     * Is the user in the specific role.
+     *
+     * @param request the request.
+     * @param role the role.
+     * @return true if in the role, false otherwise.
+     */
+    boolean isUserInRole(HttpServletRequest request, String role);
+
+    /**
+     * Login.
+     *
+     * @param request the request.
+     * @param username the username.
+     * @param password the password.
+     * @throws ServletException when unable to login.
+     */
+    void login(HttpServletRequest request, String username, String password) throws ServletException;
+
+    /**
+     * Logout.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws ServletException when a servlet error occurs.
+     */
+    void logout(HttpServletRequest request, HttpServletResponse response) throws ServletException;
+
+    /**
+     * Set if we are denying uncovered HTTP methods.
+     *
+     * @param denyUncoveredHttpMethods the boolean value.
+     */
+    void setDenyUncoveredHttpMethods(boolean denyUncoveredHttpMethods);
+
+    /**
+     * Set the web application.
+     *
+     * @param webApplication the web application.
+     */
+    void setWebApplication(WebApplication webApplication);
+
+    /**
+     * Set the handler that may be used by the login method to contact an
+     * identity store.
+     *
+     * @param usernamePasswordLoginHandler the handler
+     */
+    default void setUsernamePasswordLoginHandler(UsernamePasswordLoginHandler usernamePasswordLoginHandler) {
+        // do nothing, optional method
+    }
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ServletEnvironment.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ServletEnvironment.java
new file mode 100644
index 00000000..4f9fd26e
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ServletEnvironment.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import javax.servlet.MultipartConfigElement;
+import javax.servlet.Servlet;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletRegistration.Dynamic;
+
+/**
+ * The environment for a Servlet.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface ServletEnvironment extends Dynamic, ServletConfig {
+
+    /**
+     * Defines the UNAVAILABLE constant.
+     */
+    int UNAVAILABLE = -1;
+
+
+    /**
+     * Get the load on startup.
+     *
+     * @return the load on startup.
+     */
+    int getLoadOnStartup();
+
+    /**
+     * Get the multi-part config.
+     *
+     * @return the multi-part config.
+     */
+    MultipartConfigElement getMultipartConfig();
+
+    /**
+     * Get the servlet.
+     *
+     * @return the servlet.
+     */
+    Servlet getServlet();
+
+
+    /**
+     * Get the servlet class.
+     *
+     * @return the servlet class.
+     */
+    Class<? extends Servlet> getServletClass();
+
+    /**
+     * Get the status.
+     *
+     * @return the status.
+     */
+    int getStatus();
+
+    /**
+     * Get the web application.
+     *
+     * @return the web application.
+     */
+    WebApplication getWebApplication();
+
+    /**
+     * Is async supported.
+     *
+     * @return true if it is, false otherwise.
+     */
+    boolean isAsyncSupported();
+
+
+    /**
+     * Set the class name.
+     *
+     * @param className the class name.
+     */
+    void setClassName(String className);
+
+    /**
+     * Set the servlet.
+     *
+     * @param servlet the servlet.
+     */
+    void setServlet(Servlet servlet);
+
+    /**
+     * Set the status.
+     *
+     * @param status the status.
+     */
+    void setStatus(int status);
+
+    /**
+     * The exception that caused this servlet to become unavailable
+     *
+     * @return the exception.
+     */
+    Throwable getUnavailableException();
+
+    /**
+     * Sets the exception that caused this servlet to become unavailable
+     *
+     * @param unavailableException the unavailable exception.
+     */
+    void setUnavailableException(Throwable unavailableException);
+
+}
\ No newline at end of file
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ServletInvocation.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ServletInvocation.java
new file mode 100644
index 00000000..abf0d9f8
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/ServletInvocation.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import static cloud.piranha.servlet4.webapp.ServletEnvironment.UNAVAILABLE;
+
+import java.util.List;
+
+import javax.servlet.FilterChain;
+import javax.servlet.ServletConfig;
+
+/**
+ * The ServletInvocation API.
+ *
+ * <p>
+ * This type holds data necessary to invoke a Servlet.
+ *
+ *
+ * @author Arjan Tijms
+ *
+ */
+public interface ServletInvocation {
+
+    /**
+     * The original path used to base the Servlet invocation on.
+     *
+     * @return the full invocation path
+     */
+    String getInvocationPath();
+
+    /**
+     * Get the servlet name.
+     *
+     * @return the servlet name.
+     */
+    String getServletName();
+
+    /**
+     * Get the servlet path.
+     *
+     * @return the servlet path.
+     */
+    String getServletPath();
+
+    /**
+     * Get the path info.
+     *
+     * @return the path info.
+     */
+    String getPathInfo();
+
+    /**
+     * Get the web application request mapping.
+     *
+     * @return the web application request mapping.
+     */
+    WebApplicationRequestMapping getApplicationRequestMapping();
+
+    /**
+     * Get the servlet environment.
+     *
+     * @return the servlet environment.
+     */
+    ServletEnvironment getServletEnvironment();
+
+    /**
+     * Get the filter environments.
+     *
+     * @return the filter environments.
+     */
+    List<FilterEnvironment> getFilterEnvironments();
+
+    /**
+     * Get the filter chain.
+     *
+     * @return the filter chain.
+     */
+    FilterChain getFilterChain();
+
+    /**
+     * Do we have a servlet.
+     *
+     * @return true if we do, false otherwise.
+     */
+    default boolean hasServlet() {
+        return getServletEnvironment() != null && getServletEnvironment().getServlet() != null;
+    }
+
+    /**
+     * Do we have a filter.
+     *
+     * @return true if we do, false otherwise.
+     */
+    default boolean hasFilter() {
+        return getFilterEnvironments() != null;
+    }
+
+    /**
+     * Is the servlet unavailable.
+     *
+     * @return true if it is, false otherwise.
+     */
+    default boolean isServletUnavailable() {
+        return getServletEnvironment() != null && getServletEnvironment().getStatus() == UNAVAILABLE;
+    }
+
+    /**
+     * Can we invoke.
+     *
+     * @return true if we can, false otherwise.
+     */
+    default boolean canInvoke() {
+        return hasServlet() || hasFilter();
+    }
+
+    /**
+     * Get the servlet configuration.
+     *
+     * @return the servlet configuration.
+     */
+    default ServletConfig getServletConfig() {
+        if (!hasServlet()) {
+            return null;
+        }
+        return getServletEnvironment().getServlet().getServletConfig();
+    }
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplication.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplication.java
new file mode 100644
index 00000000..4469a6b7
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplication.java
@@ -0,0 +1,524 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import cloud.piranha.naming.api.NamingManager;
+import cloud.piranha.policy.api.PolicyManager;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.FilterRegistration;
+import javax.servlet.Servlet;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+import cloud.piranha.resource.api.Resource;
+import cloud.piranha.resource.api.ResourceManager;
+
+/**
+ * The WebApplication API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplication extends ServletContext {
+
+    /**
+     * Adds an error page to be forwarded to on the given HTTP status code
+     *
+     * @param code the HTTP code for which the error page is to be invoked
+     * @param location the location of the error page
+     */
+    void addErrorPage(int code, String location);
+
+    /**
+     * Adds an error page to be forwarded to on the given exception
+     *
+     * @param exception the exception for which the error page is to be invoked
+     * @param location the location of the error page
+     */
+    void addErrorPage(String exception, String location);
+
+    /**
+     * Add a mapping for the given filter.
+     *
+     * @param filterName the filter name.
+     * @param urlPatterns the URL patterns.
+     * @return the possible empty set of already mapped URL patterns.
+     * @see FilterRegistration#addMappingForUrlPatterns(EnumSet, boolean,
+     * String...)
+     */
+    default Set<String> addFilterMapping(String filterName, String... urlPatterns) {
+        return addFilterMapping(filterName, true, urlPatterns);
+    }
+
+    /**
+     * Add a mapping for the given filter.
+     *
+     * @param filterName the filter name.
+     * @param isMatchAfter true to call the filter this mapping applies to after declared ones, false to call it before declared ones.
+     * @param urlPatterns the URL patterns.
+     * @return the possible empty set of already mapped URL patterns.
+     * @see FilterRegistration#addMappingForUrlPatterns(EnumSet, boolean,
+     * String...)
+     */
+    default Set<String> addFilterMapping(String filterName, boolean isMatchAfter, String... urlPatterns) {
+        return addFilterMapping(null, filterName, isMatchAfter, urlPatterns);
+    }
+
+    /**
+     * Add a mapping for the given filter.
+     *
+     * @param dispatcherTypes the dispatcher types. Can be null to use default DispatcherType.REQUEST.
+     * @param filterName the filter name.
+     * @param isMatchAfter true to call the filter this mapping applies to after declared ones, false to call it before declared ones.
+     * @param urlPatterns the URL patterns.
+     * @return the possible empty set of already mapped URL patterns.
+     * @see FilterRegistration#addMappingForUrlPatterns(EnumSet, boolean,
+     * String...)
+     */
+    Set<String> addFilterMapping(Set<DispatcherType> dispatcherTypes, String filterName, boolean isMatchAfter, String... urlPatterns);
+
+    /**
+     * Add a servlet container initializer.
+     *
+     * @param className the class name.
+     */
+    void addInitializer(String className);
+
+    /**
+     * Add a servlet container initializer.
+     *
+     * @param servletContainerInitializer the servletContainerInitializer
+     * instance
+     */
+    void addInitializer(ServletContainerInitializer servletContainerInitializer);
+
+    /**
+     * Add the resource.
+     *
+     * @param resource the resouce.
+     */
+    void addResource(Resource resource);
+
+    /**
+     * Add a mapping for the given servlet.
+     *
+     * @param servletName the servlet name.
+     * @param urlPatterns the URL patterns.
+     * @return the possible empty set of already mapped URL patterns.
+     * @see ServletRegistration#addMapping(String...)
+     */
+    Set<String> addServletMapping(String servletName, String... urlPatterns);
+
+    /**
+     * Destroy the web application.
+     */
+    void destroy();
+
+    /**
+     * Gets the annotation manager.
+     *
+     * @return the annotation manager.
+     */
+    AnnotationManager getAnnotationManager();
+
+    /**
+     * Get the async manager.
+     *
+     * @return the async manager.
+     */
+    AsyncManager getAsyncManager();
+
+    /**
+     * Get the default Servlet.
+     *
+     * @return the default Servlet.
+     */
+    Servlet getDefaultServlet();
+
+    /**
+     * Are we denying uncovered HTTP methods.
+     *
+     * @return true if we are, false otherwise.
+     */
+    boolean getDenyUncoveredHttpMethods();
+
+    /**
+     * Get the mime type manager.
+     *
+     * @return the mime type manager.
+     */
+    MimeTypeManager getMimeTypeManager();
+
+    /**
+     * Get the multi part manager.
+     *
+     * @return the multi part manager.
+     */
+    MultiPartManager getMultiPartManager();
+    
+    /**
+     * Get the naming manager.
+     * 
+     * @return the naming manager.
+     */
+    NamingManager getNamingManager();
+    
+    /**
+     * Get the policy manager.
+     * 
+     * @return the policy manager.
+     */
+    PolicyManager getPolicyManager();
+
+    /**
+     * Returns the unique Id of this web application corresponding to this
+     * ServletContext.
+     *
+     * @return the servlet context id.
+     */
+    default String getServletContextId() {
+        return getVirtualServerName() + " " + getContextPath();
+    }
+
+    /**
+     * Get the HttpSessionManager.
+     *
+     * @return the HttpSessionManager.
+     */
+    HttpSessionManager getHttpSessionManager();
+
+    /**
+     * Get the HttpRequestManager.
+     *
+     * @return the HttpRequestManager.
+     */
+    HttpRequestManager getHttpRequestManager();
+
+    /**
+     * Gets the ServletContainerInitializers
+     *
+     * @return list of ServletContainerInitializers
+     */
+    List<ServletContainerInitializer> getInitializers();
+
+
+    /**
+     * Get the mappings for a particular servlet.
+     *
+     * @param servletName the servlet name.
+     * @return the possible empty set of mapped URL patterns.
+     * @see ServletRegistration#getMappings()
+     */
+    Collection<String> getMappings(String servletName);
+
+    /**
+     * Get the object instance manager.
+     *
+     * @return the DependencyInjectionManager.
+     */
+    ObjectInstanceManager getObjectInstanceManager();
+
+    /**
+     * Get the associated request.
+     *
+     * @param response the response.
+     * @return the associated request.
+     */
+    ServletRequest getRequest(ServletResponse response);
+
+    /**
+     * Get the associated response.
+     *
+     * @param request the request.
+     * @return the associated response.
+     */
+    ServletResponse getResponse(ServletRequest request);
+
+    /**
+     * Get the security manager.
+     *
+     * @return the security manager.
+     */
+    SecurityManager getSecurityManager();
+
+    /**
+     * Get the welcome file manager.
+     *
+     * @return the welcome file manager.
+     */
+    WelcomeFileManager getWelcomeFileManager();
+
+    /**
+     * Get the locale encoding manager
+     * @return the locale encoding manager
+     */
+    LocaleEncodingManager getLocaleEncodingManager();
+
+    /**
+     * Initialize the web application.
+     */
+    void initialize();
+
+    /**
+     * Marks the end of initializing declared (web.xml, annotations) artifacts
+     */
+    void initializeDeclaredFinish();
+
+    /**
+     * Finish the initialization.
+     */
+    void initializeFinish();
+
+    /**
+     * Initialize the filters.
+     */
+    void initializeFilters();
+
+    /**
+     * Initialize the servlet container initializers.
+     */
+    void initializeInitializers();
+
+    /**
+     * Initialize the servlets.
+     */
+    void initializeServlets();
+
+    /**
+     * Is the application distributable.
+     *
+     * @return true if it is, false otherwise.
+     */
+    boolean isDistributable();
+    
+    /**
+     * Is the web application initialized.
+     * 
+     * @return true if it is, false otherwise.
+     */
+    boolean isInitialized();
+
+    /**
+     * Link the request and response.
+     *
+     * @param request the request.
+     * @param response the response.
+     */
+    void linkRequestAndResponse(ServletRequest request, ServletResponse response);
+
+    /**
+     * Service the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws ServletException when a servlet error occurs.
+     * @throws IOException when an I/O error occurs.
+     */
+    void service(ServletRequest request, ServletResponse response)
+            throws ServletException, IOException;
+
+    /**
+     * Set the class loader.
+     *
+     * @param classLoader the class loader.
+     */
+    void setClassLoader(ClassLoader classLoader);
+
+    /**
+     * Set the context path.
+     *
+     * @param contextPath the context path.
+     */
+    void setContextPath(String contextPath);
+
+    /**
+     * Set the default servlet.
+     *
+     * @param defaultServlet the default servlet.
+     */
+    void setDefaultServlet(Servlet defaultServlet);
+
+    /**
+     * Set if we are denying uncovered HTTP methods.
+     *
+     * @param denyUncoveredHttpMethods the boolean value.
+     */
+    void setDenyUncoveredHttpMethods(boolean denyUncoveredHttpMethods);
+
+    /**
+     * Set if the web application is distributable.
+     *
+     * @param distributable the distributable flag.
+     */
+    void setDistributable(boolean distributable);
+
+    /**
+     * Set the effective major version.
+     *
+     * @param version the effective major version.
+     */
+    void setEffectiveMajorVersion(int version);
+
+    /**
+     * Set the effective minor version.
+     *
+     * @param version the effective minor version.
+     */
+    void setEffectiveMinorVersion(int version);
+
+    /**
+     * Set the HTTP session manager.
+     *
+     * @param httpSessionManager the HTTP session manager.
+     */
+    void setHttpSessionManager(HttpSessionManager httpSessionManager);
+
+    /**
+     * Set the HTTP request manager.
+     *
+     * @param httpRequestManager the HTTP request manager.
+     */
+    void setHttpRequestManager(HttpRequestManager httpRequestManager);
+
+    /**
+     * Set the JSP manager.
+     *
+     * @param jspManager the JSP manager.
+     */
+    void setJspManager(JspManager jspManager);
+
+    /**
+     * Set the logging manager.
+     *
+     * @param loggingManager the logging manager.
+     */
+    void setLoggingManager(LoggingManager loggingManager);
+
+    /**
+     * Set the mimeType manager.
+     *
+     * @param mimeTypeManager the mimeType manager.
+     */
+    void setMimeTypeManager(MimeTypeManager mimeTypeManager);
+
+    /**
+     * Set the multi part manager.
+     *
+     * @param multiPartManager the multi part manager.
+     */
+    void setMultiPartManager(MultiPartManager multiPartManager);
+    
+    /**
+     * Set the naming manager.
+     * 
+     * @param namingManager the naming manager.
+     */
+    void setNamingManager(NamingManager namingManager);
+
+    /**
+     * Set the object instance manager.
+     *
+     * @param objectInstanceManager the object instance manager.
+     */
+    void setObjectInstanceManager(ObjectInstanceManager objectInstanceManager);
+
+    /**
+     * Set the resource manager.
+     *
+     * @param resourceManager the resource manager.
+     */
+    void setResourceManager(ResourceManager resourceManager);
+
+    /**
+     * Set the security manager.
+     *
+     * @param securityManager the security manager.
+     */
+    void setSecurityManager(SecurityManager securityManager);
+
+    /**
+     * Sets the annotation manager.
+     *
+     * @param annotationManager the annotation manager
+     */
+    void setAnnotationManager(AnnotationManager annotationManager);
+
+    /**
+     * Set the servlet context name.
+     *
+     * @param servletContextName the servlet context name.
+     */
+    void setServletContextName(String servletContextName);
+
+    /**
+     * Set the web application request mapper.
+     *
+     * @param webApplicationRequestMapper the web application request mapper.
+     */
+    void setWebApplicationRequestMapper(WebApplicationRequestMapper webApplicationRequestMapper);
+
+    /**
+     * Set the welcome file manager.
+     *
+     * @param welcomeFileManager the welcome file manager.
+     */
+    void setWelcomeFileManager(WelcomeFileManager welcomeFileManager);
+
+    /**
+     * Set the locale encoding manager
+     * @param localeEncodingManager the locale encoding manager
+     */
+    void setLocaleEncodingManager(LocaleEncodingManager localeEncodingManager);
+
+    /**
+     * Start servicing.
+     */
+    void start();
+
+    /**
+     * Stop servicing.
+     */
+    void stop();
+
+    /**
+     * Unlink the request and response.
+     *
+     * @param request the request.
+     * @param response the response.
+     */
+    void unlinkRequestAndResponse(ServletRequest request, ServletResponse response);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationClassLoader.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationClassLoader.java
new file mode 100644
index 00000000..b8961920
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationClassLoader.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import cloud.piranha.resource.api.ResourceManagerClassLoader;
+
+/**
+ * The WebApplicationClassLoader API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationClassLoader extends ResourceManagerClassLoader {
+
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationExtension.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationExtension.java
new file mode 100644
index 00000000..f13fe675
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationExtension.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+/**
+ * The web application extension API.
+ *
+ * <p>
+ * A web application extension can be used to automatically configure the web
+ * application according to what the extension delivers, or you can use it as a
+ * way to compose extensions together in one extension.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationExtension {
+
+    /**
+     * Configure the web application.
+     *
+     * @param webApplication the web application to configure.
+     */
+    default void configure(WebApplication webApplication) {
+    }
+
+    /**
+     * Extend the web application.
+     *
+     * @param context the context.
+     */
+    default void extend(WebApplicationExtensionContext context) {
+    }
+
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationExtensionContext.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationExtensionContext.java
new file mode 100644
index 00000000..d768d61e
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationExtensionContext.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+/**
+ * The web application extension context API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationExtensionContext {
+
+    /**
+     * Add the extension to the web application.
+     *
+     * <p>
+     * This will add this extension to the list of extensions that will be used
+     * when configuring the web application.
+     * </p>
+     *
+     * @param extension the extension.
+     */
+    void add(Class<? extends WebApplicationExtension> extension);
+
+    /**
+     * Add the extension to the web application.
+     *
+     * <p>
+     * This will add this extension to the list of extensions that will be used
+     * when configuring the web application.
+     * </p>
+     *
+     * @param extension the extension.
+     */
+    void add(WebApplicationExtension extension);
+
+    /**
+     * Remove the extension from the web application.
+     *
+     * <p>
+     * This will remove the extension from the list of extensions that will be
+     * used when configuring the web application.
+     * </p>
+     * <p>
+     * NOTE this will ONLY remove this extension. Any extensions that were added
+     * to the list by this extension BEFORE it was removed will NOT be removed
+     * from the list of extensions. This is by design.
+     * </p>
+     *
+     * @param extension the extension.
+     */
+    void remove(Class<? extends WebApplicationExtension> extension);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequest.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequest.java
new file mode 100644
index 00000000..6122c28c
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.http.HttpServletRequest;
+
+/**
+ * The WebApplicationRequest API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationRequest extends HttpServletRequest {
+
+    /**
+     * Set the context path.
+     *
+     * @param contextPath the context path.
+     */
+    void setContextPath(String contextPath);
+
+    /**
+     * Set the dispatcher type.
+     *
+     * @param dispatcherType the dispatcher type.
+     */
+    void setDispatcherType(DispatcherType dispatcherType);
+
+    /**
+     * Set the servlet path.
+     *
+     * @param servletPath the servlet path.
+     */
+    void setServletPath(String servletPath);
+
+    /**
+     * Set the web application.
+     *
+     * @param webApplication the web application.
+     */
+    void setWebApplication(WebApplication webApplication);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequestMapper.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequestMapper.java
new file mode 100644
index 00000000..9c9f6c6d
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequestMapper.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import static javax.servlet.DispatcherType.REQUEST;
+
+import java.util.Collection;
+import java.util.Set;
+
+import javax.servlet.DispatcherType;
+
+/**
+ * The WebApplicationRequestMapper API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationRequestMapper {
+
+    /**
+     * Add a servlet mapping.
+     *
+     * @param servletName the servlet name.
+     * @param urlPatterns the URL patterns to map (aka mappings).
+     * @return the URL patterns that were added.
+     */
+    Set<String> addServletMapping(String servletName, String... urlPatterns);
+
+    /**
+     * Add a filter mapping.
+     *
+     * <p>
+     * This adds the filter mappings at the end of list of existing mappings (if any).
+     *
+     * @param filterName the filter name.
+     * @param urlPatterns the URL patterns to map (aka mappings).
+     * @return the URL patterns that were added.
+     */
+    default Set<String> addFilterMapping(String filterName, String... urlPatterns) {
+        return addFilterMapping(null, filterName, urlPatterns);
+    }
+
+    /**
+     * Add a filter mapping.
+     *
+     * <p>
+     * This adds the filter mappings at the end of list of existing mappings (if any).
+     *
+     * @param dispatcherTypes the dispatcher types.
+     * @param filterName the filter name.
+     * @param urlPatterns the URL patterns to map (aka mappings).
+     * @return the URL patterns that were added.
+     */
+    Set<String> addFilterMapping(Set<DispatcherType> dispatcherTypes, String filterName, String... urlPatterns);
+
+    /**
+     * Add a filter mapping.
+     *
+     * <p>
+     * This adds the filter mappings at the start of list of existing mappings (if any).
+     * If there are existing mappings these are shifted to the right.
+     *
+     * @param filterName the filter name.
+     * @param urlPatterns the URL patterns to map (aka mappings).
+     * @return the URL patterns that were added.
+     */
+    default Set<String> addFilterMappingBeforeExisting(String filterName, String... urlPatterns) {
+        return addFilterMappingBeforeExisting(null, filterName, urlPatterns);
+    }
+
+    /**
+     * Add a filter mapping.
+     *
+     * <p>
+     * This adds the filter mappings at the start of list of existing mappings (if any).
+     * If there are existing mappings these are shifted to the right.
+     *
+     * @param dispatcherTypes the dispatcher types.
+     * @param filterName the filter name.
+     * @param urlPatterns the URL patterns to map (aka mappings).
+     * @return the URL patterns that were added.
+     */
+    Set<String> addFilterMappingBeforeExisting(Set<DispatcherType> dispatcherTypes, String filterName, String... urlPatterns);
+
+
+    /**
+     * Find the filter mappings for the given path.
+     *
+     * @param path the path.
+     * @return the mappings.
+     */
+    default Collection<String> findFilterMappings(String path) {
+        return findFilterMappings(REQUEST, path);
+    }
+
+    /**
+     * Find the filter mappings for the given path.
+     *
+     * @param dispatcherType the dispatcher type.
+     * @param path the path.
+     * @return the mappings.
+     */
+    Collection<String> findFilterMappings(DispatcherType dispatcherType, String path);
+
+    /**
+     * Find the servlet mapping for the given path.
+     *
+     * @param path the path.
+     * @return the mapping, or null if not found.
+     */
+    WebApplicationRequestMapping findServletMapping(String path);
+
+    /**
+     * Get the mappings for the specified servlet.
+     *
+     * @param servletName the servlet name.
+     * @return the servlet mappings, or an empty collection if none.
+     */
+    Collection<String> getServletMappings(String servletName);
+
+    /**
+     * Get the servlet name for the specified mapping.
+     *
+     * @param mapping the mapping.
+     * @return the servlet name, or null if not found.
+     */
+    String getServletName(String mapping);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequestMapping.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequestMapping.java
new file mode 100644
index 00000000..83f97221
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationRequestMapping.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+/**
+ * The WebApplicationRequestMapping API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationRequestMapping {
+
+    /**
+     * Get the path.
+     *
+     * @return the path.
+     */
+    String getPath();
+
+    /**
+     * Is this an exact match.
+     *
+     * @return true it it is, false otherwise.
+     */
+    boolean isExact();
+
+    /**
+     * Is this an extension match.
+     *
+     * @return true if it is, false otherwise.
+     */
+    boolean isExtension();
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationResponse.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationResponse.java
new file mode 100644
index 00000000..4b741e39
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationResponse.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Collection;
+
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * The WebApplicationResponse API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationResponse extends HttpServletResponse {
+
+    /**
+     * Close the async response.
+     */
+    void closeAsyncResponse();
+
+    /**
+     * Get the cookies.
+     *
+     * @return the cookies.
+     */
+    Collection<Cookie> getCookies();
+    
+    /**
+     * Get the response closer.
+     * 
+     * @return the response closer.
+     */
+    Runnable getResponseCloser();
+
+    /**
+     * Get the underlying output stream.
+     *
+     * @return the underlying output stream.
+     */
+    OutputStream getUnderlyingOutputStream();
+
+    /**
+     * Set the underlying output stream.
+     *
+     * @param outputStream the underlying output stream.
+     */
+    void setUnderlyingOutputStream(OutputStream outputStream);
+        
+    /**
+     * Write the headers.
+     * 
+     * @throws IOException when an I/O error occurs.
+     */
+    void writeHeaders() throws IOException;
+    
+    /**
+     * Write the status line.
+     * 
+     * @throws IOException when an I/O error occurs.
+     */
+    void writeStatusLine() throws IOException;
+
+    /**
+     * Set the web application.
+     *
+     * @param webApplication the web application.
+     */
+    void setWebApplication(WebApplication webApplication);
+
+    /**
+     * Set the response closer.
+     *
+     * @param responseCloser the response closer.
+     */
+    void setResponseCloser(Runnable responseCloser);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationServer.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationServer.java
new file mode 100644
index 00000000..8a072ad2
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationServer.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.io.IOException;
+import javax.servlet.ServletException;
+
+/**
+ * The WebApplicationServer API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationServer {
+
+    /**
+     * Add a web application.
+     *
+     * @param webApplication the web application to add.
+     */
+    void addWebApplication(WebApplication webApplication);
+
+    /**
+     * Get the request mapper.
+     *
+     * @return the request mapper.
+     */
+    WebApplicationServerRequestMapper getRequestMapper();
+
+    /**
+     * Service the request and response.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    void service(WebApplicationRequest request, WebApplicationResponse response)
+            throws IOException, ServletException;
+
+    /**
+     * Initialize the server.
+     */
+    void initialize();
+
+    /**
+     * Set the request mapper.
+     *
+     * @param requestMapper the request mapper.
+     */
+    void setRequestMapper(WebApplicationServerRequestMapper requestMapper);
+
+    /**
+     * Start the server.
+     */
+    void start();
+
+    /**
+     * Stop the server.
+     */
+    void stop();
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationServerRequestMapper.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationServerRequestMapper.java
new file mode 100644
index 00000000..47674bcc
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WebApplicationServerRequestMapper.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.util.Set;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The WebApplicationServerRequestMapper API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WebApplicationServerRequestMapper {
+
+    /**
+     * Add a mapping.
+     *
+     * @param webApplication the web application.
+     * @param urlPatterns the url patterns to map (aka mappings).
+     * @return the url patterns added.
+     */
+    Set<String> addMapping(WebApplication webApplication, String... urlPatterns);
+
+    /**
+     * Find a mapping for the given path.
+     *
+     * @param path the path.
+     * @return the mapping, or null if not found.
+     */
+    WebApplication findMapping(String path);
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WelcomeFileManager.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WelcomeFileManager.java
new file mode 100644
index 00000000..4f46d83a
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/WelcomeFileManager.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webapp;
+
+import java.io.IOException;
+import java.util.List;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * The WelcomeFileManager API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public interface WelcomeFileManager {
+
+    /**
+     * Add a welcome file.
+     *
+     * @param welcomeFile the welcome file.
+     */
+    void addWelcomeFile(String welcomeFile);
+
+    /**
+     * Process the request.
+     * 
+     * @param request the request.
+     * @param response the response.
+     * @param chain the filter chain.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a filter or servlet error occurs.
+     */
+    void doFilter(ServletRequest request, ServletResponse response,
+            FilterChain chain) throws IOException, ServletException;
+    
+    /**
+     * Get the welcome file list.
+     *
+     * @return the welcome file list.
+     */
+    List<String> getWelcomeFileList();
+}
diff --git a/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/package-info.java b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/package-info.java
new file mode 100644
index 00000000..559ace3f
--- /dev/null
+++ b/servlet4/webapp/src/main/java/cloud/piranha/servlet4/webapp/package-info.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/**
+ * <p>
+ * The Piranha Web Application API package contains the core set of APIs of
+ * Piranha that deliver web application support.
+ * </p>
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+package cloud.piranha.servlet4.webapp;
diff --git a/servlet4/webapp/src/main/java/module-info.java b/servlet4/webapp/src/main/java/module-info.java
new file mode 100644
index 00000000..efc1c528
--- /dev/null
+++ b/servlet4/webapp/src/main/java/module-info.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+module cloud.piranha.servlet4.webapp {
+    
+    exports cloud.piranha.servlet4.webapp;
+    requires static cloud.piranha.resource.api;
+    requires static cloud.piranha.servlet4.api;
+    requires cloud.piranha.naming.api;
+    requires cloud.piranha.policy.api;
+}
diff --git a/servlet4/webxml/pom.xml b/servlet4/webxml/pom.xml
new file mode 100644
index 00000000..d3c8f07c
--- /dev/null
+++ b/servlet4/webxml/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>cloud.piranha.servlet4</groupId>
+        <artifactId>project</artifactId>
+        <version>21.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>piranha-servlet4-webxml</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Piranha Servlet 4 - web.xml Integration</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>cloud.piranha.resource</groupId>
+            <artifactId>piranha-resource</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-impl</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-webapp</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlExtension.java b/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlExtension.java
new file mode 100644
index 00000000..94b15461
--- /dev/null
+++ b/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlExtension.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webxml;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.servlet.ServletContainerInitializer;
+
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WebApplicationExtension;
+
+/**
+ * The extension for web.xml processing.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlExtension implements WebApplicationExtension {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(WebXmlExtension.class.getName());
+
+    /**
+     * Configure the web application.
+     *
+     * @param webApplication the web application.
+     */
+    @Override
+    public void configure(WebApplication webApplication) {
+        try {
+            ClassLoader classLoader = webApplication.getClassLoader();
+            Class<? extends ServletContainerInitializer> clazz
+                    = classLoader.
+                            loadClass(WebXmlInitializer.class.getName())
+                            .asSubclass(ServletContainerInitializer.class);
+            ServletContainerInitializer initializer = clazz.getDeclaredConstructor().newInstance();
+            webApplication.addInitializer(initializer);
+        } catch (ClassNotFoundException | NoSuchMethodException | SecurityException
+                | InstantiationException | IllegalAccessException
+                | IllegalArgumentException | InvocationTargetException ex) {
+            LOGGER.log(Level.WARNING, "Unable to enable the WebXmlExtension", ex);
+        }
+    }
+}
diff --git a/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlInitializer.java b/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlInitializer.java
new file mode 100644
index 00000000..c5130ab3
--- /dev/null
+++ b/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlInitializer.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webxml;
+
+import static java.util.logging.Level.FINE;
+import static java.util.logging.Level.WARNING;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.logging.Logger;
+
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+
+import cloud.piranha.servlet4.impl.WebXml;
+import cloud.piranha.servlet4.impl.WebXmlManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+
+/**
+ * The web.xml initializer.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlInitializer implements ServletContainerInitializer {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(WebXmlInitializer.class.getName());
+
+    /**
+     * On startup.
+     *
+     * @param classes the classes.
+     * @param servletContext the servlet context.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
+        LOGGER.log(FINE, () -> "Entering WebXmlInitializer.onStartup");
+
+        try {
+            WebXmlParser parser = new WebXmlParser();
+            WebXmlManager manager = new WebXmlManager();
+            servletContext.setAttribute(WebXmlManager.KEY, manager);
+
+            WebApplication webApp = (WebApplication) servletContext;
+            InputStream inputStream = servletContext.getResourceAsStream("WEB-INF/web.xml");
+            if (inputStream != null) {
+                WebXml webXml = parser.parse(servletContext.getResourceAsStream("WEB-INF/web.xml"));
+                manager.setWebXml(webXml);
+                manager.setInitialWebXml(webXml);
+            }
+
+            ArrayList<WebXml> webFragments = new ArrayList<>();
+            List<URL> webFragmentUrls = Collections.list(servletContext.getClassLoader().getResources("META-INF/web-fragment.xml"));
+            for (URL url : webFragmentUrls) {
+                try (InputStream stream = url.openStream()) {
+                    WebXml webFragment = parser.parse(stream);
+                    webFragment.setFragment(true);
+                    webFragments.add(webFragment);
+                }
+            }
+            if (!webFragments.isEmpty()) {
+                manager.setWebFragments(webFragments);
+            }
+
+            if (manager.getWebXml() == null) {
+                manager.setWebXml(new WebXml());
+            }
+
+            if (manager.getWebXml() != null) {
+                WebXml webXml = manager.getWebXml();
+                WebXmlProcessor processor = new WebXmlProcessor();
+
+                processor.process(webXml, webApp);
+
+                if (webXml.getMetadataComplete()) {
+                    return;
+                }
+
+                manager.getOrderedFragments().forEach(fragment -> processor.process(fragment, webApp));
+            } else {
+                LOGGER.fine("No web.xml found!");
+            }
+        } catch (IOException e) {
+            LOGGER.log(WARNING, "Unable to parse web.xml", e);
+        }
+
+        LOGGER.log(FINE, () -> "Exiting WebXmlInitializer.onStartup");
+    }
+
+}
diff --git a/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlParser.java b/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlParser.java
new file mode 100644
index 00000000..87363623
--- /dev/null
+++ b/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlParser.java
@@ -0,0 +1,846 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webxml;
+
+import static cloud.piranha.servlet4.impl.WebXml.OTHERS_TAG;
+import static java.util.logging.Level.FINE;
+import static java.util.logging.Level.WARNING;
+import static java.util.regex.Pattern.quote;
+import static javax.xml.xpath.XPathConstants.NODE;
+import static javax.xml.xpath.XPathConstants.NODESET;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.logging.Logger;
+import java.util.stream.StreamSupport;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathConstants;
+import javax.xml.xpath.XPathException;
+import javax.xml.xpath.XPathExpressionException;
+import javax.xml.xpath.XPathFactory;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import cloud.piranha.servlet4.impl.WebXml;
+import cloud.piranha.servlet4.impl.WebXmlContextParam;
+import cloud.piranha.servlet4.impl.WebXmlCookieConfig;
+import cloud.piranha.servlet4.impl.WebXmlErrorPage;
+import cloud.piranha.servlet4.impl.WebXmlFilter;
+import cloud.piranha.servlet4.impl.WebXmlFilterInitParam;
+import cloud.piranha.servlet4.impl.WebXmlFilterMapping;
+import cloud.piranha.servlet4.impl.WebXmlListener;
+import cloud.piranha.servlet4.impl.WebXmlLoginConfig;
+import cloud.piranha.servlet4.impl.WebXmlMimeMapping;
+import cloud.piranha.servlet4.impl.WebXmlServlet;
+import cloud.piranha.servlet4.impl.WebXmlServletInitParam;
+import cloud.piranha.servlet4.impl.WebXmlServletMapping;
+import cloud.piranha.servlet4.impl.WebXmlServletSecurityRoleRef;
+import cloud.piranha.servlet4.impl.WebXmlSessionConfig;
+
+/**
+ * The web.xml / web-fragment.xml parser.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlParser {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(WebXmlParser.class.getName());
+
+    /**
+     * Parse the input stream.
+     *
+     * @param inputStream the input stream.
+     * @return the WebXml.
+     */
+    public WebXml parse(InputStream inputStream) {
+        WebXml webXml = new WebXml();
+        try {
+            DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+            Document document = documentBuilder.parse(inputStream);
+            XPath xPath = XPathFactory.newInstance().newXPath();
+            parseAbsoluteOrdering(webXml, xPath, document);
+            parseOrdering(webXml, xPath, document);
+            parseContextParameters(webXml, xPath, document);
+            parseDefaultContextPath(webXml, xPath, document);
+            parseDenyUncoveredHttpMethods(webXml, xPath, document);
+            parseDisplayName(webXml, xPath, document);
+            parseFragmentName(webXml, xPath, document);
+            parseDistributable(webXml, xPath, document);
+            parseErrorPages(webXml, xPath, document);
+            parseFilterMappings(webXml, xPath, document);
+            parseFilters(webXml, xPath, document);
+            parseListeners(webXml, xPath, document);
+            parseLoginConfig(webXml, xPath, document);
+            parseMimeMappings(webXml, xPath, document);
+            parseRequestCharacterEncoding(webXml, xPath, document);
+            parseResponseCharacterEncoding(webXml, xPath, document);
+            parseLocaleEncodingMapping(webXml, xPath, document);
+            processSecurityConstraints(webXml, xPath, document);
+            processSecurityRoles(webXml, xPath, document);
+            parseServletMappings(webXml, xPath, document);
+            parseServlets(webXml, xPath, document);
+            parseSessionConfig(webXml, xPath, document);
+            parseWebApp(webXml, xPath, document);
+            parseWelcomeFiles(webXml, xPath, document);
+        } catch (Throwable t) {
+            LOGGER.log(WARNING, "Unable to parse web.xml", t);
+        }
+        return webXml;
+    }
+
+    /**
+     * Parse the name section of a fragment.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseFragmentName(WebXml webXml, XPath xPath, Node node) {
+        try {
+            String fragmentName = parseString(xPath, "//name/text()", node);
+            if (fragmentName != null) {
+                webXml.setFragmentName(fragmentName);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <name> section", xpe);
+        }
+    }
+    private void parseAbsoluteOrdering(WebXml webXml, XPath xPath, Node rootNode) {
+        try {
+            Node absoluteOrderingNode = (Node) xPath.evaluate("//absolute-ordering", rootNode, NODE);
+            if (absoluteOrderingNode == null)
+                return;
+            // It is possible to have only the <absolute-ordering/> to disable fragments
+            List<String> fragmentNames = new ArrayList<>();
+            NodeList childNodes = absoluteOrderingNode.getChildNodes();
+            for (int i = 0; i < childNodes.getLength(); i++) {
+                Node item = childNodes.item(i);
+                if ("others".equalsIgnoreCase(item.getNodeName())) {
+                    fragmentNames.add(OTHERS_TAG);
+                    continue;
+                }
+                String s = parseString(xPath, "text()", item);
+                if (s != null && !s.trim().isEmpty())
+                    fragmentNames.add(s);
+            }
+            webXml.setAbsoluteOrdering(fragmentNames);
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <absolute-ordering> section", xpe);
+        }
+    }
+
+    private void parseOrdering(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList before = (NodeList) xPath.evaluate("//ordering/before", node, NODESET);
+            if (before.getLength() > 1) {
+                throw new IllegalStateException("Cannot have multiple <before> tags in <ordering>");
+            }
+
+            NodeList after = (NodeList) xPath.evaluate("//ordering/after", node, NODESET);
+            if (after.getLength() > 1) {
+                throw new IllegalStateException("Cannot have multiple <after> tags in <ordering>");
+            }
+
+            List<String> beforeValues = parseOrderingChildren(xPath, before);
+
+            List<String> afterValues = parseOrderingChildren(xPath, after);
+
+            if (!beforeValues.isEmpty() || !afterValues.isEmpty())
+                webXml.setRelativeOrdering(new WebXml.RelativeOrder(beforeValues, afterValues));
+        } catch (Exception xpe) {
+            LOGGER.log(WARNING, "Unable to parse <ordering> section", xpe);
+        }
+
+    }
+
+    private List<String> parseOrderingChildren(XPath xPath, NodeList orderingChild) throws XPathExpressionException {
+        List<String> values = new ArrayList<>();
+        if (orderingChild.getLength() == 1) {
+            Node beforeTag = orderingChild.item(0);
+            for (Node orderingNode : parseNodes(xPath, "*", beforeTag)) {
+                String fragmentName = parseString(xPath, "text()", orderingNode);
+                if (fragmentName != null && !fragmentName.trim().isEmpty()) {
+                    values.add(fragmentName);
+                    continue;
+                }
+                if ("others".equalsIgnoreCase(orderingNode.getNodeName())) {
+                    values.add(OTHERS_TAG);
+                }
+            }
+        }
+        return values;
+    }
+
+    /**
+
+    /**
+     * Parse a boolean.
+     *
+     * @param xPath the XPath to use.
+     * @param node the node to use.
+     * @param expression the expression to use.
+     * @return the boolean, or null if an error occurred.
+     */
+    private static Boolean parseBoolean(XPath xPath, String expression, Node node) {
+        Boolean result = null;
+        try {
+            result = Boolean.parseBoolean((String) xPath.evaluate(expression, node, XPathConstants.STRING));
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse boolean", xpe);
+        }
+        return result;
+    }
+
+    /**
+     * Parse the context-param sections.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the node to use.
+     */
+    private void parseContextParameters(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList nodeList = (NodeList) xPath.evaluate("//context-param", node, NODESET);
+            if (nodeList != null) {
+                List<WebXmlContextParam> contextParams = webXml.getContextParams();
+                for (int i = 0; i < nodeList.getLength(); i++) {
+                    String name = parseString(xPath, "//param-name/text()", nodeList.item(i));
+                    String value = parseString(xPath, "//param-value/text()", nodeList.item(i));
+                    contextParams.add(new WebXmlContextParam(name, value));
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <context-param> sections", xpe);
+        }
+    }
+
+    /**
+     * Parse the deny-uncovered-http-methods section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseDenyUncoveredHttpMethods(WebXml webXml, XPath xPath, Node node) {
+        try {
+            Node denyNode = (Node) xPath.evaluate("//deny-uncovered-http-methods", node, NODE);
+            if (denyNode != null) {
+                webXml.setDenyUncoveredHttpMethods(true);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <deny-uncovered-http-methods> section", xpe);
+        }
+    }
+
+    /**
+     * Parse the default-context-path section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseDefaultContextPath(WebXml webXml, XPath xPath, Node node) {
+        try {
+            Node contextPathNode = (Node) xPath.evaluate("//default-context-path", node, NODE);
+            if (contextPathNode != null) {
+                String defaultContextPath = parseString(xPath, "//default-context-path/text()", node);
+                if (defaultContextPath != null) {
+                    webXml.setDefaultContextPath(defaultContextPath);
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <default-context-path> section", xpe);
+        }
+    }
+
+    /**
+     * Parse the display-name section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseDisplayName(WebXml webXml, XPath xPath, Node node) {
+        try {
+            String displayName = parseString(xPath, "//display-name/text()", node);
+            if (displayName != null) {
+                webXml.setDisplayName(displayName);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <display-name> section", xpe);
+        }
+    }
+
+    /**
+     * Parse the distributable section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseDistributable(WebXml webXml, XPath xPath, Node node) {
+        try {
+            Node denyNode = (Node) xPath.evaluate("//distributable", node, NODE);
+            if (denyNode != null) {
+                webXml.setDistributable(true);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <distributable> section", xpe);
+        }
+    }
+
+    /**
+     * Parse the error-page sections.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseErrorPages(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList nodeList = (NodeList) xPath.evaluate("//error-page", node, NODESET);
+            if (nodeList != null) {
+                List<WebXmlErrorPage> errorPages = webXml.getErrorPages();
+                for (int i = 0; i < nodeList.getLength(); i++) {
+                    String errorCode = parseString(xPath, "error-code/text()", nodeList.item(i));
+                    String exceptionType = parseString(xPath, "exception-type/text()", nodeList.item(i));
+                    String location = parseString(xPath, "location/text()", nodeList.item(i));
+                    errorPages.add(new WebXmlErrorPage(errorCode, exceptionType, location));
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <error-page> sections", xpe);
+        }
+    }
+
+    /**
+     * Parse the filter-mapping sections.
+     *
+     * @param webXml the web.xml to use.
+     * @param xPath the XPath to use.
+     * @param rootNode the node to use.
+     */
+    private void parseFilterMappings(WebXml webXml, XPath xPath, Node rootNode) {
+        try {
+            for (Node node : parseNodes(xPath, "//filter-mapping", rootNode)) {
+                String filterName = parseString(xPath, "filter-name/text()", node);
+                WebXmlFilterMapping webXmlFilterMapping = new WebXmlFilterMapping(filterName);
+
+                for (String urlPattern : parseStrings(xPath, "url-pattern/text()", node)) {
+                    webXmlFilterMapping.getUrlPatterns().add(urlPattern);
+                }
+
+                for (String servletName : parseStrings(xPath, "servlet-name/text()", node)) {
+                    webXmlFilterMapping.getServletNames().add(servletName);
+                }
+
+                for (String dispatcher : parseStrings(xPath, "dispatcher/text()", node)) {
+                    webXmlFilterMapping.getDispatchers().add(dispatcher);
+                }
+
+                webXml.getFilterMappings().add(webXmlFilterMapping);
+            }
+        } catch (XPathExpressionException xee) {
+            LOGGER.log(WARNING, "Unable to parse <filter-mapping> sections", xee);
+        }
+    }
+
+    /**
+     * Parse the filter sections.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseFilters(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList nodeList = (NodeList) xPath.evaluate("//filter", node, NODESET);
+            if (nodeList != null) {
+                List<WebXmlFilter> filters = webXml.getFilters();
+                for (int i = 0; i < nodeList.getLength(); i++) {
+                    WebXmlFilter filter = new WebXmlFilter();
+                    String filterName = parseString(xPath, "filter-name/text()", nodeList.item(i));
+                    filter.setFilterName(filterName);
+                    String className = parseString(xPath, "filter-class/text()", nodeList.item(i));
+                    filter.setClassName(className);
+                    String servletName = parseString(xPath, "servlet-name/text()", nodeList.item(i));
+                    filter.setServletName(servletName);
+
+                    Boolean asyncSupported = parseBoolean(xPath, "async-supported/text()", nodeList.item(i));
+                    if (asyncSupported != null) {
+                        filter.setAsyncSupported(asyncSupported);
+                    }
+
+                    filters.add(filter);
+
+                    NodeList paramNodeList = (NodeList) xPath.evaluate("init-param", nodeList.item(i), NODESET);
+                    for (int j = 0; j < paramNodeList.getLength(); j++) {
+                        WebXmlFilterInitParam initParam = new WebXmlFilterInitParam();
+                        String name = parseString(xPath, "param-name/text()", paramNodeList.item(j));
+                        initParam.setName(name);
+                        String value = parseString(xPath, "param-value/text()", paramNodeList.item(j));
+                        initParam.setValue(value);
+                        filter.addInitParam(initParam);
+                    }
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <filter> sections", xpe);
+        }
+    }
+
+    /**
+     * Parse an integer.
+     *
+     * @param xPath the XPath to use.
+     * @param expression the expression.
+     * @param node the node.
+     * @return the string.
+     * @throws XPathExpressionException when the expression was invalid.
+     */
+    private int parseInteger(XPath xPath, String expression, Node node) throws XPathExpressionException {
+        Double doubleValue = (Double) xPath.evaluate(expression, node, XPathConstants.NUMBER);
+        return doubleValue.intValue();
+    }
+
+    /**
+     * Parse the listener sections.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseListeners(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList nodeList = (NodeList) xPath.evaluate("//listener", node, NODESET);
+            if (nodeList != null) {
+                List<WebXmlListener> listeners = webXml.getListeners();
+                for (int i = 0; i < nodeList.getLength(); i++) {
+                    String className = parseString(xPath, "listener-class/text()", nodeList.item(i));
+                    listeners.add(new WebXmlListener(className));
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <listener> sections", xpe);
+        }
+    }
+
+    /**
+     * Parse the login-config section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseLoginConfig(WebXml webXml, XPath xPath, Node node) {
+        try {
+            Node configNode = (Node) xPath.evaluate("//login-config", node, NODE);
+            if (configNode != null) {
+                String authMethod = parseString(xPath,
+                        "//auth-method/text()", configNode);
+                String realmName = parseString(xPath,
+                        "//realm-name/text()", configNode);
+                String formLoginPage = parseString(xPath,
+                        "//form-login-config/form-login-page/text()", configNode);
+                String formErrorPage = parseString(xPath,
+                        "//form-login-config/form-error-page/text()", configNode);
+                WebXmlLoginConfig config = new WebXmlLoginConfig(
+                        authMethod, realmName, formLoginPage, formErrorPage);
+                webXml.setLoginConfig(config);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <login-config> section", xpe);
+        }
+    }
+
+    /**
+     * Parse the mime-mapping sections.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the node to use.
+     */
+    private void parseMimeMappings(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList nodeList = (NodeList) xPath.evaluate("//mime-mapping", node, NODESET);
+            if (nodeList != null) {
+                List<WebXmlMimeMapping> mimeMappings = webXml.getMimeMappings();
+                for (int i = 0; i < nodeList.getLength(); i++) {
+                    String extension = parseString(xPath, "//extension/text()", nodeList.item(i));
+                    String mimeType = parseString(xPath, "//mime-type/text()", nodeList.item(i));
+                    mimeMappings.add(new WebXmlMimeMapping(extension, mimeType));
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <mime-mapping> sections", xpe);
+        }
+    }
+
+    /**
+     * Parse the request-character-encoding section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseRequestCharacterEncoding(WebXml webXml, XPath xPath, Node node) {
+        try {
+            Node rceNode = (Node) xPath.evaluate("//request-character-encoding", node, NODE);
+            if (rceNode != null) {
+                String requestCharacterEncoding = parseString(
+                        xPath, "//request-character-encoding/text()", node);
+                webXml.setRequestCharacterEncoding(requestCharacterEncoding);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <request-character-encoding> section", xpe);
+        }
+    }
+
+    /**
+     * Parse the response-character-encoding section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseResponseCharacterEncoding(WebXml webXml, XPath xPath, Node node) {
+        try {
+            Node rceNode = (Node) xPath.evaluate("//response-character-encoding", node, NODE);
+            if (rceNode != null) {
+                String responseCharacterEncoding = parseString(
+                        xPath, "//response-character-encoding/text()", node);
+                webXml.setResponseCharacterEncoding(responseCharacterEncoding);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <response-character-encoding> section", xpe);
+        }
+    }
+
+    private void processSecurityConstraints(WebXml webXml, XPath xPath, Node rootNode) {
+        try {
+            for (Node node : parseNodes(xPath, "//security-constraint", rootNode)) {
+                processSecurityConstraint(webXml, xPath, node);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <security-constraint> sections", xpe);
+        }
+    }
+
+    private void processSecurityConstraint(WebXml webXml, XPath xPath, Node rootNode) {
+        try {
+            WebXml.SecurityConstraint securityConstraint = new WebXml.SecurityConstraint();
+
+            for (Node node : parseNodes(xPath, "web-resource-collection", rootNode)) {
+                WebXml.SecurityConstraint.WebResourceCollection webResourceCollection = new WebXml.SecurityConstraint.WebResourceCollection();
+
+                for (String urlPattern : parseStrings(xPath, "url-pattern/text()", node)) {
+                    webResourceCollection.urlPatterns.add(urlPattern);
+                }
+
+                for (String httpMethod : parseStrings(xPath, "http-method/text()", node)) {
+                    webResourceCollection.httpMethods.add(httpMethod);
+                }
+
+                for (String httpMethodOmission : parseStrings(xPath, "http-method-omission/text()", node)) {
+                    webResourceCollection.httpMethodOmissions.add(httpMethodOmission);
+                }
+
+                securityConstraint.webResourceCollections.add(webResourceCollection);
+            }
+
+            for (Node node : parseNodes(xPath, "auth-constraint", rootNode)) {
+                for (String roleName : parseStrings(xPath, "role-name/text()", node)) {
+                    securityConstraint.roleNames.add(roleName);
+                }
+            }
+
+            securityConstraint.transportGuarantee = parseString(xPath, "user-data-constraint/transport-guarantee/text()", rootNode);
+
+            webXml.securityConstraints.add(securityConstraint);
+        } catch (XPathExpressionException xee) {
+            LOGGER.log(WARNING, "Unable to parse <security-constraint> sections", xee);
+        }
+    }
+
+    private void processSecurityRoles(WebXml webXml, XPath xPath, Node rootNode) {
+        try {
+            for (String roleName : parseStrings(xPath, "//security-role/role-name/text()", rootNode)) {
+                webXml.getRoleNames().add(roleName);
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <security-constraint> sections", xpe);
+        }
+    }
+
+    /**
+     * Parse the servlet-mapping sections.
+     *
+     * @param webXml the web.xml to use.
+     * @param xPath the XPath to use.
+     * @param node the node to use.
+     */
+    private void parseServletMappings(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList nodeList = (NodeList) xPath.evaluate("//servlet-mapping", node, NODESET);
+            if (nodeList != null) {
+                List<WebXmlServletMapping> servletMappings = webXml.getServletMappings();
+                for (int i = 0; i < nodeList.getLength(); i++) {
+                    String servletName = parseString(xPath, "servlet-name/text()", nodeList.item(i));
+                    for (String urlPattern : parseStrings(xPath, "url-pattern/text()", nodeList.item(i))) {
+                        servletMappings.add(new WebXmlServletMapping(servletName, urlPattern));
+                    }
+                }
+            }
+        } catch (XPathExpressionException xee) {
+            LOGGER.log(WARNING, "Unable to parse <servlet-mapping> section", xee);
+        }
+    }
+
+    /**
+     * Parse the servlet sections.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param rootNode the DOM node.
+     */
+    private void parseServlets(WebXml webXml, XPath xPath, Node rootNode) {
+        try {
+            List<WebXmlServlet> servlets = webXml.getServlets();
+            for (Node servletNode : parseNodes(xPath, "//servlet", rootNode)) {
+                WebXmlServlet servlet = new WebXmlServlet();
+                servlet.setServletName(parseString(xPath, "servlet-name/text()", servletNode));
+                servlet.setClassName(parseString(xPath, "servlet-class/text()", servletNode));
+                servlet.setJspFile(parseString(xPath, "jsp-file/text()", servletNode));
+
+                Boolean asyncSupported = parseBoolean(xPath, "async-supported/text()", servletNode);
+                if (asyncSupported != null) {
+                    servlet.setAsyncSupported(asyncSupported);
+                }
+
+                for (Node initParamNode : parseNodes(xPath, "init-param", servletNode)) {
+                    WebXmlServletInitParam initParam = new WebXmlServletInitParam();
+                    initParam.setName(parseString(xPath, "param-name/text()", initParamNode));
+                    initParam.setValue(parseString(xPath, "param-value/text()", initParamNode));
+
+                    servlet.getInitParams().add(initParam);
+                }
+
+                for (Node securityRoleRefNode : parseNodes(xPath, "security-role-ref", servletNode)) {
+                    WebXmlServletSecurityRoleRef securityRoleRef = new WebXmlServletSecurityRoleRef();
+                    securityRoleRef.setRoleName(parseString(xPath, "role-name/text()", securityRoleRefNode));
+                    securityRoleRef.setRoleLink(parseString(xPath, "role-link/text()", securityRoleRefNode));
+
+                    servlet.getSecurityRoleRefs().add(securityRoleRef);
+                }
+
+                servlets.add(servlet);
+
+                LOGGER.log(FINE, "Configured servlet: {0}", servlet);
+            }
+
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <filter> sections", xpe);
+        }
+    }
+
+    /**
+     * Parse the session-config section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseSessionConfig(WebXml webXml, XPath xPath, Node node) {
+        try {
+            Node scNode = (Node) xPath.evaluate("//session-config", node, NODE);
+            if (scNode != null) {
+                WebXmlSessionConfig sessionConfig = new WebXmlSessionConfig();
+                int sessionTimeout = parseInteger(xPath, "session-timeout/text()", scNode);
+                sessionConfig.setSessionTimeout(sessionTimeout);
+                webXml.setSessionConfig(sessionConfig);
+                Node cNode = (Node) xPath.evaluate("cookie-config", scNode, NODE);
+                if (cNode != null) {
+                    WebXmlCookieConfig cookieConfig = new WebXmlCookieConfig();
+                    String name = parseString(xPath, "name/text()", cNode);
+                    if (name != null) {
+                        cookieConfig.setName(name);
+                    }
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <session-config> section", xpe);
+        }
+    }
+
+
+    /**
+     * Parse the default-context-path section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseWebApp(WebXml webXml, XPath xPath, Node node) {
+        try {
+            Node webAppNode = (Node) xPath.evaluate("//web-app", node, NODE);
+            if (webAppNode != null) {
+                NamedNodeMap attributes = webAppNode.getAttributes();
+                if (attributes != null) {
+                    Node versionNode = attributes.getNamedItem("version");
+                    if (versionNode != null) {
+                        String version = versionNode.getTextContent();
+                        if (version != null) {
+                            String[] versionComponents = version.split(quote("."));
+                            if (versionComponents.length > 0) {
+                                webXml.setMajorVersion(Integer.valueOf(versionComponents[0]));
+                            }
+                            if (versionComponents.length > 1) {
+                                webXml.setMinorVersion(Integer.valueOf(versionComponents[1]));
+                            }
+                        }
+                    }
+                    Node metadataCompleteNode = attributes.getNamedItem("metadata-complete");
+                    if (metadataCompleteNode != null) {
+                        webXml.setMetadataComplete(Boolean.parseBoolean(metadataCompleteNode.getTextContent()));
+                    }
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <web-app> section", xpe);
+        }
+    }
+
+
+
+    /**
+     * Parse a string.
+     *
+     * @param xPath the XPath to use.
+     * @param expression the expression.
+     * @param node the node.
+     * @return the string.
+     * @throws XPathExpressionException when the expression was invalid.
+     */
+    private String parseString(XPath xPath, String expression, Node node) throws XPathExpressionException {
+        return (String) xPath.evaluate(expression, node, XPathConstants.STRING);
+    }
+
+    private Iterable<Node> parseNodes(XPath xPath, String expression, Node node) throws XPathExpressionException {
+        return StreamSupport
+                .stream(toIterable((NodeList) xPath.evaluate(expression, node, NODESET)).spliterator(), false)
+                ::iterator;
+    }
+
+    private Iterable<String> parseStrings(XPath xPath, String expression, Node node) throws XPathExpressionException {
+        return StreamSupport
+                .stream(toIterable((NodeList) xPath.evaluate(expression, node, NODESET)).spliterator(), false)
+                .map(Node::getNodeValue)
+                ::iterator;
+    }
+
+    /**
+     * Convert nodes list to iterable nodes.
+     * 
+     * @param nodeList the node list.
+     * @return the iterable nodes.
+     */
+    public static Iterable<Node> toIterable(NodeList nodeList) {
+        return () -> new Iterator<Node>() {
+
+            private int position;
+
+            @Override
+            public boolean hasNext() {
+                return position < nodeList.getLength();
+            }
+
+            @Override
+            public Node next() {
+                if (hasNext()) {
+                    return nodeList.item(position++);
+                }
+
+                throw new NoSuchElementException();
+            }
+        };
+    }
+
+    /**
+     * Parse the welcome file section.
+     *
+     * @param webXml the web.xml to add to.
+     * @param xPath the XPath to use.
+     * @param node the DOM node.
+     */
+    private void parseWelcomeFiles(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList nodeList = (NodeList) xPath.evaluate("//welcome-file-list/welcome-file", node, NODESET);
+            if (nodeList != null) {
+                List<String> welcomeFiles = webXml.getWelcomeFiles();
+                for (int i = 0; i < nodeList.getLength(); i++) {
+                    String welcomeFile = parseString(xPath, "text()", nodeList.item(i));
+                    welcomeFiles.add(welcomeFile);
+                    LOGGER.log(FINE, "Parsed welcome-file: {0}", welcomeFile);
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <welcome-file-list> sections", xpe);
+        }
+    }
+
+
+    private void parseLocaleEncodingMapping(WebXml webXml, XPath xPath, Node node) {
+        try {
+            NodeList nodeList = (NodeList) xPath.evaluate("//locale-encoding-mapping-list/locale-encoding-mapping", node, NODESET);
+            if (nodeList != null) {
+                Map<String, String> localeEncodingMapping = webXml.getLocaleEncodingMapping();
+                for (int i = 0; i < nodeList.getLength(); i++) {
+                    String locale = parseString(xPath, ".//locale/text()", nodeList.item(i));
+                    String encoding = parseString(xPath, ".//encoding/text()", nodeList.item(i));
+                    localeEncodingMapping.put(locale, encoding);
+                }
+            }
+        } catch (XPathException xpe) {
+            LOGGER.log(WARNING, "Unable to parse <locale-encoding-mapping-list> sections", xpe);
+        }
+    }
+
+}
diff --git a/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlProcessor.java b/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlProcessor.java
new file mode 100644
index 00000000..0643d4f0
--- /dev/null
+++ b/servlet4/webxml/src/main/java/cloud/piranha/servlet4/webxml/WebXmlProcessor.java
@@ -0,0 +1,404 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webxml;
+
+import static java.util.logging.Level.FINE;
+import static java.util.logging.Level.FINER;
+import static java.util.stream.Collectors.toSet;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Logger;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletRegistration;
+
+import cloud.piranha.servlet4.webapp.LocaleEncodingManager;
+import cloud.piranha.servlet4.webapp.WebApplication;
+import cloud.piranha.servlet4.webapp.WelcomeFileManager;
+import cloud.piranha.servlet4.impl.WebXml;
+import cloud.piranha.servlet4.impl.WebXmlContextParam;
+import cloud.piranha.servlet4.impl.WebXmlErrorPage;
+import cloud.piranha.servlet4.impl.WebXmlFilterInitParam;
+import cloud.piranha.servlet4.impl.WebXmlListener;
+import cloud.piranha.servlet4.impl.WebXmlMimeMapping;
+import cloud.piranha.servlet4.impl.WebXmlServlet;
+import cloud.piranha.servlet4.impl.WebXmlServletMapping;
+import cloud.piranha.servlet4.impl.WebXmlSessionConfig;
+
+/**
+ * The web.xml / web-fragment.xml processor.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class WebXmlProcessor {
+
+    /**
+     * Stores the logger.
+     */
+    private static final Logger LOGGER = Logger.getLogger(WebXmlProcessor.class.getName());
+
+    /**
+     * Stores the empty string array.
+     */
+    private static final String[] STRING_ARRAY = new String[0];
+
+    /**
+     * Process the web.xml into the web application.
+     *
+     * @param webXml the web.xml
+     * @param webApplication the web application.
+     */
+    public void process(WebXml webXml, WebApplication webApplication) {
+        LOGGER.log(FINER, "Started WebXmlProcessor.process");
+        processContextParameters(webApplication, webXml);
+        processDefaultContextPath(webApplication, webXml);
+        processDenyUncoveredHttpMethods(webApplication, webXml);
+        processDisplayName(webApplication, webXml);
+        processDistributable(webApplication, webXml);
+        processErrorPages(webApplication, webXml);
+        processFilters(webApplication, webXml);
+        processFilterMappings(webApplication, webXml);
+        processListeners(webApplication, webXml);
+        processMimeMappings(webApplication, webXml);
+        processRequestCharacterEncoding(webApplication, webXml);
+        processResponseCharacterEncoding(webApplication, webXml);
+        processRoleNames(webApplication, webXml);
+        processServlets(webApplication, webXml);
+        processServletMappings(webApplication, webXml);
+        processWebApp(webApplication, webXml);
+        processWelcomeFiles(webApplication, webXml);
+        processLocaleEncodingMapping(webApplication, webXml);
+        processSessionConfig(webApplication, webXml);
+        LOGGER.log(FINER, "Finished WebXmlProcessor.process");
+    }
+
+    /**
+     * Process the context parameters.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processContextParameters(WebApplication webApplication, WebXml webXml) {
+        Iterator<WebXmlContextParam> iterator = webXml.getContextParams().iterator();
+        while (iterator.hasNext()) {
+            WebXmlContextParam contextParam = iterator.next();
+            webApplication.setInitParameter(contextParam.getName(), contextParam.getValue());
+        }
+    }
+
+    /**
+     * Process the default context path.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processDefaultContextPath(WebApplication webApplication, WebXml webXml) {
+        if (webXml.getDefaultContextPath() != null) {
+            webApplication.setContextPath(webXml.getDefaultContextPath());
+        }
+    }
+
+    /**
+     * Process the deny uncovered HTTP methods flag.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processDenyUncoveredHttpMethods(WebApplication webApplication, WebXml webXml) {
+        webApplication.setDenyUncoveredHttpMethods(webXml.getDenyUncoveredHttpMethods());
+    }
+
+    /**
+     * Process the display name flag.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processDisplayName(WebApplication webApplication, WebXml webXml) {
+        webApplication.setServletContextName(webXml.getDisplayName());
+    }
+
+    /**
+     * Process the distributable flag.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processDistributable(WebApplication webApplication, WebXml webXml) {
+        webApplication.setDistributable(webXml.isDistributable());
+    }
+
+    /**
+     * Process the error pages.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processErrorPages(WebApplication webApplication, WebXml webXml) {
+        Iterator<WebXmlErrorPage> iterator = webXml.getErrorPages().iterator();
+        while (iterator.hasNext()) {
+            WebXmlErrorPage errorPage = iterator.next();
+            if (errorPage.getErrorCode() != null && !errorPage.getErrorCode().isEmpty()) {
+                webApplication.addErrorPage(Integer.parseInt(errorPage.getErrorCode()), errorPage.getLocation());
+            } else if (errorPage.getExceptionType() != null && !errorPage.getExceptionType().isEmpty()) {
+                webApplication.addErrorPage(errorPage.getExceptionType(), errorPage.getLocation());
+            }
+        }
+    }
+
+    /**
+     * Process the filter mappings mappings.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processFilterMappings(WebApplication webApplication, WebXml webXml) {
+        webXml.getFilterMappings().forEach(filterMapping -> {
+            // Filter is mapped to a URL pattern, e.g. /path/customer
+            webApplication.addFilterMapping(
+                toDispatcherTypes(filterMapping.getDispatchers()),
+                filterMapping.getFilterName(),
+                true,
+                filterMapping.getUrlPatterns().toArray(STRING_ARRAY));
+
+            // Filter is mapped to a named Servlet, e.g. FacesServlet
+            webApplication.addFilterMapping(
+                toDispatcherTypes(filterMapping.getDispatchers()),
+                filterMapping.getFilterName(),
+                true,
+                filterMapping.getServletNames().stream().map(e -> "servlet:// " + e).toArray(String[]::new));
+        });
+    }
+
+    private Set<DispatcherType> toDispatcherTypes(List<String> dispatchers) {
+        if (dispatchers == null) {
+            return null;
+        }
+
+        return
+            dispatchers.stream()
+                       .map(DispatcherType::valueOf)
+                       .collect(toSet());
+    }
+
+    /**
+     * Process the filters.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processFilters(WebApplication webApplication, WebXml webXml) {
+        webXml.getFilters().forEach(filter -> {
+            FilterRegistration.Dynamic dynamic = null;
+
+            if (filter.getClassName() != null) {
+                dynamic = webApplication.addFilter(filter.getFilterName(), filter.getClassName());
+            } else if (filter.getServletName() != null) {
+                dynamic = webApplication.addFilter(filter.getFilterName(), filter.getServletName());
+            }
+
+            if (dynamic != null && filter.isAsyncSupported()) {
+                dynamic.setAsyncSupported(true);
+            }
+
+            if (dynamic != null) {
+                for (WebXmlFilterInitParam initParam : filter.getInitParams()) {
+                    dynamic.setInitParameter(initParam.getName(), initParam.getValue());
+                }
+            }
+        });
+    }
+
+    /**
+     * Process the listeners.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processListeners(WebApplication webApplication, WebXml webXml) {
+        Iterator<WebXmlListener> iterator = webXml.getListeners().iterator();
+        while (iterator.hasNext()) {
+            WebXmlListener listener = iterator.next();
+            webApplication.addListener(listener.getClassName());
+        }
+    }
+
+    /**
+     * Process the mime mappings.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processMimeMappings(WebApplication webApplication, WebXml webXml) {
+        Iterator<WebXmlMimeMapping> mappingIterator = webXml.getMimeMappings().iterator();
+        while (mappingIterator.hasNext()) {
+            WebXmlMimeMapping mapping = mappingIterator.next();
+            webApplication.getMimeTypeManager()
+                    .addMimeType(mapping.getExtension(), mapping.getMimeType());
+        }
+    }
+
+    /**
+     * Process the request character encoding.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processRequestCharacterEncoding(WebApplication webApplication, WebXml webXml) {
+        if (webXml.getRequestCharacterEncoding() != null) {
+            webApplication.setRequestCharacterEncoding(webXml.getRequestCharacterEncoding());
+        }
+    }
+
+    /**
+     * Process the response character encoding.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processResponseCharacterEncoding(WebApplication webApplication, WebXml webXml) {
+        if (webXml.getResponseCharacterEncoding() != null) {
+            webApplication.setResponseCharacterEncoding(webXml.getResponseCharacterEncoding());
+        }
+    }
+
+    private void processRoleNames(WebApplication webApplication, WebXml webXml) {
+        webApplication.getSecurityManager().declareRoles(webXml.getRoleNames());
+    }
+
+    /**
+     * Process the servlet mappings.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processServletMappings(WebApplication webApplication, WebXml webXml) {
+        Iterator<WebXmlServletMapping> iterator = webXml.getServletMappings().iterator();
+        while (iterator.hasNext()) {
+            WebXmlServletMapping mapping = iterator.next();
+            webApplication.addServletMapping(
+                    mapping.getServletName(), mapping.getUrlPattern());
+        }
+    }
+
+    /**
+     * Process the web app. This is basically only the version contained within it.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processWebApp(WebApplication webApplication, WebXml webXml) {
+        webApplication.setEffectiveMajorVersion(webXml.getMajorVersion());
+        webApplication.setEffectiveMinorVersion(webXml.getMinorVersion());
+    }
+
+    /**
+     * Process the servlets.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processServlets(WebApplication webApplication, WebXml webXml) {
+        LOGGER.log(FINE, "Configuring Servlets");
+
+        Iterator<WebXmlServlet> iterator = webXml.getServlets().iterator();
+        while (iterator.hasNext()) {
+            WebXmlServlet servlet = iterator.next();
+            LOGGER.log(FINE, () -> "Configuring Servlet: " + servlet.getServletName());
+
+            ServletRegistration.Dynamic dynamic = webApplication.addServlet(servlet.getServletName(), servlet.getClassName());
+
+            String jspFile = servlet.getJspFile();
+            if (!isEmpty(jspFile))
+                webApplication.addJspFile(servlet.getServletName(), jspFile);
+
+            if (servlet.isAsyncSupported()) {
+                dynamic.setAsyncSupported(true);
+            }
+
+            servlet.getInitParams().forEach(initParam -> {
+                ServletRegistration servletRegistration = webApplication.getServletRegistration(servlet.getServletName());
+                if (servletRegistration != null)
+                    servletRegistration.setInitParameter(initParam.getName(), initParam.getValue());
+            });
+
+            LOGGER.log(FINE, () -> "Configured Servlet: " + servlet.getServletName());
+        }
+    }
+
+    /**
+     * Process the welcome files.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processWelcomeFiles(WebApplication webApplication, WebXml webXml) {
+        LOGGER.log(FINE, "Adding welcome files");
+
+        Iterator<String> iterator = webXml.getWelcomeFiles().iterator();
+        WelcomeFileManager welcomeFileManager = webApplication.getWelcomeFileManager();
+        while (iterator.hasNext()) {
+            String welcomeFile = iterator.next();
+            LOGGER.log(FINE, () -> "Adding welcome file: " + welcomeFile);
+            welcomeFileManager.addWelcomeFile(welcomeFile);
+        }
+    }
+
+    private void processLocaleEncodingMapping(WebApplication webApplication, WebXml webXml) {
+        Map<String, String> localeMapping = webXml.getLocaleEncodingMapping();
+        if (localeMapping == null)
+            return;
+
+        LocaleEncodingManager localeEncodingManager = webApplication.getLocaleEncodingManager();
+        if (localeEncodingManager == null)
+            return;
+
+        localeMapping.forEach(localeEncodingManager::addCharacterEncoding);
+    }
+
+    /**
+     * Process the session config.
+     *
+     * @param webApplication the web application.
+     * @param webXml the web.xml.
+     */
+    private void processSessionConfig (WebApplication webApplication, WebXml webXml) {
+        WebXmlSessionConfig sessionConfig = webXml.getSessionConfig();
+        if (sessionConfig == null)
+            return;
+        webApplication.setSessionTimeout(sessionConfig.getSessionTimeout());
+    }
+
+    private boolean isEmpty(String string) {
+        return string == null || string.isEmpty();
+    }
+}
diff --git a/webapp/webxml/src/test/java/module-info.java b/servlet4/webxml/src/main/java/module-info.java
similarity index 81%
rename from webapp/webxml/src/test/java/module-info.java
rename to servlet4/webxml/src/main/java/module-info.java
index 25cfb05e..eb3ba862 100644
--- a/webapp/webxml/src/test/java/module-info.java
+++ b/servlet4/webxml/src/main/java/module-info.java
@@ -26,18 +26,15 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-module cloud.piranha.webapp.webxml.tests {
+module cloud.piranha.servlet4.webxml {
     
-    exports cloud.piranha.webapp.webxml.tests;
-
-    opens cloud.piranha.webapp.webxml.tests;
-
-    requires cloud.piranha.resource;
-    requires cloud.piranha.servlet.api;
-    requires cloud.piranha.webapp.api;
-    requires cloud.piranha.webapp.impl;
-    requires cloud.piranha.webapp.webxml;
+    exports cloud.piranha.servlet4.webxml;
+    opens cloud.piranha.servlet4.webxml;
+    requires cloud.piranha.servlet4.api;
+    requires cloud.piranha.servlet4.impl;
+    requires cloud.piranha.servlet4.webapp;
     requires java.logging;
     requires java.xml;
-    requires org.junit.jupiter.api;
+    // Tests
+    requires static cloud.piranha.resource;
 }
diff --git a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/TestFilter.java b/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/TestFilter.java
similarity index 90%
rename from webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/TestFilter.java
rename to servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/TestFilter.java
index e2c7aaa7..e3d409f7 100644
--- a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/TestFilter.java
+++ b/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/TestFilter.java
@@ -25,14 +25,14 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.webxml.tests;
+package cloud.piranha.servlet4.webxml;
 
 import java.io.IOException;
-import jakarta.servlet.Filter;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 /**
  * A test filter
diff --git a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/TestServlet.java b/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/TestServlet.java
similarity index 95%
rename from webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/TestServlet.java
rename to servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/TestServlet.java
index 2c350557..88976db5 100644
--- a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/TestServlet.java
+++ b/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/TestServlet.java
@@ -25,9 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.webxml.tests;
+package cloud.piranha.servlet4.webxml;
 
-import jakarta.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServlet;
 
 /**
  * A test servlet
diff --git a/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/WebXmlInitializerTest.java b/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/WebXmlInitializerTest.java
new file mode 100644
index 00000000..7b5eb73f
--- /dev/null
+++ b/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/WebXmlInitializerTest.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webxml;
+
+import cloud.piranha.resource.DirectoryResource;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.DefaultWebApplicationClassLoader;
+import java.io.File;
+import javax.servlet.ServletRegistration;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the WebXmlInitializer class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class WebXmlInitializerTest {
+
+    /**
+     * Test onStartup method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testOnStartup() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addResource(new DirectoryResource(new File("src/test/webxml/init")));
+        webApplication.addInitializer(new WebXmlInitializer());
+        webApplication.initialize();
+        ServletRegistration registration = webApplication.getServletRegistration("Test Servlet");
+        assertNotNull(registration);
+        assertFalse(registration.getMappings().isEmpty());
+        assertEquals("*.html", registration.getMappings().iterator().next());
+        assertEquals("application/x-java-class", webApplication.getMimeType("my.class"));
+        assertEquals("myvalue", webApplication.getInitParameter("myname"));
+        assertEquals("myservletcontext", webApplication.getServletContextName());
+    }
+    
+    /**
+     * Test onStartup method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testOnStartup2() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addResource(new DirectoryResource(new File("src/test/webxml/init2")));
+        webApplication.addInitializer(new WebXmlInitializer());
+        webApplication.initialize();
+    }
+        
+    /**
+     * Test onStartup method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testOnStartup3() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.setClassLoader(new DefaultWebApplicationClassLoader(new File("src/test/webxml/init3")));
+        webApplication.addInitializer(new WebXmlInitializer());
+        webApplication.initialize();
+        assertEquals("/webfragmentInClassesMetaInf", webApplication.getContextPath());
+    }
+}
diff --git a/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/WebXmlParserTest.java b/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/WebXmlParserTest.java
new file mode 100644
index 00000000..cdbb8856
--- /dev/null
+++ b/servlet4/webxml/src/test/java/cloud/piranha/servlet4/webxml/WebXmlParserTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.servlet4.webxml;
+
+import cloud.piranha.resource.DirectoryResource;
+import cloud.piranha.servlet4.impl.DefaultWebApplication;
+import cloud.piranha.servlet4.impl.WebXml;
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import cloud.piranha.servlet4.impl.WebXmlServletMapping;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the WebXmlParser class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class WebXmlParserTest {
+    
+    /**
+     * Test parse method.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testParseWebXml() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addResource(new DirectoryResource(new File("src/test/webxml/parse")));
+        InputStream inputStream = webApplication.getResourceAsStream("WEB-INF/web.xml");
+        WebXmlParser parser = new WebXmlParser();
+        WebXml webXml = parser.parse(inputStream);
+        assertFalse(webXml.getServlets().isEmpty());
+        assertEquals(2, webXml.getServlets().size());
+        assertNotEquals(webXml.getServlets().get(0).getServletName(), webXml.getServlets().get(1).getServletName());
+        assertTrue(webXml.getServlets().get(0).isAsyncSupported());
+        assertFalse(webXml.getServlets().get(1).isAsyncSupported());
+        assertFalse(webXml.getFilters().isEmpty());
+        assertEquals(1, webXml.getFilters().size());
+        assertEquals("/defaultContextPath", webXml.getDefaultContextPath());
+        assertTrue(webXml.getDenyUncoveredHttpMethods());
+        assertEquals("myServletContextName", webXml.getDisplayName());
+        assertTrue(webXml.isDistributable());
+        assertEquals("UTF-8", webXml.getResponseCharacterEncoding());
+    }
+    
+    /**
+     * Test parse method.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testParseWebXml2() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addResource(new DirectoryResource(new File("src/test/webxml/parse2")));
+        InputStream inputStream = webApplication.getResourceAsStream("WEB-INF/web.xml");
+        WebXmlParser parser = new WebXmlParser();
+        WebXml webXml = parser.parse(inputStream);
+        assertNotEquals("/defaultContextPath", webXml.getDefaultContextPath());
+        assertFalse(webXml.getDenyUncoveredHttpMethods());
+        assertNotEquals("myServletContextName", webXml.getDisplayName());
+        assertFalse(webXml.isDistributable());
+        assertNotEquals("UTF-8", webXml.getResponseCharacterEncoding());
+    }
+    
+    /**
+     * Test parse method.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testParseWebXml3() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addResource(new DirectoryResource(new File("src/test/webxml/parse3")));
+        InputStream inputStream = webApplication.getResourceAsStream("WEB-INF/web.xml");
+        WebXmlParser parser = new WebXmlParser();
+        WebXml webXml = parser.parse(inputStream);
+        assertEquals(2, webXml.getWelcomeFiles().size());
+        assertEquals("index.html", webXml.getWelcomeFiles().get(0));
+        assertEquals("default.jsp", webXml.getWelcomeFiles().get(1));
+    }
+
+
+    /**
+     * Test parse method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testParseWebXml4() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addResource(new DirectoryResource(new File("src/test/webxml/parse4")));
+        InputStream inputStream = webApplication.getResourceAsStream("WEB-INF/web.xml");
+        WebXmlParser parser = new WebXmlParser();
+        WebXml webXml = parser.parse(inputStream);
+        assertEquals(1, webXml.getServlets().size());
+        String servletName = webXml.getServlets().get(0).getServletName();
+        assertEquals("Test Servlet", servletName);
+        List<WebXmlServletMapping> servletMappings = webXml.getServletMappings();
+        assertEquals(2, servletMappings.size());
+        assertEquals(servletName, servletMappings.get(0).getServletName());
+        assertEquals("/foo", servletMappings.get(0).getUrlPattern());
+        assertEquals(servletName, servletMappings.get(1).getServletName());
+        assertEquals("/bar", servletMappings.get(1).getUrlPattern());
+    }
+
+}
diff --git a/servlet4/webxml/src/test/webxml/init/WEB-INF/web.xml b/servlet4/webxml/src/test/webxml/init/WEB-INF/web.xml
new file mode 100644
index 00000000..af4f968f
--- /dev/null
+++ b/servlet4/webxml/src/test/webxml/init/WEB-INF/web.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<web-app xmlns="http://java.sun.com/xml/ns/javaee"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
+         version="3.0">
+    <display-name>myservletcontext</display-name>
+    <context-param>
+        <param-name>myname</param-name>
+        <param-value>myvalue</param-value>
+    </context-param>
+    <servlet>
+        <servlet-name>Test Servlet</servlet-name>
+        <servlet-class>cloud.piranha.servlet4.webxml.TestServlet</servlet-class>
+        <load-on-startup>1</load-on-startup>
+    </servlet>
+    <servlet-mapping>
+        <servlet-name>Test Servlet</servlet-name>
+        <url-pattern>*.html</url-pattern>
+    </servlet-mapping>
+    <session-config>
+        <session-timeout>30</session-timeout>
+    </session-config>
+    <mime-mapping>
+        <extension>class</extension>
+        <mime-type>application/x-java-class</mime-type>
+    </mime-mapping>
+</web-app>
diff --git a/servlet4/webxml/src/test/webxml/init2/WEB-INF/web.xml b/servlet4/webxml/src/test/webxml/init2/WEB-INF/web.xml
new file mode 100644
index 00000000..7bd8c5b7
--- /dev/null
+++ b/servlet4/webxml/src/test/webxml/init2/WEB-INF/web.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">
+    
+    <security-constraint>
+        <web-resource-collection>
+            <web-resource-name>SecureServlet</web-resource-name>
+            <url-pattern>/SecureServlet</url-pattern>
+            <http-method>GET</http-method>
+            <http-method>POST</http-method>
+        </web-resource-collection>
+        
+        <auth-constraint>
+            <role-name>someRole</role-name>
+        </auth-constraint>
+        
+        <user-data-constraint>
+            <transport-guarantee>NONE</transport-guarantee>
+        </user-data-constraint>
+    </security-constraint>
+    
+</web-app>
diff --git a/servlet4/webxml/src/test/webxml/init3/WEB-INF/classes/META-INF/web-fragment.xml b/servlet4/webxml/src/test/webxml/init3/WEB-INF/classes/META-INF/web-fragment.xml
new file mode 100644
index 00000000..716c7f25
--- /dev/null
+++ b/servlet4/webxml/src/test/webxml/init3/WEB-INF/classes/META-INF/web-fragment.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<web-fragment xmlns="http://java.sun.com/xml/ns/javaee"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="
+            http://xmlns.jcp.org/xml/ns/javaee
+            http://xmlns.jcp.org/xml/ns/javaee/web-fragment_4_0.xsd"
+         version="4.0">
+    <default-context-path>/webfragmentInClassesMetaInf</default-context-path>
+</web-fragment>
diff --git a/servlet4/webxml/src/test/webxml/parse/WEB-INF/web.xml b/servlet4/webxml/src/test/webxml/parse/WEB-INF/web.xml
new file mode 100644
index 00000000..46113c25
--- /dev/null
+++ b/servlet4/webxml/src/test/webxml/parse/WEB-INF/web.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<web-app xmlns="http://java.sun.com/xml/ns/javaee"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="
+            http://xmlns.jcp.org/xml/ns/javaee
+            http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
+         version="4.0">
+    <context-param>
+        <param-name>myname</param-name>
+        <param-value>myvalue</param-value>
+    </context-param>
+    <filter>
+        <filter-name>>Test Filter</filter-name>
+        <filter-class>cloud.piranha.servlet4.webxml.TestFilter</filter-class>
+    </filter>
+    <servlet>
+        <servlet-name>Test Servlet</servlet-name>
+        <servlet-class>cloud.piranha.servlet4.webxml.TestServlet</servlet-class>
+        <load-on-startup>1</load-on-startup>
+        <async-supported>true</async-supported>
+    </servlet>    
+    <servlet>
+        <servlet-name>Test Servlet 2</servlet-name>
+        <servlet-class>cloud.piranha.servlet4.webxml.TestServlet</servlet-class>
+        <async-supported>false</async-supported>
+    </servlet>
+    <servlet-mapping>
+        <servlet-name>Test Servlet</servlet-name>
+        <url-pattern>*.html</url-pattern>
+    </servlet-mapping>
+    <session-config>
+        <session-timeout>30</session-timeout>
+    </session-config>
+    <mime-mapping>
+        <extension>class</extension>
+        <mime-type>application/x-java-class</mime-type>
+    </mime-mapping>
+    <default-context-path>/defaultContextPath</default-context-path>
+    <deny-uncovered-http-methods/>
+    <display-name>myServletContextName</display-name>
+    <distributable/>
+    <response-character-encoding>UTF-8</response-character-encoding>
+</web-app>
diff --git a/servlet4/webxml/src/test/webxml/parse2/WEB-INF/web.xml b/servlet4/webxml/src/test/webxml/parse2/WEB-INF/web.xml
new file mode 100644
index 00000000..6c4af13b
--- /dev/null
+++ b/servlet4/webxml/src/test/webxml/parse2/WEB-INF/web.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<web-app xmlns="http://java.sun.com/xml/ns/javaee"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="
+            http://xmlns.jcp.org/xml/ns/javaee
+            http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
+         version="4.0">
+</web-app>
diff --git a/servlet4/webxml/src/test/webxml/parse3/WEB-INF/web.xml b/servlet4/webxml/src/test/webxml/parse3/WEB-INF/web.xml
new file mode 100644
index 00000000..ceb51225
--- /dev/null
+++ b/servlet4/webxml/src/test/webxml/parse3/WEB-INF/web.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">
+    <welcome-file-list>
+        <welcome-file>index.html</welcome-file>
+        <welcome-file>default.jsp</welcome-file>
+    </welcome-file-list>
+</web-app>
diff --git a/servlet4/webxml/src/test/webxml/parse4/WEB-INF/web.xml b/servlet4/webxml/src/test/webxml/parse4/WEB-INF/web.xml
new file mode 100644
index 00000000..fce026cc
--- /dev/null
+++ b/servlet4/webxml/src/test/webxml/parse4/WEB-INF/web.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">
+    <servlet>
+        <servlet-name>Test Servlet</servlet-name>
+        <servlet-class>cloud.piranha.servlet4.webxml.TestServlet</servlet-class>
+    </servlet>
+    <servlet-mapping>
+        <servlet-name>Test Servlet</servlet-name>
+        <url-pattern>/foo</url-pattern>
+        <url-pattern>/bar</url-pattern>
+    </servlet-mapping>
+</web-app>
diff --git a/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastHttpSession.java b/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastHttpSession.java
index ffce3d5a..5f64b7d6 100644
--- a/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastHttpSession.java
+++ b/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastHttpSession.java
@@ -32,9 +32,9 @@ import java.io.Serializable;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpSessionContext;
+import javax.servlet.ServletContext;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionContext;
 
 /**
  * The Hazelcast HttpSession.
diff --git a/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastHttpSessionManager.java b/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastHttpSessionManager.java
index 2fcef09f..10cb89d3 100644
--- a/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastHttpSessionManager.java
+++ b/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastHttpSessionManager.java
@@ -32,11 +32,11 @@ import com.hazelcast.core.Hazelcast;
 import com.hazelcast.core.HazelcastInstance;
 import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
 import java.util.UUID;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpSessionEvent;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionEvent;
 
 /**
  * The Hazelcast HTTP session manager.
diff --git a/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastInitializer.java b/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastInitializer.java
index 9d6946b6..8da05669 100644
--- a/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastInitializer.java
+++ b/session/hazelcast/src/main/java/cloud/piranha/session/hazelcast/HazelcastInitializer.java
@@ -29,9 +29,9 @@ package cloud.piranha.session.hazelcast;
 
 import cloud.piranha.webapp.api.WebApplication;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 import java.util.Set;
 
 /**
diff --git a/session/hazelcast/src/main/java/module-info.java b/session/hazelcast/src/main/java/module-info.java
index 4015d17b..4a732f88 100644
--- a/session/hazelcast/src/main/java/module-info.java
+++ b/session/hazelcast/src/main/java/module-info.java
@@ -28,7 +28,7 @@
 
 import cloud.piranha.session.hazelcast.HazelcastInitializer;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 module cloud.piranha.session.hazelcast {
     requires cloud.piranha.servlet4.api;
diff --git a/test/arquillian/servlet-basic/src/main/java/cloud/piranha/test/arquillian/ProtectedServlet.java b/test/arquillian/servlet-basic/src/main/java/cloud/piranha/test/arquillian/ProtectedServlet.java
index 5772996e..443e3f09 100644
--- a/test/arquillian/servlet-basic/src/main/java/cloud/piranha/test/arquillian/ProtectedServlet.java
+++ b/test/arquillian/servlet-basic/src/main/java/cloud/piranha/test/arquillian/ProtectedServlet.java
@@ -29,11 +29,11 @@ package cloud.piranha.test.arquillian;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * 
diff --git a/test/classloader/src/main/java/cloud/piranha/test/classloader/Test1Servlet.java b/test/classloader/src/main/java/cloud/piranha/test/classloader/Test1Servlet.java
index 2dc03f89..59678caf 100644
--- a/test/classloader/src/main/java/cloud/piranha/test/classloader/Test1Servlet.java
+++ b/test/classloader/src/main/java/cloud/piranha/test/classloader/Test1Servlet.java
@@ -27,8 +27,8 @@
  */
 package cloud.piranha.test.classloader;
 
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
 
 /**
  * The Test 1 Servlet.
diff --git a/test/embedded/src/main/java/cloud/piranha/test/embedded/Embedded.java b/test/embedded/src/main/java/cloud/piranha/test/embedded/Embedded.java
index be0c71e1..22431486 100644
--- a/test/embedded/src/main/java/cloud/piranha/test/embedded/Embedded.java
+++ b/test/embedded/src/main/java/cloud/piranha/test/embedded/Embedded.java
@@ -29,7 +29,7 @@ package cloud.piranha.test.embedded;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletException;
 
 import cloud.piranha.embedded.EmbeddedPiranha;
 import cloud.piranha.embedded.EmbeddedRequest;
diff --git a/test/exousia/src/test/java/cloud/piranha/test/exousia/PublicServlet.java b/test/exousia/src/test/java/cloud/piranha/test/exousia/PublicServlet.java
index 8472dec8..60aa6970 100644
--- a/test/exousia/src/test/java/cloud/piranha/test/exousia/PublicServlet.java
+++ b/test/exousia/src/test/java/cloud/piranha/test/exousia/PublicServlet.java
@@ -29,11 +29,11 @@ package cloud.piranha.test.exousia;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * This Servlet writes out a text
diff --git a/test/snoop/src/main/java/cloud/piranha/test/snoop/SnoopServlet.java b/test/snoop/src/main/java/cloud/piranha/test/snoop/SnoopServlet.java
index b7a9e3fe..b38eb240 100644
--- a/test/snoop/src/main/java/cloud/piranha/test/snoop/SnoopServlet.java
+++ b/test/snoop/src/main/java/cloud/piranha/test/snoop/SnoopServlet.java
@@ -34,12 +34,12 @@ import java.util.Enumeration;
 import java.util.Locale;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
 
 /**
  * A simple Snoop Servlet.
diff --git a/test/snoop/src/test/java/cloud/piranha/test/snoop/SnoopServletTest.java b/test/snoop/src/test/java/cloud/piranha/test/snoop/SnoopServletTest.java
index 87280496..41fbdb95 100644
--- a/test/snoop/src/test/java/cloud/piranha/test/snoop/SnoopServletTest.java
+++ b/test/snoop/src/test/java/cloud/piranha/test/snoop/SnoopServletTest.java
@@ -35,7 +35,7 @@ import cloud.piranha.embedded.EmbeddedResponse;
 import cloud.piranha.embedded.EmbeddedResponseBuilder;
 import org.junit.jupiter.api.Test;
 
-import jakarta.servlet.http.Cookie;
+import javax.servlet.http.Cookie;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
diff --git a/test/soteria/basic/src/test/java/cloud/piranha/test/soteria/basic/ProtectedServlet.java b/test/soteria/basic/src/test/java/cloud/piranha/test/soteria/basic/ProtectedServlet.java
index 7154af6b..aba809b1 100644
--- a/test/soteria/basic/src/test/java/cloud/piranha/test/soteria/basic/ProtectedServlet.java
+++ b/test/soteria/basic/src/test/java/cloud/piranha/test/soteria/basic/ProtectedServlet.java
@@ -29,11 +29,11 @@ package cloud.piranha.test.soteria.basic;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * 
diff --git a/test/soteria/basic/src/test/java/cloud/piranha/test/soteria/basic/PublicServlet.java b/test/soteria/basic/src/test/java/cloud/piranha/test/soteria/basic/PublicServlet.java
index 8e1241b4..ba336fd9 100644
--- a/test/soteria/basic/src/test/java/cloud/piranha/test/soteria/basic/PublicServlet.java
+++ b/test/soteria/basic/src/test/java/cloud/piranha/test/soteria/basic/PublicServlet.java
@@ -29,11 +29,11 @@ package cloud.piranha.test.soteria.basic;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * This Servlet writes out the current caller principal name and checks whether the
diff --git a/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/ErrorPageServlet.java b/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/ErrorPageServlet.java
index 1b3c0f33..92557543 100644
--- a/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/ErrorPageServlet.java
+++ b/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/ErrorPageServlet.java
@@ -29,10 +29,10 @@ package cloud.piranha.test.soteria.form;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * 
diff --git a/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/FormTest.java b/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/FormTest.java
index 1ffe4f29..bc21cff4 100644
--- a/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/FormTest.java
+++ b/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/FormTest.java
@@ -48,7 +48,7 @@ import static java.util.Arrays.asList;
 import static javax.naming.Context.INITIAL_CONTEXT_FACTORY;
 import javax.security.enterprise.authentication.mechanism.http.FormAuthenticationMechanismDefinition;
 import javax.security.enterprise.authentication.mechanism.http.LoginToContinue;
-import jakarta.servlet.http.Cookie;
+import javax.servlet.http.Cookie;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import org.junit.jupiter.api.Test;
diff --git a/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/LoginPageServlet.java b/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/LoginPageServlet.java
index fd2b480c..2191f151 100644
--- a/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/LoginPageServlet.java
+++ b/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/LoginPageServlet.java
@@ -29,10 +29,10 @@ package cloud.piranha.test.soteria.form;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * 
diff --git a/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/ProtectedServlet.java b/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/ProtectedServlet.java
index 312b3cf6..36f26dcb 100644
--- a/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/ProtectedServlet.java
+++ b/test/soteria/form/src/test/java/cloud/piranha/test/soteria/form/ProtectedServlet.java
@@ -29,11 +29,11 @@ package cloud.piranha.test.soteria.form;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * 
diff --git a/test/springmvc/src/main/java/cloud/piranha/test/springmvc/HelloSpringController.java b/test/springmvc/src/main/java/cloud/piranha/test/springmvc/HelloSpringController.java
index 3900d54e..d67ef2b5 100644
--- a/test/springmvc/src/main/java/cloud/piranha/test/springmvc/HelloSpringController.java
+++ b/test/springmvc/src/main/java/cloud/piranha/test/springmvc/HelloSpringController.java
@@ -28,9 +28,9 @@
 package cloud.piranha.test.springmvc;
 
 import java.io.IOException;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import org.springframework.web.servlet.ModelAndView;
 import org.springframework.web.servlet.mvc.Controller;
 
diff --git a/test/vaadin/src/main/java/cloud/piranha/test/vaadin/HelloVaadinServlet.java b/test/vaadin/src/main/java/cloud/piranha/test/vaadin/HelloVaadinServlet.java
index faa494dd..2d41140a 100644
--- a/test/vaadin/src/main/java/cloud/piranha/test/vaadin/HelloVaadinServlet.java
+++ b/test/vaadin/src/main/java/cloud/piranha/test/vaadin/HelloVaadinServlet.java
@@ -29,7 +29,7 @@ package cloud.piranha.test.vaadin;
 
 import com.vaadin.annotations.VaadinServletConfiguration;
 import com.vaadin.server.VaadinServlet;
-import jakarta.servlet.annotation.WebServlet;
+import javax.servlet.annotation.WebServlet;
 
 /**
  * The HelloVaadin servlet.
diff --git a/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPart.java b/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPart.java
index ba6d2b7c..fae0667a 100644
--- a/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPart.java
+++ b/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPart.java
@@ -32,7 +32,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collection;
-import jakarta.servlet.http.Part;
+import javax.servlet.http.Part;
 import org.apache.commons.fileupload.FileItem;
 
 /**
diff --git a/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPartInitializer.java b/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPartInitializer.java
index 7a323cdd..7eaf853b 100644
--- a/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPartInitializer.java
+++ b/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPartInitializer.java
@@ -30,9 +30,9 @@ package cloud.piranha.upload.apache;
 import cloud.piranha.webapp.api.WebApplication;
 import java.util.Set;
 import java.util.logging.Logger;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 /**
  * The ServletContainerInitializer for the ApacheMultiPartManager.
@@ -59,7 +59,7 @@ public class ApacheMultiPartInitializer implements ServletContainerInitializer {
 
     /**
      * @see ServletContainerInitializer#onStartup(java.util.Set,
-     * jakarta.servlet.ServletContext)
+     * javax.servlet.ServletContext)
      */
     @Override
     public void onStartup(Set<Class<?>> classes, ServletContext servletContext)
diff --git a/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPartManager.java b/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPartManager.java
index 1c5019db..6d3e1838 100644
--- a/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPartManager.java
+++ b/upload/apache/src/main/java/cloud/piranha/upload/apache/ApacheMultiPartManager.java
@@ -37,9 +37,9 @@ import java.util.List;
 import static java.util.logging.Level.FINE;
 import static java.util.logging.Level.WARNING;
 import java.util.logging.Logger;
-import static jakarta.servlet.ServletContext.TEMPDIR;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Part;
+import static javax.servlet.ServletContext.TEMPDIR;
+import javax.servlet.ServletException;
+import javax.servlet.http.Part;
 import org.apache.commons.fileupload.FileItem;
 import org.apache.commons.fileupload.FileUploadException;
 import org.apache.commons.fileupload.disk.DiskFileItemFactory;
diff --git a/upload/apache/src/main/java/module-info.java b/upload/apache/src/main/java/module-info.java
index dfa4e455..5979712c 100644
--- a/upload/apache/src/main/java/module-info.java
+++ b/upload/apache/src/main/java/module-info.java
@@ -27,7 +27,7 @@
 
 import cloud.piranha.upload.apache.ApacheMultiPartInitializer;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 module cloud.piranha.upload.apache {
     requires cloud.piranha.servlet4.api;
diff --git a/upload/pom.xml b/upload/pom.xml
index af1d43c7..fef6c98c 100644
--- a/upload/pom.xml
+++ b/upload/pom.xml
@@ -16,9 +16,7 @@
     <name>Piranha Upload - Project</name>
 
     <modules>
-        <!--
         <module>apache</module>
-         -->
     </modules>
 
     <dependencyManagement>
diff --git a/webapp/annotationscan/src/main/java/cloud/piranha/webapp/annotationscan/AnnotationScanExtension.java b/webapp/annotationscan/src/main/java/cloud/piranha/webapp/annotationscan/AnnotationScanExtension.java
index 58d86a98..d4b9bbf2 100644
--- a/webapp/annotationscan/src/main/java/cloud/piranha/webapp/annotationscan/AnnotationScanExtension.java
+++ b/webapp/annotationscan/src/main/java/cloud/piranha/webapp/annotationscan/AnnotationScanExtension.java
@@ -31,7 +31,7 @@ import java.lang.reflect.InvocationTargetException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.api.WebApplicationExtension;
diff --git a/webapp/annotationscan/src/main/java/cloud/piranha/webapp/annotationscan/AnnotationScanInitializer.java b/webapp/annotationscan/src/main/java/cloud/piranha/webapp/annotationscan/AnnotationScanInitializer.java
index 0f279723..764b1baf 100644
--- a/webapp/annotationscan/src/main/java/cloud/piranha/webapp/annotationscan/AnnotationScanInitializer.java
+++ b/webapp/annotationscan/src/main/java/cloud/piranha/webapp/annotationscan/AnnotationScanInitializer.java
@@ -34,15 +34,15 @@ import java.util.Set;
 import java.util.logging.Logger;
 import java.util.stream.Stream;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.annotation.MultipartConfig;
-import jakarta.servlet.annotation.ServletSecurity;
-import jakarta.servlet.annotation.WebFilter;
-import jakarta.servlet.annotation.WebInitParam;
-import jakarta.servlet.annotation.WebListener;
-import jakarta.servlet.annotation.WebServlet;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.MultipartConfig;
+import javax.servlet.annotation.ServletSecurity;
+import javax.servlet.annotation.WebFilter;
+import javax.servlet.annotation.WebInitParam;
+import javax.servlet.annotation.WebListener;
+import javax.servlet.annotation.WebServlet;
 
 import cloud.piranha.resource.api.ResourceManagerClassLoader;
 import cloud.piranha.webapp.api.AnnotationManager;
diff --git a/webapp/annotationscan/src/main/java/module-info.java b/webapp/annotationscan/src/main/java/module-info.java
index 10242199..cf5fbe1e 100644
--- a/webapp/annotationscan/src/main/java/module-info.java
+++ b/webapp/annotationscan/src/main/java/module-info.java
@@ -25,16 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-
 module cloud.piranha.webapp.annotationscan {
-
-    exports cloud.piranha.webapp.annotationscan;
-
-    opens cloud.piranha.webapp.annotationscan;
-    
     requires cloud.piranha.resource.api;
-    requires cloud.piranha.servlet.api;
+    requires cloud.piranha.servlet4.api;
     requires cloud.piranha.webapp.api;
     requires cloud.piranha.webapp.impl;
+
     requires java.logging;
+
+    exports cloud.piranha.webapp.annotationscan;
 }
diff --git a/webapp/api/pom.xml b/webapp/api/pom.xml
index a3c41f1c..d9a9a528 100644
--- a/webapp/api/pom.xml
+++ b/webapp/api/pom.xml
@@ -15,6 +15,12 @@
     <name>Piranha Webapplication - API</name>
 
     <dependencies>
+        <dependency>
+            <groupId>cloud.piranha.http</groupId>
+            <artifactId>piranha-http-api</artifactId>
+            <version>${project.version}</version>
+            <scope>provided</scope>
+        </dependency>
         <dependency>
             <groupId>cloud.piranha.naming</groupId>
             <artifactId>piranha-naming-api</artifactId>
@@ -31,13 +37,13 @@
             <groupId>cloud.piranha.resource</groupId>
             <artifactId>piranha-resource-api</artifactId>
             <version>${project.version}</version>
-            <scope>compile</scope>
+            <scope>provided</scope>
         </dependency>
         <dependency>
-            <groupId>cloud.piranha.servlet</groupId>
-            <artifactId>piranha-servlet-api</artifactId>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
             <version>${project.version}</version>
-            <scope>compile</scope>
+            <scope>provided</scope>
         </dependency>
     </dependencies>
 </project>
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/AsyncManager.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/AsyncManager.java
index b338e11e..89c1a57e 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/AsyncManager.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/AsyncManager.java
@@ -27,8 +27,8 @@
  */
 package cloud.piranha.webapp.api;
 
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 /**
  * The AsyncManager API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/CurrentRequestHolder.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/CurrentRequestHolder.java
index 707275ec..af2833a9 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/CurrentRequestHolder.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/CurrentRequestHolder.java
@@ -27,7 +27,7 @@
  */
 package cloud.piranha.webapp.api;
 
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequest;
 
 /**
  * A holder that references the current <code>HttpServletRequest </code>in the request processing
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/FilterEnvironment.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/FilterEnvironment.java
index 6cc81939..e683ed19 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/FilterEnvironment.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/FilterEnvironment.java
@@ -27,10 +27,10 @@
  */
 package cloud.piranha.webapp.api;
 
-import jakarta.servlet.Filter;
-import jakarta.servlet.FilterConfig;
-import jakarta.servlet.FilterRegistration.Dynamic;
-import jakarta.servlet.ServletException;
+import javax.servlet.Filter;
+import javax.servlet.FilterConfig;
+import javax.servlet.FilterRegistration.Dynamic;
+import javax.servlet.ServletException;
 
 /**
  *
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/FilterMapping.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/FilterMapping.java
index ed3887d9..b769b889 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/FilterMapping.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/FilterMapping.java
@@ -27,9 +27,9 @@
  */
 package cloud.piranha.webapp.api;
 
-import static jakarta.servlet.DispatcherType.REQUEST;
+import static javax.servlet.DispatcherType.REQUEST;
 
-import jakarta.servlet.DispatcherType;
+import javax.servlet.DispatcherType;
 
 /**
  * The FilterMapping API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/HttpRequestManager.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/HttpRequestManager.java
index 975069b3..22ae98ea 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/HttpRequestManager.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/HttpRequestManager.java
@@ -29,7 +29,7 @@ package cloud.piranha.webapp.api;
 
 import java.util.EventListener;
 
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequest;
 
 /**
  *
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/HttpSessionManager.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/HttpSessionManager.java
index a234fae0..a1212dd5 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/HttpSessionManager.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/HttpSessionManager.java
@@ -29,11 +29,11 @@ package cloud.piranha.webapp.api;
 
 import java.util.EventListener;
 import java.util.Set;
-import jakarta.servlet.SessionCookieConfig;
-import jakarta.servlet.SessionTrackingMode;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
+import javax.servlet.SessionCookieConfig;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
 
 /**
  * The HttpSessionManager API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/JspManager.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/JspManager.java
index 7344d971..e2af0860 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/JspManager.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/JspManager.java
@@ -27,8 +27,8 @@
  */
 package cloud.piranha.webapp.api;
 
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.descriptor.JspConfigDescriptor;
+import javax.servlet.ServletRegistration;
+import javax.servlet.descriptor.JspConfigDescriptor;
 
 /**
  * The JspManager API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/MultiPartManager.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/MultiPartManager.java
index 31a7da63..a8204a5c 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/MultiPartManager.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/MultiPartManager.java
@@ -29,8 +29,8 @@ package cloud.piranha.webapp.api;
 
 import java.util.Collection;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Part;
+import javax.servlet.ServletException;
+import javax.servlet.http.Part;
 
 /**
  * The multi-part manager API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/ObjectInstanceManager.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/ObjectInstanceManager.java
index c6de6026..95d63871 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/ObjectInstanceManager.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/ObjectInstanceManager.java
@@ -29,9 +29,9 @@ package cloud.piranha.webapp.api;
 
 import java.util.EventListener;
 
-import jakarta.servlet.Filter;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
+import javax.servlet.Filter;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
 
 /**
  * The object instance manager API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/SecurityManager.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/SecurityManager.java
index a70ce8a5..9e1a6b6a 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/SecurityManager.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/SecurityManager.java
@@ -31,9 +31,9 @@ import java.io.IOException;
 import java.util.Collection;
 import java.util.Set;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * The SecurityManager API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/ServletEnvironment.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/ServletEnvironment.java
index db985fc7..b82e9f35 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/ServletEnvironment.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/ServletEnvironment.java
@@ -27,10 +27,10 @@
  */
 package cloud.piranha.webapp.api;
 
-import jakarta.servlet.MultipartConfigElement;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletRegistration.Dynamic;
+import javax.servlet.MultipartConfigElement;
+import javax.servlet.Servlet;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletRegistration.Dynamic;
 
 /**
  * The environment for a Servlet.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/ServletInvocation.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/ServletInvocation.java
index 74210065..fa91c01b 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/ServletInvocation.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/ServletInvocation.java
@@ -31,8 +31,8 @@ import static cloud.piranha.webapp.api.ServletEnvironment.UNAVAILABLE;
 
 import java.util.List;
 
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.ServletConfig;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletConfig;
 
 /**
  * The ServletInvocation API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplication.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplication.java
index f2382e41..f498a5a6 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplication.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplication.java
@@ -35,15 +35,15 @@ import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.DispatcherType;
+import javax.servlet.FilterRegistration;
+import javax.servlet.Servlet;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 import cloud.piranha.resource.api.Resource;
 import cloud.piranha.resource.api.ResourceManager;
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationRequest.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationRequest.java
index 0c852bf8..fa7735d3 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationRequest.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationRequest.java
@@ -27,8 +27,8 @@
  */
 package cloud.piranha.webapp.api;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.DispatcherType;
+import javax.servlet.http.HttpServletRequest;
 
 /**
  * The WebApplicationRequest API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationRequestMapper.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationRequestMapper.java
index d5012552..6aae4b9b 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationRequestMapper.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationRequestMapper.java
@@ -27,12 +27,12 @@
  */
 package cloud.piranha.webapp.api;
 
-import static jakarta.servlet.DispatcherType.REQUEST;
+import static javax.servlet.DispatcherType.REQUEST;
 
 import java.util.Collection;
 import java.util.Set;
 
-import jakarta.servlet.DispatcherType;
+import javax.servlet.DispatcherType;
 
 /**
  * The WebApplicationRequestMapper API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationResponse.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationResponse.java
index 13deccac..450f1c85 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationResponse.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationResponse.java
@@ -31,8 +31,8 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Collection;
 
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * The WebApplicationResponse API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationServer.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationServer.java
index d0ae8882..9c299f5b 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationServer.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/WebApplicationServer.java
@@ -28,7 +28,7 @@
 package cloud.piranha.webapp.api;
 
 import java.io.IOException;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletException;
 
 /**
  * The WebApplicationServer API.
diff --git a/webapp/api/src/main/java/cloud/piranha/webapp/api/WelcomeFileManager.java b/webapp/api/src/main/java/cloud/piranha/webapp/api/WelcomeFileManager.java
index d3e7b781..17b2e28e 100644
--- a/webapp/api/src/main/java/cloud/piranha/webapp/api/WelcomeFileManager.java
+++ b/webapp/api/src/main/java/cloud/piranha/webapp/api/WelcomeFileManager.java
@@ -29,10 +29,10 @@ package cloud.piranha.webapp.api;
 
 import java.io.IOException;
 import java.util.List;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 /**
  * The WelcomeFileManager API.
diff --git a/webapp/api/src/main/java/module-info.java b/webapp/api/src/main/java/module-info.java
index d670ef1f..be3bb861 100644
--- a/webapp/api/src/main/java/module-info.java
+++ b/webapp/api/src/main/java/module-info.java
@@ -25,24 +25,11 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-
-/**
- * The Piranha Webapplication - API mopdule.
- * 
- * <p>
- *  This module defines the runtime API for each web application. 
- * </p>
- * 
- * @author Manfred Riem (mriem@manorrock.com)
- */
 module cloud.piranha.webapp.api {
-    
     exports cloud.piranha.webapp.api;
-    
-    opens cloud.piranha.webapp.api;
-
+    requires static cloud.piranha.http.api;
+    requires static cloud.piranha.resource.api;
+    requires static cloud.piranha.servlet4.api;
     requires cloud.piranha.naming.api;
     requires cloud.piranha.policy.api;
-    requires cloud.piranha.resource.api;
-    requires cloud.piranha.servlet.api;
 }
diff --git a/webapp/impl/pom.xml b/webapp/impl/pom.xml
index 7814fe63..2a97c964 100644
--- a/webapp/impl/pom.xml
+++ b/webapp/impl/pom.xml
@@ -43,6 +43,12 @@
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
+        <dependency>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
+            <version>${project.version}</version>
+            <scope>compile</scope>
+        </dependency>
         <dependency>
             <groupId>cloud.piranha.webapp</groupId>
             <artifactId>piranha-webapp-api</artifactId>
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/AsyncHttpDispatchWrapper.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/AsyncHttpDispatchWrapper.java
index e30b3dfa..d1afb8c8 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/AsyncHttpDispatchWrapper.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/AsyncHttpDispatchWrapper.java
@@ -31,7 +31,7 @@ import static java.util.Collections.enumeration;
 import static java.util.Collections.list;
 import static java.util.Collections.unmodifiableMap;
 import static java.util.Objects.requireNonNull;
-import static jakarta.servlet.DispatcherType.ASYNC;
+import static javax.servlet.DispatcherType.ASYNC;
 
 import java.util.ArrayList;
 import java.util.Enumeration;
@@ -40,12 +40,12 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 
-import jakarta.servlet.AsyncContext;
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletRequestWrapper;
+import javax.servlet.AsyncContext;
+import javax.servlet.DispatcherType;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
 
 import cloud.piranha.webapp.api.AttributeManager;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/AsyncNonHttpDispatchWrapper.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/AsyncNonHttpDispatchWrapper.java
index 14ecb329..fbfde3ce 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/AsyncNonHttpDispatchWrapper.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/AsyncNonHttpDispatchWrapper.java
@@ -27,13 +27,13 @@
  */
 package cloud.piranha.webapp.impl;
 
-import static jakarta.servlet.DispatcherType.ASYNC;
+import static javax.servlet.DispatcherType.ASYNC;
 
 import java.util.Map;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletRequestWrapper;
+import javax.servlet.DispatcherType;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestWrapper;
 
 /**
  * The async non-HTTP dispatch wrapper.
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncContext.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncContext.java
index e2421168..d1098857 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncContext.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncContext.java
@@ -38,16 +38,16 @@ import java.util.List;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.logging.Logger;
 
-import jakarta.servlet.AsyncContext;
-import jakarta.servlet.AsyncEvent;
-import jakarta.servlet.AsyncListener;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletRequestWrapper;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.ServletResponseWrapper;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.AsyncContext;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestWrapper;
+import javax.servlet.ServletResponse;
+import javax.servlet.ServletResponseWrapper;
+import javax.servlet.http.HttpServletRequest;
 
 import cloud.piranha.webapp.api.AsyncManager;
 import cloud.piranha.webapp.api.WebApplication;
@@ -153,7 +153,7 @@ public class DefaultAsyncContext implements AsyncContext {
      * Add the listener.
      *
      * @param listener the listener.
-     * @see AsyncContext#addListener(jakarta.servlet.AsyncListener)
+     * @see AsyncContext#addListener(javax.servlet.AsyncListener)
      */
     @Override
     public void addListener(AsyncListener listener) {
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncDispatcher.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncDispatcher.java
index 430c8128..c93815e2 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncDispatcher.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncDispatcher.java
@@ -27,11 +27,11 @@
  */
 package cloud.piranha.webapp.impl;
 
-import jakarta.servlet.AsyncContext;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.AsyncContext;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
 
 import cloud.piranha.webapp.api.AsyncDispatcher;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncManager.java
index 8c8fdcd7..6148758a 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultAsyncManager.java
@@ -27,8 +27,8 @@
  */
 package cloud.piranha.webapp.impl;
 
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 import cloud.piranha.webapp.api.AsyncDispatcher;
 import cloud.piranha.webapp.api.AsyncManager;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultCurrentRequestHolder.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultCurrentRequestHolder.java
index dca22296..74d0fa7e 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultCurrentRequestHolder.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultCurrentRequestHolder.java
@@ -27,7 +27,7 @@
  */
 package cloud.piranha.webapp.impl;
 
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequest;
 
 import cloud.piranha.webapp.api.CurrentRequestHolder;
 
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultErrorPageManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultErrorPageManager.java
index 6f8cae47..46f7c9f7 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultErrorPageManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultErrorPageManager.java
@@ -27,8 +27,8 @@
  */
 package cloud.piranha.webapp.impl;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletResponse;
 import java.util.HashMap;
 import java.util.Map;
 
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterChain.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterChain.java
index 01d7c18e..b487a5b1 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterChain.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterChain.java
@@ -27,18 +27,18 @@
  */
 package cloud.piranha.webapp.impl;
 
-import static jakarta.servlet.http.HttpServletResponse.SC_NOT_FOUND;
+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
 
 import java.io.IOException;
 
-import jakarta.servlet.Filter;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.UnavailableException;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.UnavailableException;
+import javax.servlet.http.HttpServletResponse;
 
 import cloud.piranha.webapp.api.ServletInvocation;
 
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterEnvironment.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterEnvironment.java
index 81ba75e2..db31788d 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterEnvironment.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterEnvironment.java
@@ -39,10 +39,10 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.stream.Stream;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.Filter;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.DispatcherType;
+import javax.servlet.Filter;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import cloud.piranha.webapp.api.FilterEnvironment;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterMapping.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterMapping.java
index 196d33de..ff8b00a5 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterMapping.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultFilterMapping.java
@@ -27,11 +27,11 @@
  */
 package cloud.piranha.webapp.impl;
 
-import static jakarta.servlet.DispatcherType.REQUEST;
+import static javax.servlet.DispatcherType.REQUEST;
 
 import java.util.Objects;
 
-import jakarta.servlet.DispatcherType;
+import javax.servlet.DispatcherType;
 
 import cloud.piranha.webapp.api.FilterMapping;
 
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpRequestManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpRequestManager.java
index 98c398ab..4ca6df15 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpRequestManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpRequestManager.java
@@ -31,9 +31,9 @@ import java.util.ArrayList;
 import java.util.EventListener;
 import java.util.List;
 
-import jakarta.servlet.ServletRequestAttributeEvent;
-import jakarta.servlet.ServletRequestAttributeListener;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.ServletRequestAttributeEvent;
+import javax.servlet.ServletRequestAttributeListener;
+import javax.servlet.http.HttpServletRequest;
 
 import cloud.piranha.webapp.api.HttpRequestManager;
 
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpSession.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpSession.java
index cc3a2ed1..18b067f7 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpSession.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpSession.java
@@ -32,9 +32,9 @@ import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.UUID;
 
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpSessionContext;
+import javax.servlet.ServletContext;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionContext;
 
 import cloud.piranha.webapp.api.HttpSessionManager;
 
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpSessionManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpSessionManager.java
index 1b8ccb24..fa28e7aa 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpSessionManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultHttpSessionManager.java
@@ -37,18 +37,18 @@ import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
-import jakarta.servlet.SessionCookieConfig;
-import jakarta.servlet.SessionTrackingMode;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpSessionAttributeListener;
-import jakarta.servlet.http.HttpSessionBindingEvent;
-import jakarta.servlet.http.HttpSessionBindingListener;
-import jakarta.servlet.http.HttpSessionEvent;
-import jakarta.servlet.http.HttpSessionIdListener;
-import jakarta.servlet.http.HttpSessionListener;
+import javax.servlet.SessionCookieConfig;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionAttributeListener;
+import javax.servlet.http.HttpSessionBindingEvent;
+import javax.servlet.http.HttpSessionBindingListener;
+import javax.servlet.http.HttpSessionEvent;
+import javax.servlet.http.HttpSessionIdListener;
+import javax.servlet.http.HttpSessionListener;
 
 /**
  * The default HttpSessionManager.
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultInvocationFinder.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultInvocationFinder.java
index c6eaf280..a1b623f8 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultInvocationFinder.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultInvocationFinder.java
@@ -29,7 +29,7 @@ package cloud.piranha.webapp.impl;
 
 import static java.util.Collections.reverse;
 import static java.util.stream.Collectors.toList;
-import static jakarta.servlet.DispatcherType.REQUEST;
+import static javax.servlet.DispatcherType.REQUEST;
 
 import java.io.IOException;
 import java.net.MalformedURLException;
@@ -38,10 +38,10 @@ import java.util.Collection;
 import java.util.List;
 import java.util.Objects;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
+import javax.servlet.DispatcherType;
+import javax.servlet.FilterChain;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
 
 import cloud.piranha.webapp.api.FilterEnvironment;
 import cloud.piranha.webapp.api.FilterPriority;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultJspFileManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultJspFileManager.java
index c2a45a1b..979b7952 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultJspFileManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultJspFileManager.java
@@ -27,8 +27,8 @@
  */
 package cloud.piranha.webapp.impl;
 
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.descriptor.JspConfigDescriptor;
+import javax.servlet.ServletRegistration;
+import javax.servlet.descriptor.JspConfigDescriptor;
 
 import cloud.piranha.webapp.api.JspManager;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultMultiPartManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultMultiPartManager.java
index 5977aaaa..78dd0bf2 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultMultiPartManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultMultiPartManager.java
@@ -32,8 +32,8 @@ import java.util.Collections;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.Part;
+import javax.servlet.ServletException;
+import javax.servlet.http.Part;
 
 import cloud.piranha.webapp.api.MultiPartManager;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultObjectInstanceManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultObjectInstanceManager.java
index fc36c824..0fb3f76b 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultObjectInstanceManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultObjectInstanceManager.java
@@ -29,9 +29,9 @@ package cloud.piranha.webapp.impl;
 
 import java.util.EventListener;
 
-import jakarta.servlet.Filter;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletException;
+import javax.servlet.Filter;
+import javax.servlet.Servlet;
+import javax.servlet.ServletException;
 
 import cloud.piranha.webapp.api.ObjectInstanceManager;
 
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultSecurityManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultSecurityManager.java
index e01a07c0..70a7c1c5 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultSecurityManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultSecurityManager.java
@@ -34,10 +34,10 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Set;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletRequestWrapper;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
+import javax.servlet.http.HttpServletResponse;
 
 import cloud.piranha.webapp.api.SecurityManager;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServlet.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServlet.java
index 02a359b8..baa64b01 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServlet.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServlet.java
@@ -27,7 +27,7 @@
  */
 package cloud.piranha.webapp.impl;
 
-import static jakarta.servlet.http.HttpServletResponse.SC_NOT_FOUND;
+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
@@ -36,12 +36,12 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintWriter;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.DispatcherType;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 /**
  * The default Servlet.
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletEnvironment.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletEnvironment.java
index 47071e1f..ae54e895 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletEnvironment.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletEnvironment.java
@@ -36,10 +36,10 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import jakarta.servlet.MultipartConfigElement;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletSecurityElement;
+import javax.servlet.MultipartConfigElement;
+import javax.servlet.Servlet;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletSecurityElement;
 
 import cloud.piranha.webapp.api.ServletEnvironment;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletInvocation.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletInvocation.java
index 5af9d9f3..7c84b201 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletInvocation.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletInvocation.java
@@ -29,7 +29,7 @@ package cloud.piranha.webapp.impl;
 
 import java.util.List;
 
-import jakarta.servlet.FilterChain;
+import javax.servlet.FilterChain;
 
 import cloud.piranha.webapp.api.FilterEnvironment;
 import cloud.piranha.webapp.api.ServletEnvironment;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletRequestDispatcher.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletRequestDispatcher.java
index 87cc388b..c0295d0a 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletRequestDispatcher.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultServletRequestDispatcher.java
@@ -30,17 +30,17 @@ package cloud.piranha.webapp.impl;
 import static cloud.piranha.webapp.api.CurrentRequestHolder.CURRENT_REQUEST_ATTRIBUTE;
 import static cloud.piranha.webapp.impl.DefaultWebApplicationRequest.unwrap;
 import static java.util.Arrays.asList;
-import static jakarta.servlet.AsyncContext.ASYNC_CONTEXT_PATH;
-import static jakarta.servlet.AsyncContext.ASYNC_PATH_INFO;
-import static jakarta.servlet.AsyncContext.ASYNC_QUERY_STRING;
-import static jakarta.servlet.AsyncContext.ASYNC_REQUEST_URI;
-import static jakarta.servlet.AsyncContext.ASYNC_SERVLET_PATH;
-import static jakarta.servlet.DispatcherType.ASYNC;
-import static jakarta.servlet.DispatcherType.ERROR;
-import static jakarta.servlet.DispatcherType.FORWARD;
-import static jakarta.servlet.DispatcherType.INCLUDE;
-import static jakarta.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
-import static jakarta.servlet.http.HttpServletResponse.SC_NOT_FOUND;
+import static javax.servlet.AsyncContext.ASYNC_CONTEXT_PATH;
+import static javax.servlet.AsyncContext.ASYNC_PATH_INFO;
+import static javax.servlet.AsyncContext.ASYNC_QUERY_STRING;
+import static javax.servlet.AsyncContext.ASYNC_REQUEST_URI;
+import static javax.servlet.AsyncContext.ASYNC_SERVLET_PATH;
+import static javax.servlet.DispatcherType.ASYNC;
+import static javax.servlet.DispatcherType.ERROR;
+import static javax.servlet.DispatcherType.FORWARD;
+import static javax.servlet.DispatcherType.INCLUDE;
+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
 
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
@@ -51,15 +51,15 @@ import java.util.Map;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletRequestWrapper;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.UnavailableException;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletRequestWrapper;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestWrapper;
+import javax.servlet.ServletResponse;
+import javax.servlet.UnavailableException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
+import javax.servlet.http.HttpServletResponse;
 
 import cloud.piranha.webapp.api.CurrentRequestHolder;
 import cloud.piranha.webapp.api.FilterEnvironment;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplication.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplication.java
index 63433f9e..2783dad5 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplication.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplication.java
@@ -82,33 +82,33 @@ import java.util.logging.Logger;
 import java.util.stream.Collectors;
 import static java.util.stream.Collectors.toSet;
 import java.util.stream.Stream;
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.Filter;
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletContextAttributeEvent;
-import jakarta.servlet.ServletContextAttributeListener;
-import jakarta.servlet.ServletContextEvent;
-import jakarta.servlet.ServletContextListener;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.ServletRegistration.Dynamic;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletRequestAttributeListener;
-import jakarta.servlet.ServletRequestEvent;
-import jakarta.servlet.ServletRequestListener;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.SessionCookieConfig;
-import jakarta.servlet.SessionTrackingMode;
-import jakarta.servlet.UnavailableException;
-import jakarta.servlet.annotation.HandlesTypes;
-import jakarta.servlet.descriptor.JspConfigDescriptor;
-import jakarta.servlet.http.HttpSessionAttributeListener;
-import jakarta.servlet.http.HttpSessionIdListener;
-import jakarta.servlet.http.HttpSessionListener;
+import javax.servlet.DispatcherType;
+import javax.servlet.Filter;
+import javax.servlet.FilterRegistration;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.Servlet;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletContextAttributeEvent;
+import javax.servlet.ServletContextAttributeListener;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.ServletRegistration.Dynamic;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestAttributeListener;
+import javax.servlet.ServletRequestEvent;
+import javax.servlet.ServletRequestListener;
+import javax.servlet.ServletResponse;
+import javax.servlet.SessionCookieConfig;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.UnavailableException;
+import javax.servlet.annotation.HandlesTypes;
+import javax.servlet.descriptor.JspConfigDescriptor;
+import javax.servlet.http.HttpSessionAttributeListener;
+import javax.servlet.http.HttpSessionIdListener;
+import javax.servlet.http.HttpSessionListener;
 
 /**
  * The default WebApplication.
@@ -1653,7 +1653,7 @@ public class DefaultWebApplication implements WebApplication {
     }
 
     /**
-     * @see WebApplication#setDefaultServlet(jakarta.servlet.Servlet)
+     * @see WebApplication#setDefaultServlet(javax.servlet.Servlet)
      */
     @Override
     public void setDefaultServlet(Servlet defaultServlet) {
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequest.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequest.java
index a52b8bef..7a6ce5eb 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequest.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequest.java
@@ -29,8 +29,8 @@ package cloud.piranha.webapp.impl;
 
 import static cloud.piranha.webapp.impl.DefaultServletRequestDispatcher.PREVIOUS_REQUEST;
 import static java.util.Objects.requireNonNull;
-import static jakarta.servlet.DispatcherType.INCLUDE;
-import static jakarta.servlet.RequestDispatcher.INCLUDE_QUERY_STRING;
+import static javax.servlet.DispatcherType.INCLUDE;
+import static javax.servlet.RequestDispatcher.INCLUDE_QUERY_STRING;
 
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
@@ -55,21 +55,21 @@ import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 
-import jakarta.servlet.AsyncContext;
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.ReadListener;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletInputStream;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletRequestWrapper;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpUpgradeHandler;
-import jakarta.servlet.http.Part;
+import javax.servlet.AsyncContext;
+import javax.servlet.DispatcherType;
+import javax.servlet.ReadListener;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletRequestWrapper;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpUpgradeHandler;
+import javax.servlet.http.Part;
 
 import cloud.piranha.webapp.api.AttributeManager;
 import cloud.piranha.webapp.api.HttpHeaderManager;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequestMapper.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequestMapper.java
index 14ef078a..e5487cda 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequestMapper.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequestMapper.java
@@ -31,7 +31,7 @@ import static java.util.Arrays.stream;
 import static java.util.Collections.emptySet;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toSet;
-import static jakarta.servlet.DispatcherType.REQUEST;
+import static javax.servlet.DispatcherType.REQUEST;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -42,7 +42,7 @@ import java.util.List;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import jakarta.servlet.DispatcherType;
+import javax.servlet.DispatcherType;
 
 import cloud.piranha.webapp.api.FilterMapping;
 import cloud.piranha.webapp.api.WebApplicationRequestMapper;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationResponse.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationResponse.java
index 1b5bd650..c29f754e 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationResponse.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWebApplicationResponse.java
@@ -45,13 +45,13 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.RequestDispatcher;
-import jakarta.servlet.ServletOutputStream;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.WriteListener;
-import jakarta.servlet.http.Cookie;
-import jakarta.servlet.http.HttpServletRequest;
+import javax.servlet.DispatcherType;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.ServletRequest;
+import javax.servlet.WriteListener;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
 
 import cloud.piranha.webapp.api.LocaleEncodingManager;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWelcomeFileFilter.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWelcomeFileFilter.java
index d786f745..27c37772 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWelcomeFileFilter.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWelcomeFileFilter.java
@@ -29,11 +29,11 @@ package cloud.piranha.webapp.impl;
 
 import cloud.piranha.webapp.api.WebApplication;
 import java.io.IOException;
-import jakarta.servlet.Filter;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 /**
  * The default WelcomeFile filter.
diff --git a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWelcomeFileManager.java b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWelcomeFileManager.java
index 80d7a738..30808908 100644
--- a/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWelcomeFileManager.java
+++ b/webapp/impl/src/main/java/cloud/piranha/webapp/impl/DefaultWelcomeFileManager.java
@@ -31,10 +31,10 @@ import cloud.piranha.webapp.api.WelcomeFileManager;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 /**
  * The default WelcomeFileManager.
diff --git a/webapp/impl/src/main/java/module-info.java b/webapp/impl/src/main/java/module-info.java
index 536fe1df..6487c781 100644
--- a/webapp/impl/src/main/java/module-info.java
+++ b/webapp/impl/src/main/java/module-info.java
@@ -27,18 +27,18 @@
  */
 
 module cloud.piranha.webapp.impl {
-    
     exports cloud.piranha.webapp.impl;
-    
     opens cloud.piranha.webapp.impl;
-    
     requires cloud.piranha.naming.api;
     requires cloud.piranha.naming.impl;
     requires cloud.piranha.policy.api;
     requires cloud.piranha.policy.impl;
     requires cloud.piranha.resource.api;
     requires cloud.piranha.resource;
-    requires cloud.piranha.servlet.api;
-    requires cloud.piranha.webapp.api;
+    requires transitive cloud.piranha.servlet4.api;
+    requires transitive cloud.piranha.webapp.api;
     requires java.logging;
+
+    // Tests
+    requires static jdk.security.auth;
 }
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/AsyncContextTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/AsyncContextTest.java
similarity index 93%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/AsyncContextTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/AsyncContextTest.java
index 30339b44..4de4901c 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/AsyncContextTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/AsyncContextTest.java
@@ -25,12 +25,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
-import cloud.piranha.webapp.impl.DefaultAsyncContext;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequest;
-import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
 import org.junit.jupiter.api.Test;
 
 import java.io.ByteArrayOutputStream;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultAnnotationManagerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultAnnotationManagerTest.java
new file mode 100644
index 00000000..676f2627
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultAnnotationManagerTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the DefaultAnnotationManager class.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultAnnotationManagerTest {
+    
+    /**
+     * Test getClasses method.
+     */
+    @Test
+    void testGetClasses() {
+        DefaultAnnotationManager manager = new DefaultAnnotationManager();
+        assertNotNull(manager.getAnnotatedClasses());
+        assertTrue(manager.getAnnotatedClasses().isEmpty());
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultErrorPageManagerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultErrorPageManagerTest.java
new file mode 100644
index 00000000..65246e43
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultErrorPageManagerTest.java
@@ -0,0 +1,68 @@
+package cloud.piranha.webapp.impl;
+
+import org.junit.jupiter.api.Test;
+
+import javax.servlet.ServletException;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+class DefaultErrorPageManagerTest {
+    @Test
+    void testPagesByCode() {
+        DefaultErrorPageManager errorPageManager = new DefaultErrorPageManager();
+        errorPageManager.getErrorPagesByCode().put(501, "/501");
+        errorPageManager.getErrorPagesByCode().put(404, "/404");
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setStatus(501);
+        assertEquals("/501", errorPageManager.getErrorPage(null, response));
+        response.setStatus(404);
+        assertEquals("/404", errorPageManager.getErrorPage(null, response));
+    }
+
+    @Test
+    void testPagesByCode2() {
+        DefaultErrorPageManager errorPageManager = new DefaultErrorPageManager();
+        errorPageManager.getErrorPagesByCode().put(404, "/404");
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setStatus(501);
+        assertNull(errorPageManager.getErrorPage(null, response));
+    }
+
+    @Test
+    void testPagesByCode3() {
+        DefaultErrorPageManager errorPageManager = new DefaultErrorPageManager();
+        errorPageManager.getErrorPagesByCode().put(404, "/404");
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setStatus(500);
+        assertNull(errorPageManager.getErrorPage(new NullPointerException(), response));
+    }
+
+    @Test
+    void testPagesByException() {
+        DefaultErrorPageManager errorPageManager = new DefaultErrorPageManager();
+        errorPageManager.getErrorPagesByException().put(IllegalArgumentException.class.getName(), "/IAE");
+        assertEquals("/IAE", errorPageManager.getErrorPage(new IllegalArgumentException(), null));
+    }
+
+    @Test
+    void testPagesByException2() {
+        DefaultErrorPageManager errorPageManager = new DefaultErrorPageManager();
+        errorPageManager.getErrorPagesByException().put(IndexOutOfBoundsException.class.getName(), "/IOUB");
+        assertEquals("/IOUB", errorPageManager.getErrorPage(new ArrayIndexOutOfBoundsException(), null));
+    }
+
+    @Test
+    void testPagesByException3() {
+        DefaultErrorPageManager errorPageManager = new DefaultErrorPageManager();
+        errorPageManager.getErrorPagesByException().put(IllegalArgumentException.class.getName(), "/IAE");
+        assertEquals("/IAE", errorPageManager.getErrorPage(new ServletException(new IllegalArgumentException()), null));
+    }
+
+    @Test
+    void testPagesByException4() {
+        DefaultErrorPageManager errorPageManager = new DefaultErrorPageManager();
+        errorPageManager.getErrorPagesByException().put(IllegalArgumentException.class.getName(), "/IAE");
+        assertNull(errorPageManager.getErrorPage(new IndexOutOfBoundsException(), null));
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpHeaderManagerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpHeaderManagerTest.java
new file mode 100644
index 00000000..fafa677e
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpHeaderManagerTest.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Enumeration;
+import static org.junit.jupiter.api.Assertions.*;
+import org.junit.jupiter.api.Test;
+
+/**
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultHttpHeaderManagerTest {
+
+    /**
+     * Test addHeader method.
+     */
+    @Test
+    void testAddHeader() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        manager.addHeader("NAME", "VALUE");
+        assertEquals("VALUE", manager.getHeader("NAME"));
+    }
+
+    /**
+     * Test addHeader method.
+     */
+    @Test
+    void testAddHeader2() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        manager.addHeader("NAME", "VALUE");
+        manager.addHeader("NAME", "VALUE2");
+        assertEquals("VALUE", manager.getHeader("NAME"));
+        Enumeration<String> values = manager.getHeaders("NAME");
+        assertTrue(values.hasMoreElements());
+        assertNotNull(values.nextElement());
+        assertTrue(values.hasMoreElements());
+        assertNotNull(values.nextElement());
+        assertFalse(values.hasMoreElements());
+    }
+
+    /**
+     * Test containsHeader method.
+     */
+    @Test
+    void testContainsHeader() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        manager.addHeader("NAME", "VALUE");
+        assertEquals("VALUE", manager.getHeader("NAME"));
+        assertTrue(manager.containsHeader("NAME"));
+    }
+
+    /**
+     * Test getDateHeader method.
+     */
+    @Test
+    void testGetDateHeader() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        SimpleDateFormat format = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz");
+        manager.addHeader("NAME", format.format(new Date()));
+        assertTrue(manager.getDateHeader("NAME") > 0);
+    }
+
+    /**
+     * Test getDateHeader method.
+     */
+    @Test
+    void testGetDateHeader2() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        assertEquals(-1, manager.getDateHeader("NAME"));
+    }
+
+    /**
+     * Test getDateHeader method.
+     */
+    @Test
+    void testGetDateHeader3() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        manager.addHeader("NAME", "KABOOM");
+        assertThrows(IllegalArgumentException.class, () -> manager.getDateHeader("NAME"));
+    }
+
+    /**
+     * Test getHeader method.
+     */
+    @Test
+    void testGetHeader() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        assertNull(manager.getHeader("NAME"));
+    }
+
+    /**
+     * Test getDateHeader method.
+     */
+    @Test
+    void testGetHeaderNames() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        manager.addHeader("NAME", "VALUE");
+        Enumeration<String> names = manager.getHeaderNames();
+        assertTrue(names.hasMoreElements());
+        assertEquals("NAME", names.nextElement());
+    }
+
+    /**
+     * Test getHeaders method.
+     */
+    @Test
+    void testGetHeaders() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        assertNotNull(manager.getHeaders("NAME"));
+        assertFalse(manager.getHeaders("NAME").hasMoreElements());
+    }
+
+    /**
+     * Test getIntHeader method.
+     */
+    @Test
+    void testGetIntHeader() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        manager.addHeader("NAME", "1");
+        assertEquals(1, manager.getIntHeader("NAME"));
+    }
+
+    /**
+     * Test getIntHeader method.
+     */
+    @Test
+    void testGetIntHeader2() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        manager.setHeader("NAME", "abcd");
+        assertThrows(IllegalArgumentException.class, () -> assertEquals(1, manager.getIntHeader("NAME")));
+    }
+
+    /**
+     * Test getIntHeader method.
+     */
+    @Test
+    void testGetIntHeader3() {
+        DefaultHttpHeaderManager manager = new DefaultHttpHeaderManager();
+        assertEquals(-1, manager.getIntHeader("NAME"));
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpServletRequestTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpServletRequestTest.java
new file mode 100644
index 00000000..a20233d1
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpServletRequestTest.java
@@ -0,0 +1,612 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpUpgradeHandler;
+import javax.servlet.http.WebConnection;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the DefaultWebApplicationRequest class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultHttpServletRequestTest {
+
+    /**
+     * Test authenticate.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testAuthenticate() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setSecurityManager(new DefaultSecurityManager());
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        HttpServletResponse response = new TestWebApplicationResponse();
+        try {
+            request.authenticate(response);
+        } catch (IOException | ServletException exception) {
+        }
+    }
+
+    /**
+     * Test authenticate.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testAuthenticate2() throws Exception {
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setSecurityManager(securityManager);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        HttpServletResponse response = new TestWebApplicationResponse();
+        request.authenticate(response);
+    }
+
+    /**
+     * Test changeSessionId method.
+     */
+    @Test
+    void testChangeSessionId() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        webApp.linkRequestAndResponse(request, response);
+        request.setWebApplication(webApp);
+        assertThrows(IllegalStateException.class, () -> request.changeSessionId());
+    }
+
+    /**
+     * Test changeSessionId method.
+     */
+    @Test
+    void testChangeSessionId2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        webApp.linkRequestAndResponse(request, response);
+        request.setWebApplication(webApp);
+        HttpSession session = request.getSession(true);
+        request.setRequestedSessionId(session.getId());
+        request.changeSessionId();
+    }
+
+    /**
+     * Test getAsyncContext method.
+     */
+    @Test
+    void testGetAsyncContext() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertThrows(IllegalStateException.class, () -> request.getAsyncContext());
+    }
+
+    /**
+     * Test getAsyncContext method.
+     */
+    @Test
+    void testGetAsyncContext2() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        request.setWebApplication(webApplication);
+        response.setWebApplication(webApplication);
+        webApplication.linkRequestAndResponse(request, response);
+        request.setAsyncSupported(true);
+        request.startAsync();
+        assertNotNull(request.getAsyncContext());
+    }
+
+    /**
+     * Test getContentLengthLong method.
+     */
+    @Test
+    void testGetContentLengthLong() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertEquals(-1L, request.getContentLengthLong());
+    }
+
+    /**
+     * Test getDateHeader method.
+     */
+    @Test
+    void testGetDateHeader() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertEquals(-1L, request.getDateHeader("notfound"));
+    }
+
+    /**
+     * Test getIntHeader method.
+     */
+    @Test
+    void testGetIntHeader() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertEquals(-1, request.getIntHeader("notfound"));
+    }
+
+    /**
+     * Test getLocale method.
+     */
+    @Test
+    void testGetLocale() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setHeader("Accept-Language", "en");
+        assertNotNull(request.getLocale());
+    }
+
+    /**
+     * Test getLocale method.
+     */
+    @Test
+    void testGetLocales() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setHeader("Accept-Language", "en, de");
+        assertNotNull(request.getLocales());
+    }
+
+    /**
+     * Test getPart method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetPart() throws Exception {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setContentType("text/html");
+        assertThrows(ServletException.class, () -> request.getPart("not_there"));
+    }
+
+    /**
+     * Test getPart method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetPart2() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApplication);
+        request.setContentType("multipart/form-data");
+        assertNull(request.getPart("not_there"));
+    }
+
+    /**
+     * Test getRealPath method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetRealPath() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApplication);
+        assertThrows(UnsupportedOperationException.class, () -> request.getRealPath("/path"));
+    }
+
+    /**
+     * Test getRequestDispatcher method.
+     */
+    @Test
+    void testGetRequestDispatcher() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        request.setWebApplication(webApp);
+        request.getRequestDispatcher("/test");
+    }
+
+    /**
+     * Test getSession method.
+     */
+    @Test
+    void testGetSession() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.linkRequestAndResponse(request, response);
+        HttpSession session = request.getSession(true);
+        request.setRequestedSessionId(session.getId());
+        assertNotNull(request.getSession());
+    }
+
+    /**
+     * Test getSession method.
+     */
+    @Test
+    void testGetSession2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setWebApplication(webApp);
+        response.setWebApplication(webApp);
+        webApp.linkRequestAndResponse(request, response);
+        HttpSession session = request.getSession(true);
+        request.setRequestedSessionId(session.getId());
+        assertNotNull(request.getSession(false));
+    }
+
+    /**
+     * Test getSession method.
+     */
+    @Test
+    void testGetSession3() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setWebApplication(webApp);
+        response.setWebApplication(webApp);
+        webApp.linkRequestAndResponse(request, response);
+        HttpSession session = request.getSession(false);
+        assertNull(session);
+    }
+
+    /**
+     * Test getUpgradeHandler method.
+     */
+    @Test
+    void testGetUpgradeHandler() {
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest() {
+        };
+        assertNull(request.getUpgradeHandler());
+    }
+
+    /**
+     * Test setRequestedSessionIdFromURL method.
+     */
+    @Test
+    void testIsRequestedSessionIdFromUrl() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertFalse(request.isRequestedSessionIdFromUrl());
+    }
+
+    /**
+     * Test isRequestedSessionIdValid method.
+     */
+    @Test
+    void testIsRequestedSessionIdValid() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setWebApplication(webApp);
+        response.setWebApplication(webApp);
+        webApp.linkRequestAndResponse(request, response);
+        HttpSession session = request.getSession(true);
+        request.setRequestedSessionId(session.getId());
+        assertTrue(request.isRequestedSessionIdValid());
+    }
+
+    /**
+     * Test isSecure method.
+     */
+    @Test
+    void testIsSecure() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setScheme("https");
+        assertTrue(request.isSecure());
+    }
+
+    /**
+     * Test isUpgraded method.
+     */
+    @Test
+    void testIsUpgraded() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertFalse(request.isUpgraded());
+    }
+
+    /**
+     * Test isUserInRole method.
+     */
+    @Test
+    void testIsUserInRole() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        request.setWebApplication(webApplication);
+        assertFalse(request.isUserInRole("notmatched"));
+    }
+
+    /**
+     * Test login method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testLogin() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApplication);
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        securityManager.addUser("username", "password", new String[]{});
+        webApplication.setSecurityManager(securityManager);
+        request.login("username", "password");
+        assertNotNull(request.getUserPrincipal());
+    }
+
+    /**
+     * Test removeAttribute method.
+     */
+    @Test
+    void testRemoveAttribute() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        request.setWebApplication(webApplication);
+        request.setAttribute("name", "value");
+        assertNotNull(request.getAttribute("name"));
+        request.removeAttribute("name");
+        assertNull(request.getAttribute("name"));
+    }
+
+    /**
+     * Test setCharacterEncoding method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSetCharacterEncoding() throws Exception {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertNull(request.getCharacterEncoding());
+        request.setCharacterEncoding("UTF-8");
+        assertEquals("UTF-8", request.getCharacterEncoding());
+    }
+
+    /**
+     * Test setCookies method.
+     */
+    @Test
+    void testSetCookies() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertNull(request.getCookies());
+        request.setCookies(new Cookie[0]);
+        assertNull(request.getCookies());
+        Cookie[] cookies = new Cookie[1];
+        cookies[0] = new Cookie("name", "value");
+        request.setCookies(cookies);
+        assertNotNull(request.getCookies());
+        assertEquals("name", request.getCookies()[0].getName());
+        assertEquals("value", request.getCookies()[0].getValue());
+    }
+
+    /**
+     * Test setLocalAddr method.
+     */
+    @Test
+    void testSetLocalAddr() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertNull(request.getLocalAddr());
+        request.setLocalAddr("127.0.0.1");
+        assertEquals("127.0.0.1", request.getLocalAddr());
+    }
+
+    /**
+     * Test setLocalName method.
+     */
+    @Test
+    void testSetLocalName() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertNull(request.getLocalName());
+        request.setLocalName("localhost");
+        assertEquals("localhost", request.getLocalName());
+    }
+
+    /**
+     * Test setLocalPort method.
+     */
+    @Test
+    void testSetLocalPort() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertEquals(0, request.getLocalPort());
+        request.setLocalPort(12345);
+        assertEquals(12345, request.getLocalPort());
+    }
+
+    /**
+     * Test setProtocol method.
+     */
+    @Test
+    void testSetProtocol() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertEquals("HTTP/1.1", request.getProtocol());
+        request.setProtocol("HTTP/1.0");
+        assertEquals("HTTP/1.0", request.getProtocol());
+    }
+
+    /**
+     * Test setRemoteAddr method.
+     */
+    @Test
+    void testSetRemoteAddr() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertNull(request.getRemoteAddr());
+        request.setRemoteAddr("127.0.0.1");
+        assertEquals("127.0.0.1", request.getRemoteAddr());
+    }
+
+    /**
+     * Test setRemoteHost method.
+     */
+    @Test
+    void testSetRemoteHost() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertNull(request.getRemoteHost());
+        request.setRemoteHost("localhost");
+        assertEquals("localhost", request.getRemoteHost());
+    }
+
+    /**
+     * Test setRemotePort method.
+     */
+    @Test
+    void testSetRemotePort() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertEquals(0, request.getRemotePort());
+        request.setRemotePort(12345);
+        assertEquals(12345, request.getRemotePort());
+    }
+
+    /**
+     * Test setRequestedSessionIdFromCookie method.
+     */
+    @Test
+    void testSetRequestedSessionIdFromCookie() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertFalse(request.isRequestedSessionIdFromCookie());
+        request.setRequestedSessionIdFromCookie(true);
+        assertTrue(request.isRequestedSessionIdFromCookie());
+    }
+
+    /**
+     * Test setRequestedSessionIdFromURL method.
+     */
+    @Test
+    void testSetRequestedSessionIdFromURL() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertFalse(request.isRequestedSessionIdFromURL());
+        request.setRequestedSessionIdFromURL(true);
+        assertTrue(request.isRequestedSessionIdFromURL());
+    }
+
+    /**
+     * Test setServerName method.
+     */
+    @Test
+    void testSetServerName() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertEquals("localhost", request.getServerName());
+        request.setServerName("my.host.com");
+        assertEquals("my.host.com", request.getServerName());
+    }
+
+    /**
+     * Test setServerPort method.
+     */
+    @Test
+    void testSetServerPort() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertEquals(80, request.getServerPort());
+        request.setServerPort(8080);
+        assertEquals(8080, request.getServerPort());
+    }
+
+    /**
+     * Test startAsync method.
+     */
+    @Test
+    void testStartAsync() {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setAttribute("piranha.response", response);
+        request.setAsyncSupported(false);
+        assertThrows(IllegalStateException.class, () -> request.startAsync(request, response));
+    }
+
+    /**
+     * Test startAsync method.
+     */
+    @Test
+    void testStartAsync2() {
+        assertThrows(IllegalStateException.class, () -> {
+            try {
+                DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+                request.setAttribute("piranha.response", new TestWebApplicationResponse());
+                request.setAsyncSupported(false);
+                request.startAsync();
+            } catch (Exception e) {
+                e.printStackTrace();
+                throw e;
+            }
+        });
+    }
+
+    /**
+     * Test upgrade method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testUpgrade() throws Exception {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertNotNull(request.upgrade(TestHandler.class));
+    }
+
+    /**
+     * Test upgrade method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testUpgrade2() throws Exception {
+        DefaultWebApplicationRequest request = new TestWebApplicationRequest();
+        assertThrows(ServletException.class, () -> request.upgrade(TestThrowingHandler.class));
+    }
+
+    static class TestHandler implements HttpUpgradeHandler {
+
+        @Override
+        public void init(WebConnection wc) {
+        }
+
+        @Override
+        public void destroy() {
+        }
+    }
+
+    static class TestThrowingHandler implements HttpUpgradeHandler {
+
+        TestThrowingHandler() throws IllegalAccessException {
+            throw new IllegalAccessException();
+        }
+
+        @Override
+        public void init(WebConnection wc) {
+        }
+
+        @Override
+        public void destroy() {
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpServletResponseTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpServletResponseTest.java
new file mode 100644
index 00000000..efcee4c1
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpServletResponseTest.java
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import javax.servlet.http.HttpServletResponse;
+import java.util.Locale;
+
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * The JUnit tests for the DefaultWebApplicationResponse class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultHttpServletResponseTest {
+
+    /**
+     * Test addDateHeader method.
+     */
+    @Test
+    void testAddDateHeader() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.addDateHeader("name", 1234);
+        assertEquals("Thu, 1 Jan 1970 00:00:01 GMT", response.getHeader("name"));
+    }
+
+    /**
+     * Test addIntHeader method.
+     */
+    @Test
+    void testAddIntHeader() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.addIntHeader("name", 1234);
+        assertEquals("1234", response.getHeader("name"));
+    }
+
+    /**
+     * Test containsHeader method.
+     */
+    @Test
+    void testContainsHeader() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        assertFalse(response.containsHeader("name"));
+        response.addHeader("name", "value");
+        assertTrue(response.containsHeader("name"));
+    }
+
+    /**
+     * Test encodeRedirectUrl method.
+     */
+    @Test
+    void testEncodeRedirectUrl() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        assertNotNull(response.encodeRedirectURL("/encodeMe"));
+    }
+
+    /**
+     * Test encodeRedirectUrl method.
+     */
+    @Test
+    void testEncodeRedirectUrl2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        assertNotNull(response.encodeRedirectUrl("/encodeMe"));
+    }
+
+    /**
+     * Test encodeUrl method.
+     */
+    @Test
+    void testEncodeUrl() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        assertNotNull(response.encodeURL("/encodeMe"));
+    }
+
+    /**
+     * Test encodeUrl method.
+     */
+    @Test
+    void testEncodeUrl2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        assertNotNull(response.encodeUrl("/encodeMe"));
+    }
+
+    /**
+     * Test flushBuffer method.
+     *
+     * @throws Exception when an error occurs.
+     */
+    @Test
+    void testFlushBuffer() throws Exception {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.flushBuffer();
+    }
+
+    /**
+     * Test getCharacterEncoding method.
+     */
+    @Test
+    void testGetCharacterEncoding() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        assertEquals("ISO-8859-1", response.getCharacterEncoding());
+        response.setCharacterEncoding("UTF-8");
+        assertEquals("UTF-8", response.getCharacterEncoding());
+    }
+
+    /**
+     * Test getContentType method.
+     */
+    @Test
+    void testGetContentType() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        assertNull(response.getContentType());
+        response.setContentType("text/html");
+        assertEquals("text/html", response.getContentType());
+    }
+
+    /**
+     * Test getContentType method.
+     */
+    @Test
+    void testGetContentType2() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        assertNull(response.getContentType());
+        response.setContentType("text/html;charset=UTF-8");
+        assertEquals("text/html;charset=UTF-8", response.getContentType());
+        assertEquals("UTF-8", response.getCharacterEncoding());
+    }
+
+    /**
+     * Test getHeaderNames method.
+     */
+    @Test
+    void testGetHeaderNames() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        assertNotNull(response.getHeaderNames());
+        assertTrue(response.getHeaderNames().isEmpty());
+        response.addHeader("name", "value");
+        assertFalse(response.getHeaderNames().isEmpty());
+    }
+
+    /**
+     * Test getHeaders method.
+     */
+    @Test
+    void testGetHeaders() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        assertNotNull(response.getHeaders("name"));
+        assertTrue(response.getHeaders("name").isEmpty());
+        response.addHeader("name", "value");
+        assertFalse(response.getHeaders("name").isEmpty());
+    }
+
+    /**
+     * Test getLocale method.
+     */
+    @Test
+    void testGetLocale() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        assertEquals(Locale.getDefault(), response.getLocale());
+        response.setLocale(Locale.ITALIAN);
+        assertEquals(Locale.ITALIAN, response.getLocale());
+    }
+
+    /**
+     * Test getOutputStream method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetOutputStream() throws Exception {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.getWriter();
+        assertThrows(IllegalStateException.class, () -> response.getOutputStream());
+    }
+
+    /**
+     * Test getWebApplication method.
+     */
+    @Test
+    void testGetWebApplication() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        assertNull(response.getWebApplication());
+    }
+
+    /**
+     * Test getWriter method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetWriter() throws Exception {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.getOutputStream();
+        assertThrows(IllegalStateException.class, () -> response.getWriter());
+    }
+
+    /**
+     * Test reset method.
+     */
+    @Test
+    void testReset() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.reset();
+        assertEquals(200, response.getStatus());
+    }
+
+    /**
+     * Test sendError method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSendError() throws Exception {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "error");
+        response.flushBuffer();
+        assertEquals(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, response.getStatus());
+        assertEquals("error", response.getStatusMessage());
+        assertTrue(response.isCommitted());
+    }
+
+    /**
+     * Test sendError method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSendError2() throws Exception {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "error");
+        response.flushBuffer();
+        assertThrows(IllegalStateException.class, () -> response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));
+    }
+
+    /**
+     * Test setContentLength method.
+     */
+    @Test
+    void testSetContentLength() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setContentLength(12);
+        assertEquals(12, response.getContentLength());
+    }
+
+    /**
+     * Test setContentLength method.
+     */
+    @Test
+    void testSetContentLength2() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setContentLengthLong(12L);
+        assertEquals(12, response.getContentLength());
+    }
+
+    @Test
+    void testSetContentLength3() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setContentLength(12);
+        assertEquals("12", response.getHeader("Content-Length"));
+    }
+
+    @Test
+    void testSetContentLength4() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setContentLengthLong(12L);
+        assertEquals("12", response.getHeader("Content-Length"));
+    }
+
+    /**
+     * Test setContentType.
+     */
+    @Test
+    void testSetContentType() {
+        DefaultWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setContentType(null);
+        assertNull(response.getContentType());
+    }
+
+    @Test
+    void testContentTypeHeader() throws Exception {
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setContentType("text/html");
+        assertEquals("text/html", response.getContentType());
+        assertEquals("ISO-8859-1", response.getCharacterEncoding());
+
+        response.setBodyOnly(false);
+        response.flushBuffer();
+
+        assertTrue(new String(response.getResponseBytes()).contains("Content-Type: text/html;charset=ISO-8859-1"));
+    }
+
+    @Test
+    void testContentTypeHeader2() throws Exception {
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setContentType("text/html;charset=UTF-8");
+        assertEquals("text/html;charset=UTF-8", response.getContentType());
+        assertEquals("UTF-8", response.getCharacterEncoding());
+
+        response.setBodyOnly(false);
+        response.flushBuffer();
+
+        assertTrue(new String(response.getResponseBytes()).contains("Content-Type: text/html;charset=UTF-8\n"));
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpSessionManagerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpSessionManagerTest.java
new file mode 100644
index 00000000..9a771e08
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpSessionManagerTest.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpSession;
+import static org.junit.jupiter.api.Assertions.*;
+import org.junit.jupiter.api.Test;
+
+import java.util.EnumSet;
+
+/**
+ * The JUnit tests for the DefaultHttpSessionManager class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultHttpSessionManagerTest {
+
+    /**
+     * Test createSession method.
+     */
+    @Test
+    void testCreateSession() {
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(NullPointerException.class, () -> sessionManager.createSession(null));
+    }
+
+    /**
+     * Test getComment method.
+     */
+    @Test
+    void testGetComment() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        sessionManager.setComment("COMMENT");
+        assertEquals("COMMENT", sessionManager.getComment());
+    }
+
+    /**
+     * Test getDomain method.
+     */
+    @Test
+    void testGetDomain() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        sessionManager.setDomain("domain");
+        assertEquals("domain", sessionManager.getDomain());
+    }
+
+    /**
+     * Test getMaxAge method.
+     */
+    @Test
+    void testGetMaxAge() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        assertEquals(-1, sessionManager.getMaxAge());
+        sessionManager.setMaxAge(60);
+        assertEquals(60, sessionManager.getMaxAge());
+    }
+
+    /**
+     * Test getName method.
+     */
+    @Test
+    void testGetName() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        sessionManager.setName("JSESSIONID");
+        assertEquals("JSESSIONID", sessionManager.getName());
+    }
+
+    /**
+     * Test getPath method.
+     */
+    @Test
+    void testGetPath() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        sessionManager.setPath("/");
+        assertEquals("/", sessionManager.getPath());
+    }
+
+    /**
+     * Test getSession method.
+     */
+    @Test
+    void testGetSession() {
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(NullPointerException.class, () -> sessionManager.getSession(null, null));
+    }
+
+    /**
+     * Test getSession method.
+     */
+    @Test
+    void testGetSession2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApp);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        webApp.linkRequestAndResponse(request, response);
+        HttpSession session = sessionManager.createSession(request);
+        request.setRequestedSessionId(session.getId());
+        assertNotNull(sessionManager.getSession(request, session.getId()));
+    }
+
+    /**
+     * Test getSessionCookieConfig method.
+     */
+    @Test
+    void testGetSessionCookieConfig() {
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        assertNotNull(sessionManager.getSessionCookieConfig());
+    }
+
+    /**
+     * Test getSessionTimeout method.
+     */
+    @Test
+    void testGetSessionTimeout() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        assertEquals(10, sessionManager.getSessionTimeout());
+        sessionManager.setSessionTimeout(5);
+        assertEquals(5, sessionManager.getSessionTimeout());
+    }
+
+    /**
+     * Test isHttpOnly method.
+     */
+    @Test
+    void testIsHttpOnly() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        assertFalse(sessionManager.isHttpOnly());
+        sessionManager.setHttpOnly(true);
+        assertTrue(sessionManager.isHttpOnly());
+    }
+
+    /**
+     * Test isSecure method.
+     */
+    @Test
+    void testIsSecure() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApplication);
+        assertFalse(sessionManager.isSecure());
+        sessionManager.setSecure(true);
+        assertTrue(sessionManager.isSecure());
+    }
+
+    /**
+     * Test encodeRedirectUrl method.
+     */
+    @Test
+    void testEncodeRedirectURL() {
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        assertEquals("test", sessionManager.encodeRedirectURL(null, "test"));
+    }
+
+    /**
+     * Test encodeURL method.
+     */
+    @Test
+    void testEncodeURL() {
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        assertEquals("test", sessionManager.encodeURL(null, "test"));
+    }
+
+    @Test
+    void testEffectiveSessionTracking() {
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        assertEquals(sessionManager.getDefaultSessionTrackingModes(), sessionManager.getEffectiveSessionTrackingModes());
+    }
+
+    @Test
+    void testSetSSLTrackingModeWithOtherMethod() {
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        EnumSet<SessionTrackingMode> sslAndUrl = EnumSet.of(SessionTrackingMode.SSL, SessionTrackingMode.URL);
+        assertThrows(IllegalArgumentException.class, () -> sessionManager.setSessionTrackingModes(sslAndUrl));
+        EnumSet<SessionTrackingMode> sslAndCookie = EnumSet.of(SessionTrackingMode.COOKIE, SessionTrackingMode.SSL);
+        assertThrows(IllegalArgumentException.class, () -> sessionManager.setSessionTrackingModes(sslAndCookie));
+    }
+
+    @Test
+    void testSetCookieAttributes() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultHttpSessionManager sessionManager = new DefaultHttpSessionManager();
+        sessionManager.setWebApplication(webApp);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        webApp.linkRequestAndResponse(request, response);
+
+        sessionManager.setComment("Comment");
+        sessionManager.setDomain("SessionCookie");
+        sessionManager.setHttpOnly(true);
+        sessionManager.setName("SessionCookie");
+        sessionManager.setMaxAge(100);
+        sessionManager.setPath("/context");
+        sessionManager.setSecure(true);
+
+        sessionManager.createSession(request);
+
+        Cookie sessionCookie = response.getCookies().stream().filter(cookie -> "SessionCookie".equals(cookie.getName())).findFirst().orElse(null);
+        assertNotNull(sessionCookie);
+
+        assertEquals(sessionManager.getComment(), sessionCookie.getComment());
+        assertEquals(sessionManager.getDomain(), sessionCookie.getDomain());
+        assertTrue(sessionCookie.isHttpOnly());
+        assertEquals(sessionManager.getMaxAge(), sessionCookie.getMaxAge());
+        assertEquals(sessionManager.getPath(), sessionCookie.getPath());
+        assertTrue(sessionCookie.getSecure());
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpSessionTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpSessionTest.java
similarity index 97%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpSessionTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpSessionTest.java
index fe258f49..f547be34 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultHttpSessionTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultHttpSessionTest.java
@@ -25,11 +25,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
-import cloud.piranha.webapp.impl.DefaultHttpSession;
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 import static org.junit.jupiter.api.Assertions.*;
 import org.junit.jupiter.api.Test;
 
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultMultiPartManagerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultMultiPartManagerTest.java
new file mode 100644
index 00000000..81558fe8
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultMultiPartManagerTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.util.Collection;
+import javax.servlet.http.Part;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the DefaultMultiPartManager.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultMultiPartManagerTest {
+
+    /**
+     * Test getParts method.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetParts() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultMultiPartManager manager = new DefaultMultiPartManager();
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest() {
+        };
+        request.setContentType("multipart/form-data; boundary=------------------------12345");
+        Collection<Part> result = manager.getParts(webApplication, request);
+        assertTrue(result.isEmpty());
+    }
+
+    /**
+     * Test getPart method.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetPart() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        DefaultMultiPartManager manager = new DefaultMultiPartManager();
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest() {
+        };
+        request.setContentType("multipart/form-data; boundary=------------------------12345");
+        assertNull(manager.getPart(webApplication, request, "notfound"));
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultSecurityManagerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultSecurityManagerTest.java
new file mode 100644
index 00000000..3c45e0cd
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultSecurityManagerTest.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import com.sun.security.auth.UserPrincipal;
+import java.io.IOException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
+
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * The JUnit tests for the SecurityManagerImpl class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultSecurityManagerTest {
+
+    /**
+     * Test addUser method.
+     */
+    @Test
+    void testAddUser() {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setUserPrincipal(new UserPrincipal("username"));
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        securityManager.addUser("username", "password", new String[]{"role1", "role2"});
+        assertTrue(securityManager.isUserInRole(request, "role1"));
+    }
+
+    /**
+     * Test authenticate method.
+     *
+     * @throws ServletException because BASIC authentication is not supported.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Test
+    void testAuthenticate() throws ServletException, IOException {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setAuthType(HttpServletRequest.BASIC_AUTH);
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        assertThrows(ServletException.class, () -> assertFalse(securityManager.authenticate(request, response)));
+    }
+
+    /**
+     * Test authenticate method.
+     *
+     * @throws ServletException because CLIENT_CERT_AUTH authentication is not
+     * supported.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Test
+    void testAuthenticate2() throws ServletException, IOException {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setAuthType(HttpServletRequest.CLIENT_CERT_AUTH);
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        assertThrows(ServletException.class, () -> assertFalse(securityManager.authenticate(request, response)));
+    }
+
+    /**
+     * Test authenticate method.
+     *
+     * @throws ServletException because DIGEST_AUTH authentication is not
+     * supported.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Test
+    void testAuthenticate3() throws ServletException, IOException {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setAuthType(HttpServletRequest.DIGEST_AUTH);
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        assertThrows(ServletException.class, () -> assertFalse(securityManager.authenticate(request, response)));
+    }
+
+    /**
+     * Test authenticate method.
+     *
+     * @throws ServletException because DIGEST_AUTH authentication is not
+     * supported.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Test
+    void testAuthenticate4() throws ServletException, IOException {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setAuthType(HttpServletRequest.FORM_AUTH);
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        assertThrows(ServletException.class, () -> assertFalse(securityManager.authenticate(request, response)));
+    }
+
+    /**
+     * Test authenticate method.
+     *
+     * @throws ServletException when a servlet error occurs.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Test
+    void testAuthenticate5() throws ServletException, IOException {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setParameter("j_username", new String[]{"username"});
+        request.setParameter("j_password", new String[]{"password"});
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setAuthType(HttpServletRequest.FORM_AUTH);
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        securityManager.addUser("username", "password", new String[]{"role1"});
+        assertTrue(securityManager.authenticate(request, response));
+    }
+
+    /**
+     * Test authenticate method.
+     *
+     * @throws ServletException when a servlet error occurs.
+     * @throws IOException when an I/O error occurs.
+     */
+    @Test
+    void testAuthenticate6() throws ServletException, IOException {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setParameter("j_username", new String[]{"username"});
+        request.setParameter("j_password", new String[]{"password"});
+        HttpServletRequestWrapper wrappedRequest = new HttpServletRequestWrapper(request);
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        request.setAuthType(HttpServletRequest.FORM_AUTH);
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        securityManager.addUser("username", "password", new String[]{"role1"});
+        assertTrue(securityManager.authenticate(wrappedRequest, response));
+    }
+
+    /**
+     * Test login method.
+     *
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Test
+    void testLogin() throws ServletException {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        webApp.linkRequestAndResponse(request, response);
+        securityManager.setWebApplication(webApp);
+        securityManager.addUser("username", "password", new String[]{"role1", "role2"});
+        securityManager.login(request, "username", "password");
+    }
+
+    /**
+     * Test removeUser method.
+     */
+    @Test
+    void testRemoveUser() {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setUserPrincipal(new UserPrincipal("username"));
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        securityManager.addUser("username", "password", new String[]{"role1", "role2"});
+        assertTrue(securityManager.isUserInRole(request, "role1"));
+        securityManager.removeUser("username");
+        assertFalse(securityManager.isUserInRole(request, "role1"));
+    }
+
+    /**
+     * Test getWebApplication method.
+     */
+    @Test
+    void testGetWebApplication() {
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        assertNull(securityManager.getWebApplication());
+    }
+
+    /**
+     * Test getWebApplication method.
+     */
+    @Test
+    void testGetWebApplication2() {
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        securityManager.setWebApplication(new DefaultWebApplication());
+        assertNotNull(securityManager.getWebApplication());
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultSecurityPrincipalTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultSecurityPrincipalTest.java
new file mode 100644
index 00000000..64458057
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultSecurityPrincipalTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * The JUnit tests for the DefaultSecurityPrincipal class.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultSecurityPrincipalTest {
+
+    /**
+     * Test getName method.
+     */
+    @Test
+    void testGetName() {
+        DefaultSecurityPrincipal principal = new DefaultSecurityPrincipal("user");
+        assertEquals("user", principal.getName());
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultServletEnvironmentTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultServletEnvironmentTest.java
new file mode 100644
index 00000000..d3d763b4
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultServletEnvironmentTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import javax.servlet.MultipartConfigElement;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the DefaultServletEnvironment class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com).
+ */
+class DefaultServletEnvironmentTest {
+
+    /**
+     * Test getLoadOnStartup method.
+     */
+    @Test
+    void testGetLoadOnStartup() {
+        TestSnoopServlet servlet = new TestSnoopServlet();
+        DefaultServletEnvironment environment = new DefaultServletEnvironment(null, null, servlet);
+        environment.setLoadOnStartup(1);
+        assertEquals(1, environment.getLoadOnStartup());
+    }
+
+    /**
+     * Test setAsyncSupported method.
+     */
+    @Test
+    void testSetAsyncSupported() {
+        TestSnoopServlet servlet = new TestSnoopServlet();
+        DefaultServletEnvironment environment = new DefaultServletEnvironment(null, null, servlet);
+        assertFalse(environment.isAsyncSupported());
+        environment.setAsyncSupported(true);
+        assertTrue(environment.isAsyncSupported());
+    }
+
+    /**
+     * Test setMultipartConfig method.
+     */
+    @Test
+    void testMultipartConfig() {
+        TestSnoopServlet servlet = new TestSnoopServlet();
+        DefaultServletEnvironment environment = new DefaultServletEnvironment(null, null, servlet);
+        assertNull(environment.getMultipartConfig());
+        environment.setMultipartConfig(new MultipartConfigElement("/location"));
+        assertNotNull(environment.getMultipartConfig());
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultServletRequestDispatcherTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultServletRequestDispatcherTest.java
new file mode 100644
index 00000000..ce3e6b72
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultServletRequestDispatcherTest.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletException;
+import javax.servlet.UnavailableException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * The JUnit tests for DefaultServletRequestDispatcher.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultServletRequestDispatcherTest {
+
+    /**
+     * Test forward method.
+     *
+     * @throws Exception when an error occurs.
+     */
+    @Test
+    void testForward() throws Exception {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("Snoop", TestSnoopServlet.class);
+        webApp.initialize();
+        webApp.start();
+        RequestDispatcher dispatcher = webApp.getNamedDispatcher("Snoop");
+        dispatcher.forward(request, response);
+        String responseText = new String(response.getResponseBytes());
+        webApp.stop();
+        assertTrue(responseText.contains("<title>Snoop</title>"));
+    }
+
+    /**
+     * Test forward method.
+     *
+     * @throws Exception when an error occurs.
+     */
+    @Test
+    void testForward2() throws Exception {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(new DefaultWebApplicationRequestMapper());
+        webApp.addServlet("Snoop", TestSnoopServlet.class);
+        webApp.addServletMapping("Snoop", "/Snoop");
+        webApp.initialize();
+        webApp.start();
+        RequestDispatcher dispatcher = webApp.getRequestDispatcher("/Snoop");
+        dispatcher.forward(request, response);
+        String responseText = new String(response.getResponseBytes());
+        webApp.stop();
+        assertTrue(responseText.contains("<title>Snoop</title>"));
+    }
+
+    /**
+     * Test forward method.
+     *
+     * @throws Exception when an error occurs.
+     */
+    @Test
+    void testForward3() throws Exception {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(new DefaultWebApplicationRequestMapper());
+        webApp.addServlet("Error", TestIOExceptionServlet.class);
+        webApp.addServletMapping("Error", "/Error");
+        webApp.initialize();
+        webApp.start();
+        RequestDispatcher dispatcher = webApp.getRequestDispatcher("/Error");
+        assertThrows(IOException.class, () -> dispatcher.forward(request, response));
+    }
+
+    /**
+     * Test forward method.
+     *
+     * @throws Exception when an error occurs.
+     */
+    @Test
+    void testForward4() throws Exception {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(new DefaultWebApplicationRequestMapper());
+        webApp.addServlet("Runtime", TestRuntimeExceptionServlet.class);
+        webApp.addServletMapping("Runtime", "/Runtime");
+        webApp.initialize();
+        webApp.start();
+        RequestDispatcher dispatcher = webApp.getRequestDispatcher("/Runtime");
+        assertThrows(RuntimeException.class, () -> dispatcher.forward(request, response));
+    }
+
+    /**
+     * Test include method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testInclude() throws Exception {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("Echo", TestEcho1Servlet.class);
+        webApp.initialize();
+        webApp.start();
+        webApp.linkRequestAndResponse(request, response);
+        RequestDispatcher dispatcher = webApp.getNamedDispatcher("Echo");
+        dispatcher.include(request, response);
+        response.flushBuffer();
+        String responseText = new String(response.getResponseBytes());
+        webApp.unlinkRequestAndResponse(request, response);
+        webApp.stop();
+        assertTrue(responseText.contains("ECHO"));
+    }
+
+    /**
+     * Test include method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testInclude2() throws Exception {
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("Echo2", TestEcho2Servlet.class);
+        webApp.initialize();
+        webApp.start();
+        webApp.linkRequestAndResponse(request, response);
+        RequestDispatcher dispatcher = webApp.getNamedDispatcher("Echo2");
+        dispatcher.include(request, response);
+        response.flushBuffer();
+        String responseText = new String(response.getResponseBytes());
+        webApp.unlinkRequestAndResponse(request, response);
+        webApp.stop();
+        assertTrue(responseText.contains("ECHO"));
+    }
+
+    @Test
+    void testErrorDispatcher() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("error-servlet", new TestSendError());
+        webApp.addServletMapping("error-servlet", "/sendError");
+        webApp.addServlet("snoop", TestSnoopServlet.class);
+        webApp.addServletMapping("snoop", "/snoop");
+        webApp.addErrorPage(500, "/snoop");
+        webApp.initialize();
+        webApp.start();
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setServletPath("/sendError");
+        request.setParameter("send-error", new String[]{"true"});
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.service(request, response);
+        String responseText = new String(response.getResponseBytes());
+        webApp.stop();
+        assertTrue(responseText.contains(RequestDispatcher.ERROR_MESSAGE));
+        assertTrue(responseText.contains("some-internal-error"));
+    }
+
+    @Test
+    void testErrorDispatcher2() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("error-servlet", new TestSendError());
+        webApp.addServletMapping("error-servlet", "/sendError");
+        webApp.addServlet("snoop", TestSnoopServlet.class);
+        webApp.addServletMapping("snoop", "/snoop");
+        webApp.addErrorPage(404, "/snoop");
+        webApp.initialize();
+        webApp.start();
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setServletPath("/sendError");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.service(request, response);
+        String responseText = new String(response.getResponseBytes());
+        webApp.stop();
+        assertEquals(404, response.getStatus());
+        assertTrue(responseText.contains(RequestDispatcher.ERROR_MESSAGE));
+        assertTrue(responseText.contains("unavailable"));
+    }
+    @Test
+    void testErrorDispatcher3() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("error-servlet", TestIOExceptionServlet.class);
+        webApp.addServletMapping("error-servlet", "/sendError");
+        webApp.addServlet("snoop", TestSnoopServlet.class);
+        webApp.addServletMapping("snoop", "/snoop");
+        webApp.addErrorPage(IOException.class.getName(), "/snoop");
+        webApp.initialize();
+        webApp.start();
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setServletPath("/sendError");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.service(request, response);
+        String responseText = new String(response.getResponseBytes());
+        webApp.stop();
+        assertEquals(500, response.getStatus());
+        assertTrue(responseText.contains(RequestDispatcher.ERROR_EXCEPTION_TYPE));
+        assertTrue(responseText.contains(IOException.class.getName()));
+    }
+
+    static class TestSendError extends HttpServlet {
+        @Override
+        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            if (request.getParameter("send-error") != null) {
+                response.sendError(500, "some-internal-error");
+                return;
+            }
+            throw new UnavailableException("unavailable");
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationClassLoaderTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationClassLoaderTest.java
new file mode 100644
index 00000000..e0778510
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationClassLoaderTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the DefaultWebApplicationClassLoader.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultWebApplicationClassLoaderTest {
+
+    /**
+     * Test loadClass method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testLoadClass() throws Exception {
+        DefaultWebApplicationClassLoader classLoader = new DefaultWebApplicationClassLoader();
+        assertNotNull(classLoader.loadClass("java.lang.String", true));
+    }
+
+    /**
+     * Test loadClass method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testLoadClass2() throws Exception {
+        DefaultWebApplicationClassLoader classLoader = new DefaultWebApplicationClassLoader();
+        assertThrows(ClassNotFoundException.class, () -> classLoader.loadClass("this.is.a.bogus.className", true));
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationExtensionContextTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationExtensionContextTest.java
similarity index 86%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationExtensionContextTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationExtensionContextTest.java
index bb6f1afe..c9d97a46 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationExtensionContextTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationExtensionContextTest.java
@@ -25,24 +25,22 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertNull;
 
 import java.util.Set;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.api.WebApplicationExtension;
 import cloud.piranha.webapp.api.WebApplicationExtensionContext;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationExtensionContext;
 
 /**
  * The JUnit tests for the DefaultWebApplicationExtensionContext.
@@ -80,8 +78,13 @@ class DefaultWebApplicationExtensionContextTest {
     /**
      * A test extension.
      */
-    public static class TestExtension implements WebApplicationExtension {
+    static class TestExtension implements WebApplicationExtension {
 
+        /**
+         * Configure the web application.
+         *
+         * @param webApplication the web application.
+         */
         @Override
         public void configure(WebApplication webApplication) {
             webApplication.addInitializer(TestInitializer.class.getName());
@@ -124,11 +127,15 @@ class DefaultWebApplicationExtensionContextTest {
     /**
      * A test servlet container initializer.
      */
-    public static class TestInitializer implements ServletContainerInitializer {
-
-        public TestInitializer() {
-        }
+    static class TestInitializer implements ServletContainerInitializer {
 
+        /**
+         * On startup.
+         *
+         * @param classes the list of annotated classes.
+         * @param servletContext the Servlet context.
+         * @throws ServletException when a Servlet error occurs.
+         */
         @Override
         public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
             servletContext.setAttribute(TestInitializer.class.getName(), true);
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationRequestMapperTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequestMapperTest.java
similarity index 98%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationRequestMapperTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequestMapperTest.java
index 0776710c..93f88c00 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/DefaultWebApplicationRequestMapperTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationRequestMapperTest.java
@@ -25,11 +25,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequestMapper;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequestMapping;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationTest.java
new file mode 100644
index 00000000..47e33a2d
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/DefaultWebApplicationTest.java
@@ -0,0 +1,1123 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.PrintWriter;
+import java.util.Date;
+import java.util.EnumSet;
+import java.util.Enumeration;
+import java.util.Locale;
+import java.util.Set;
+
+import javax.servlet.DispatcherType;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.ServletRegistration.Dynamic;
+import javax.servlet.ServletRequestEvent;
+import javax.servlet.ServletRequestListener;
+import javax.servlet.SessionTrackingMode;
+import javax.servlet.http.HttpServletRequest;
+
+import org.junit.jupiter.api.Test;
+
+import cloud.piranha.resource.DefaultResourceManager;
+import cloud.piranha.resource.DirectoryResource;
+
+/**
+ * The JUnit tests for the DefaultWebApplication class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class DefaultWebApplicationTest {
+
+    /**
+     * Test addJspFile method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddJspFile() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNull(webApp.addJspFile("MyJspFile", "myjspfile.jsp"));
+    }
+
+    /**
+     * Test addJspFile method
+     */
+    @Test
+    void testAddJspFile2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.initialize();
+        webApp.start();
+        assertThrows(IllegalStateException.class, () -> webApp.addJspFile("MyJspFile", "myjspfile.jsp"));
+    }
+
+    /**
+     * Test addMapping method (verify the # of mappings > 0).
+     */
+    @Test
+    void testAddMapping() {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        ServletRegistration.Dynamic dynamic
+                = webApp.addServlet("echo", "servlet.EchoServlet");
+        assertNotNull(dynamic);
+        dynamic.addMapping("/echo");
+        assertTrue(dynamic.getMappings().size() > 0);
+    }
+
+    /**
+     * Test addMapping method (verify when we add twice addMapping will return a empty set).
+     */
+    @Test
+    void testAddMapping2() {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        ServletRegistration.Dynamic dynamic = webApp.addServlet("echo", "servlet.EchoServlet");
+        assertNotNull(dynamic);
+        dynamic.addMapping("/echo");
+        assertTrue(dynamic.getMappings().size() > 0);
+        assertTrue(dynamic.addMapping("/echo").size() == 0);
+    }
+
+    /**
+     * Test addResource method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testAddResource() throws Exception {
+        DefaultResourceManager resourceManager = new DefaultResourceManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setResourceManager(resourceManager);
+        webApp.addResource(new DirectoryResource(new File(".")));
+        assertNotNull(webApp.getResource("/src/main/java"));
+    }
+
+    /**
+     * Test declareRoles method.
+     */
+    @Test
+    void testDeclareRoles() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setSecurityManager(new DefaultSecurityManager());
+        webApp.declareRoles(new String[]{"ADMIN", "USER"});
+    }
+
+    /**
+     * Test destroy method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testDestroy() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addListener(new TestWebApplicationDestroyListener());
+        webApp.initialize();
+        webApp.destroy();
+        assertNotNull(webApp.getAttribute("contextDestroyed"));
+    }
+
+    /**
+     * Test listener to validate the destroy method was called.
+     */
+    class TestWebApplicationDestroyListener implements ServletContextListener {
+
+        /**
+         * Context initialized event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void contextInitialized(ServletContextEvent event) {
+        }
+
+        /**
+         * Context destroyed event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void contextDestroyed(ServletContextEvent event) {
+            event.getServletContext().setAttribute("contextDestroyed", true);
+        }
+    }
+
+    /**
+     * Test getAsync.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testGetAsync() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        Dynamic registration = webApp.addServlet("Chat", TestChat1Servlet.class);
+        registration.setAsyncSupported(true);
+        webApp.addServletMapping("Chat", "/chat");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/chat");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        webApp.service(request, response);
+        assertNotNull(response.getResponseBytes());
+        request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setAsyncSupported(true);
+        request.setServletPath("/chat");
+        request.setMethod("POST");
+        request.setParameter("action", new String[]{"login"});
+        request.setParameter("name", new String[]{"username"});
+        response = new TestWebApplicationResponse();
+        webApp.service(request, response);
+        assertNotNull(response.getResponseBytes());
+        request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/chat");
+        request.setMethod("POST");
+        request.setParameter("action", new String[]{"post"});
+        request.setParameter("name", new String[]{"username"});
+        request.setParameter("message", new String[]{new Date().toString()});
+        response = new TestWebApplicationResponse();
+        webApp.service(request, response);
+        assertNotNull(response.getResponseBytes());
+    }
+
+    /**
+     * Test getAsync.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testGetAsync2() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        Dynamic registration = webApp.addServlet("Chat", TestChat2Servlet.class);
+        registration.setAsyncSupported(true);
+        webApp.addServletMapping("Chat", "/chat");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/chat");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        webApp.service(request, response);
+        assertNotNull(response.getResponseBytes());
+        request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/chat");
+        request.setMethod("POST");
+        request.setParameter("action", new String[]{"login"});
+        request.setParameter("name", new String[]{"username"});
+        response = new TestWebApplicationResponse();
+        webApp.service(request, response);
+        assertNotNull(response.getResponseBytes());
+        request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/chat");
+        request.setMethod("POST");
+        request.setParameter("action", new String[]{"post"});
+        request.setParameter("name", new String[]{"username"});
+        request.setParameter("message", new String[]{new Date().toString()});
+        response = new TestWebApplicationResponse();
+        webApp.service(request, response);
+        assertNotNull(response.getResponseBytes());
+    }
+
+    /**
+     * Test getAttributeNames method.
+     */
+    @Test
+    void testGetAttributeNames() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNotNull(webApp.getAttributeNames());
+    }
+
+    /**
+     * Test getContext method.
+     */
+    @Test
+    void testGetContext() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNull(webApp.getContext("/does_not_matter"));
+    }
+
+    /**
+     * Test getDefaultSessionTrackingModes method.
+     */
+    @Test
+    void testGetDefaultSessionTrackingModes() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertTrue(webApp.getDefaultSessionTrackingModes().contains(SessionTrackingMode.COOKIE));
+    }
+
+    /**
+     * Test getDependencyInjectionManager method.
+     */
+    @Test
+    void testGetDependencyInjectionManager() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNotNull(webApp.getObjectInstanceManager());
+        webApp.setObjectInstanceManager(null);
+        assertNull(webApp.getObjectInstanceManager());
+    }
+
+    /**
+     * Test getDispatcherType.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testGetDispatcherType() throws Exception {
+        HttpServletRequest request = new TestWebApplicationRequest();
+        assertEquals(DispatcherType.REQUEST, request.getDispatcherType());
+    }
+
+    /**
+     * Test getEffectiveMajorVersion method.
+     */
+    @Test
+    void testGetEffectiveMajorVersion() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertEquals(4, webApp.getEffectiveMajorVersion());
+    }
+
+    /**
+     * Test getEffectiveMinorVersion method.
+     */
+    @Test
+    void testGetEffectiveMinorVersion() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertEquals(0, webApp.getEffectiveMinorVersion());
+    }
+
+    /**
+     * Test getEffectiveSessionTrackingModes method.
+     */
+    @Test
+    void testGetEffectiveSessionTrackingModes() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        Set<SessionTrackingMode> trackingModes = EnumSet.of(SessionTrackingMode.URL);
+        webApp.setSessionTrackingModes(trackingModes);
+        assertTrue(webApp.getEffectiveSessionTrackingModes().contains(SessionTrackingMode.URL));
+    }
+
+    /**
+     * Test getEffectiveSessionTrackingModes method.
+     */
+    @Test
+    void testGetEffectiveSessionTrackingModes2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.initialize();
+        webApp.start();
+        Set<SessionTrackingMode> trackingModes = EnumSet.of(SessionTrackingMode.URL);
+        assertThrows(IllegalStateException.class, () -> webApp.setSessionTrackingModes(trackingModes));
+    }
+
+    /**
+     * Test getInitParameter method.
+     */
+    @Test
+    void testGetInitParameter() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setInitParameter("initParameter", Boolean.TRUE.toString());
+        assertEquals("true", webApp.getInitParameter("initParameter"));
+    }
+
+    /**
+     * Test getInitParameterNames method.
+     */
+    @Test
+    void testGetInitParameterNames() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setInitParameter("initParameter", Boolean.TRUE.toString());
+        Enumeration<String> enumeration = webApp.getInitParameterNames();
+        assertEquals("initParameter", enumeration.nextElement());
+        assertFalse(enumeration.hasMoreElements());
+    }
+
+    /**
+     * Test getJspConfigDescriptor method.
+     */
+    @Test
+    void testGetJspConfigDescriptor() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNull(webApp.getJspConfigDescriptor());
+    }
+
+    /**
+     * Test getMajorVersion method.
+     */
+    @Test
+    void testGetMajorVersion() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertEquals(4, webApp.getMajorVersion());
+    }
+
+    /**
+     * Test getMimeType method.
+     */
+    @Test
+    void testGetMimeType() {
+        DefaultMimeTypeManager mimeTypeManager = new DefaultMimeTypeManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setMimeTypeManager(mimeTypeManager);
+        assertNull(webApp.getMimeType("this_maps_to.null"));
+    }
+
+    /**
+     * Test getMimeType method.
+     */
+    @Test
+    void testGetMimeType2() {
+        DefaultMimeTypeManager mimeTypeManager = new DefaultMimeTypeManager();
+        mimeTypeManager.addMimeType("class", "application/x-java-class");
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setMimeTypeManager(mimeTypeManager);
+        assertEquals(webApp.getMimeType("my.class"), "application/x-java-class");
+    }
+
+    /**
+     * Test getMinorVersion method.
+     */
+    @Test
+    void testGetMinorVersion() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertEquals(0, webApp.getMinorVersion());
+    }
+
+    /**
+     * Test getNamedDispatcher method.
+     */
+    @Test
+    void testGetNamedDispatcher() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("Snoop", TestSnoopServlet.class);
+        assertNotNull(webApp.getNamedDispatcher("Snoop"));
+    }
+
+    /**
+     * Test getParameterMap.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testGetParameterMap() throws Exception {
+        HttpServletRequest request = new TestWebApplicationRequest();
+        assertNotNull(request.getParameterMap());
+        assertNotNull(request.getParameterNames());
+    }
+
+    /**
+     * Test getRealPath method.
+     */
+    @Test
+    void testGetRealPath() {
+        DefaultResourceManager resourceManager = new DefaultResourceManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setResourceManager(resourceManager);
+        assertNull(webApp.getRealPath("index.html"));
+    }
+
+    /**
+     * Test getRealPath method.
+     */
+    @Test
+    void testGetRealPath2() {
+        DefaultResourceManager resourceManager = new DefaultResourceManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setResourceManager(resourceManager);
+        webApp.addResource(new DirectoryResource(new File(".")));
+        assertNotNull(webApp.getRealPath("/src/main/java"));
+    }
+
+    /**
+     * Test getRequest method.
+     */
+    @Test
+    void testGetRequest() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        webApp.linkRequestAndResponse(request, response);
+        assertNotNull(webApp.getRequest(response));
+    }
+
+    /**
+     * Test getRequestCharacterEncoding method.
+     */
+    @Test
+    void testGetRequestCharacterEncoding() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNull(webApp.getRequestCharacterEncoding());
+        webApp.setRequestCharacterEncoding("UTF-8");
+        assertEquals("UTF-8", webApp.getRequestCharacterEncoding());
+    }
+
+    /**
+     * Test getRequestDispatcher.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testGetRequestDispatcher() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        webApp.addServlet("Snoop", TestSnoopServlet.class);
+        webApp.addServletMapping("Snoop", "/Snoop");
+        assertNotNull(webApp.getRequestDispatcher("/Snoop"));
+    }
+
+    /**
+     * Test getResourceAsStream method.
+     */
+    @Test
+    void testGetResourceAsStream() {
+        DefaultResourceManager resourceManager = new DefaultResourceManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setResourceManager(resourceManager);
+        webApp.addResource(new DirectoryResource(new File(".")));
+        assertNotNull(webApp.getResourceAsStream("/pom.xml"));
+    }
+
+    /**
+     * Test getResourcePaths method.
+     */
+    @Test
+    void testGetResourcePaths() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNull(webApp.getResourcePaths("/this_will_be_null/"));
+        assertNull(webApp.getResourcePaths(null));
+    }
+
+    @Test
+    void testGetResourcePaths2() {
+        // Simulating the Javadoc example of the getResourcePaths method
+        DefaultResourceManager resourceManager = new DefaultResourceManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setResourceManager(resourceManager);
+        webApp.addResource(new DirectoryResource("src/test/webapp/resourcepaths"));
+
+        Set<String> resourcePathsRoot = webApp.getResourcePaths("/");
+        assertNotNull(resourcePathsRoot);
+        assertTrue(resourcePathsRoot.contains("/catalog/"));
+        assertTrue(resourcePathsRoot.contains("/customer/"));
+        assertTrue(resourcePathsRoot.contains("/welcome.html"));
+
+        Set<String> resourcePathsCatalog = webApp.getResourcePaths("/catalog/");
+        assertNotNull(resourcePathsCatalog);
+        assertTrue(resourcePathsCatalog.contains("/catalog/offers/"));
+        assertTrue(resourcePathsCatalog.contains("/catalog/products.html"));
+        assertTrue(resourcePathsCatalog.contains("/catalog/index.html"));
+
+        Set<String> resourcePathsCatalogOffers = webApp.getResourcePaths("/catalog/offers");
+        assertNotNull(resourcePathsCatalogOffers);
+        assertTrue(resourcePathsCatalogOffers.contains("/catalog/offers/books.html"));
+        assertTrue(resourcePathsCatalogOffers.contains("/catalog/offers/music.html"));
+    }
+
+    @Test
+    void testGetResourcePaths3() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(IllegalArgumentException.class, () -> webApp.getResourcePaths(""));
+    }
+
+    @Test
+    void testGetResourcePaths4() {
+        DefaultResourceManager resourceManager = new DefaultResourceManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setResourceManager(resourceManager);
+        webApp.addResource(new DirectoryResource("src/test/webapp/resourcepaths"));
+
+        assertNull(webApp.getResourcePaths("/welcome.html"));
+        assertNull(webApp.getResourcePaths("/catalog/products.html"));
+        assertNull(webApp.getResourcePaths("/catalog/offers/books.html"));
+    }
+
+    /**
+     * Test getResponseCharacterEncoding.
+     */
+    @Test
+    void testGetResponseCharacterEncoding() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNull(webApp.getResponseCharacterEncoding());
+        webApp.setResponseCharacterEncoding("UTF-8");
+        assertEquals("UTF-8", webApp.getResponseCharacterEncoding());
+    }
+
+    /**
+     * Test getSecurityManager.
+     */
+    @Test
+    void testGetSecurityManager() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        try {
+            webApp.getSecurityManager();
+        } catch (Exception exception) {
+        }
+    }
+
+    /**
+     * Test getSecurityManager.
+     */
+    @Test
+    void testGetSecurityManager2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setSecurityManager(new DefaultSecurityManager());
+        assertNotNull(webApp.getSecurityManager());
+    }
+
+    /**
+     * Test getServerInfo method.
+     */
+    @Test
+    void testGetServerInfo() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertEquals("", webApp.getServerInfo());
+    }
+
+    /**
+     * Test getServlets method.
+     *
+     * @throws Exception
+     */
+    @Test
+    @SuppressWarnings("deprecation")
+    void testGetServlet() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(UnsupportedOperationException.class, () -> webApp.getServlet("always_null"));
+    }
+
+    /**
+     * Test getServletContextName method.
+     */
+    @Test
+    void testGetServletContextName() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setServletContextName("MYNAME");
+        assertNotNull(webApp.getServletContextName());
+        assertEquals("MYNAME", webApp.getServletContextName());
+    }
+
+    /**
+     * Test getServletRegistrations method.
+     */
+    @Test
+    void testGetServletRegistrations() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNotNull(webApp.getServletRegistrations());
+        assertTrue(webApp.getServletRegistrations().isEmpty());
+    }
+
+    /**
+     * Test getServletNames method.
+     */
+    @Test
+    @SuppressWarnings("deprecation")
+    void testGetServletNames() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(UnsupportedOperationException.class, () -> webApp.getServletNames());
+    }
+
+    /**
+     * Test getServlets method.
+     */
+    @Test
+    @SuppressWarnings("deprecation")
+    void testGetServlets() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(UnsupportedOperationException.class, () -> webApp.getServlets());
+    }
+
+    /**
+     * Test getSession.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testGetSession() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        ServletRegistration.Dynamic dynamic = webApp.addServlet("session", "cloud.piranha.webapp.impl.TestSessionServlet");
+        assertNotNull(dynamic);
+        dynamic.addMapping("/session");
+        webApp.initialize();
+        webApp.start();
+
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/session");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+
+        webApp.service(request, response);
+
+        assertNotNull(response.getResponseBytes());
+    }
+
+    /**
+     * Test getSessionCookieConfig method.
+     */
+    @Test
+    void testGetSessionCookieConfig() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNotNull(webApp.getSessionCookieConfig());
+    }
+
+    /**
+     * Test getSessionManager method.
+     */
+    @Test
+    void testGetSessionManager() {
+        try {
+            DefaultWebApplication webApp = new DefaultWebApplication();
+            webApp.setHttpSessionManager(null);
+            webApp.getHttpSessionManager();
+        } catch (IllegalStateException exception) {
+        }
+    }
+
+    /**
+     * Test getSessionManager method.
+     */
+    @Test
+    void testGetSessionManager2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNotNull(webApp.getHttpSessionManager());
+    }
+
+    /**
+     * Test getVirtualServerName method.
+     */
+    @Test
+    void testGetVirtualServerName() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setVirtualServerName("myname");
+        assertEquals("myname", webApp.getVirtualServerName());
+    }
+
+    /**
+     * Test include.
+     *
+     * @throws Exception when a serious error occurred.
+     */
+    @Test
+    void testInclude() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("Include", TestIncludeServlet.class);
+        webApp.addServletMapping("Include", "/include");
+        webApp.addServlet("Include2", TestInclude2Servlet.class);
+        webApp.addServletMapping("Include2", "/include2");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/include");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.service(request, response);
+        assertTrue(new String(response.getResponseBytes()).contains("This was included"));
+    }
+
+    /**
+     * Test include.
+     *
+     * @throws Exception when a serious error occurred.
+     */
+    @Test
+    void testInclude2() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("Include", TestIncludeServlet.class);
+        webApp.addServletMapping("Include", "/include");
+        webApp.addServlet("Include2", TestInclude2Servlet.class);
+        webApp.addServletMapping("Include2", "/include2");
+        webApp.addServlet("Include", TestIncludeServlet.class);
+        webApp.addServletMapping("Include", "/include");
+        webApp.addServlet("Include3", TestInclude3Servlet.class);
+        webApp.addServletMapping("Include3", "/include3");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/include3");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.service(request, response);
+        assertTrue(new String(response.getResponseBytes()).contains("This was included"));
+    }
+
+    /**
+     * Test include.
+     *
+     * @throws Exception when a serious error occurred.
+     */
+    @Test
+    void testInclude3() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.addServlet("Include", TestIncludeServlet.class);
+        webApp.addServletMapping("Include", "/include");
+        webApp.addServlet("Include2", TestInclude2Servlet.class);
+        webApp.addServletMapping("Include2", "/include2");
+        webApp.addServlet("Include", TestIncludeServlet.class);
+        webApp.addServletMapping("Include", "/include");
+        webApp.addServlet("Include3", TestInclude3Servlet.class);
+        webApp.addServletMapping("Include3", "/include3");
+        webApp.addServlet("Include4", TestInclude4Servlet.class);
+        webApp.addServletMapping("Include4", "/include4");
+        webApp.initialize();
+        webApp.start();
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/include4");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.service(request, response);
+        assertTrue(new String(response.getResponseBytes()).contains("This was includedThis was included"));
+    }
+
+    /**
+     * Test initialize, start and stop methods.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testInitializeStartAndStop() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.initialize();
+        webApp.start();
+        webApp.stop();
+        webApp.destroy();
+
+        try {
+            webApp.start();
+        } catch (RuntimeException exception) {
+        }
+    }
+
+    /**
+     * Test log method.
+     */
+    @Test
+    void testLog() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.log("TEST");
+    }
+
+    /**
+     * Test log method.
+     */
+    @Test
+    @SuppressWarnings("deprecation")
+    void testLog2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(UnsupportedOperationException.class, () -> webApp.log(new IllegalStateException(), "TEST"));
+    }
+
+    /**
+     * Test log method.
+     */
+    @Test
+    void testLog3() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.log("TEST", new RuntimeException());
+    }
+
+    /**
+     * Test login.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testLogin() throws Exception {
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setSecurityManager(securityManager);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        try {
+            request.login("admin", "password");
+        } catch (ServletException exception) {
+        }
+    }
+
+    /**
+     * Test logout.
+     *
+     * @throws Exception
+     */
+    @Test
+    void testLogout() throws Exception {
+        DefaultSecurityManager securityManager = new DefaultSecurityManager();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setSecurityManager(securityManager);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        try {
+            request.logout();
+        } catch (ServletException exception) {
+        }
+    }
+
+    /**
+     * Test removeAttribute method.
+     */
+    @Test
+    void testRemoveAttribute() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setAttribute("name", "value");
+        assertNotNull(webApp.getAttribute("name"));
+        webApp.removeAttribute("name");
+        assertNull(webApp.getAttribute("name"));
+    }
+
+    /**
+     * Test service method (ServletRequestListeners)
+     *
+     * @throws Exception
+     */
+    @Test
+    void testService2() throws Exception {
+        DefaultWebApplicationRequestMapper webAppRequestMapper = new DefaultWebApplicationRequestMapper();
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(webAppRequestMapper);
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/Snoop");
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+        webApp.addServletMapping("Snoop", "/Snoop");
+        webApp.addServlet("DefaultServlet", DefaultServlet.class.getName());
+        webApp.addServletMapping("DefaultServlet", "/*");
+
+        webApp.initialize();
+        webApp.start();
+        webApp.service(request, response);
+        assertEquals(404, response.getStatus());
+    }
+
+    class TrackServletRequestListener implements ServletRequestListener {
+
+        StringBuilder trackCalls = new StringBuilder();
+
+        @Override
+        public void requestDestroyed(ServletRequestEvent sre) {
+            trackCalls.append("requestDestroyed,");
+        }
+
+        @Override
+        public void requestInitialized(ServletRequestEvent sre) {
+            trackCalls.append("requestInitialized,");
+        }
+    }
+
+    /**
+     * Test service method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testService3() throws Exception {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setWebApplicationRequestMapper(new DefaultWebApplicationRequestMapper());
+        webApp.addServletMapping("Snoop", "/Snoop");
+        webApp.addServlet("DefaultServlet", DefaultServlet.class.getName());
+        webApp.addServletMapping("DefaultServlet", "/*");
+
+        TestWebApplicationRequest request = new TestWebApplicationRequest();
+        request.setWebApplication(webApp);
+        request.setServletPath("/Snoop");
+
+        TestWebApplicationResponse response = new TestWebApplicationResponse();
+        response.setWebApplication(webApp);
+
+        webApp.initialize();
+        webApp.start();
+        webApp.service(request, response);
+        assertEquals(404, response.getStatus());
+    }
+
+    /**
+     * Test setAttribute method.
+     */
+    @Test
+    void testSetAttribute() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setAttribute("myattribute", null);
+        assertNull(webApp.getAttribute("myattribute"));
+    }
+
+    /**
+     * Test setAttribute method.
+     */
+    @Test
+    void testSetAttribute2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(NullPointerException.class, () -> webApp.setAttribute(null, "KABOOM"));
+    }
+
+    /**
+     * Test getAttribute method.
+     */
+    @Test
+    void testGetAttribute() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(NullPointerException.class, () -> webApp.getAttribute(null));
+    }
+
+
+    /**
+     * Test setClassLoader method.
+     */
+    @Test
+    void testSetClassLoader() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertNotNull(webApp.getClassLoader());
+        webApp.setClassLoader(null);
+        assertNull(webApp.getClassLoader());
+    }
+
+    /**
+     * Test setInitParameter method.
+     */
+    @Test
+    void testSetInitParameter() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertTrue(webApp.setInitParameter("name", "value"));
+        assertFalse(webApp.setInitParameter("name", "value"));
+    }
+
+    /**
+     * Test setInitParameter method.
+     */
+    @Test
+    void testSetInitParameter2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.initialize();
+        webApp.start();
+        assertThrows(IllegalStateException.class, () -> webApp.setInitParameter("name", "value"));
+    }
+
+    /**
+     * Test setInitParameter method.
+     */
+    @Test
+    void testSetInitParameter3() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        assertThrows(NullPointerException.class, () -> webApp.setInitParameter(null, "KABOOM"));
+    }
+
+
+    /**
+     * Test setInitParameter method.
+     */
+    @Test
+    void testSetInitParameter4() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.initialize();
+        webApp.start();
+        assertThrows(NullPointerException.class, () -> webApp.setInitParameter(null, "KABOOM"));
+    }
+
+    /**
+     * Test setLoggingManager method.
+     */
+    @Test
+    void testSetLoggingManager() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setLoggingManager(null);
+        assertThrows(NullPointerException.class, () -> webApp.log("KABOOM"));
+    }
+
+    /**
+     * Test setSessionTimeout method
+     */
+    @Test
+    void testSessionTimeout() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.setSessionTimeout(50);
+        assertEquals(50, webApp.getSessionTimeout());
+    }
+
+    /**
+     * Test setSessionTimeout method
+     */
+    @Test
+    void testSessionTimeout2() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.initialize();
+        webApp.start();
+        assertThrows(IllegalStateException.class, () -> webApp.setSessionTimeout(50));
+    }
+
+    @Test
+    void testSetLocale() {
+        DefaultWebApplication webApp = new DefaultWebApplication();
+        webApp.getLocaleEncodingManager().addCharacterEncoding(Locale.ITALY.toString(), "windows-1252");
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setWebApplication(webApp);
+        response.setLocale(Locale.ITALY);
+        assertEquals("windows-1252", response.getCharacterEncoding());
+    }
+
+    @Test
+    void testGetContentType() throws Exception {
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        assertNull(response.getContentType());
+        PrintWriter writer = response.getWriter();
+        response.setContentType("text/html");
+        assertEquals("text/html;charset=ISO-8859-1", response.getContentType());
+    }
+
+    @Test
+    void testSetBufferSize() throws Exception {
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
+            response.setUnderlyingOutputStream(baos);
+            response.flush();
+            assertThrows(IllegalStateException.class, () -> response.setBufferSize(20));
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/FilterRegistrationTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/FilterRegistrationTest.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/FilterRegistrationTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/FilterRegistrationTest.java
index 361ce994..27e1e1bb 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/FilterRegistrationTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/FilterRegistrationTest.java
@@ -25,7 +25,7 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
@@ -36,19 +36,18 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 import java.io.IOException;
 import java.util.HashMap;
 
-import jakarta.servlet.Filter;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.FilterConfig;
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for testing everything related to the FilterRegistration API.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/FilterTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/FilterTest.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/FilterTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/FilterTest.java
index 98264d6d..82a2faf8 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/FilterTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/FilterTest.java
@@ -25,7 +25,7 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
@@ -34,23 +34,22 @@ import static org.junit.jupiter.api.Assertions.assertThrows;
 
 import java.io.IOException;
 
-import jakarta.servlet.Filter;
-import jakarta.servlet.FilterChain;
-import jakarta.servlet.FilterConfig;
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequest;
-import jakarta.servlet.ServletResponse;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for testing everything related to the addFilter method and
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpServletRequestTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpServletRequestTest.java
new file mode 100644
index 00000000..c08e6c63
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpServletRequestTest.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.UnsupportedEncodingException;
+import javax.servlet.http.HttpServletRequest;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+/**
+ * The JUnit tests for testing everything related to the HttpServletRequest API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class HttpServletRequestTest {
+
+    /**
+     * Stores the HTTP servlet request.
+     */
+    protected HttpServletRequest httpServletRequest;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        httpServletRequest = new TestWebApplicationRequest();
+    }
+
+    /**
+     * Test setCharacterEncoding method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSetCharacterEncoding() throws Exception {
+        httpServletRequest.setCharacterEncoding("UTF-8");
+        assertEquals("UTF-8", httpServletRequest.getCharacterEncoding());
+    }
+
+    /**
+     * Test setCharacterEncoding method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSetCharacterEncoding2() throws Exception {
+        assertNull(httpServletRequest.getCharacterEncoding());
+        httpServletRequest.getReader();
+        httpServletRequest.setCharacterEncoding("UTF-8");
+        assertNotEquals("UTF-8", httpServletRequest.getCharacterEncoding());
+    }
+
+    /**
+     * Test setCharacterEncoding method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSetCharacterEncoding3() throws Exception {
+        assertThrows(UnsupportedEncodingException.class, () -> httpServletRequest.setCharacterEncoding("doesnotexist"));
+    }
+
+    /**
+     * Test setCharacterEncoding method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testSetCharacterEncoding4() throws Exception {
+        assertThrows(UnsupportedEncodingException.class, () -> httpServletRequest.setCharacterEncoding(null));
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpServletResponseTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpServletResponseTest.java
similarity index 84%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpServletResponseTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpServletResponseTest.java
index 8a9c6289..b4e54aeb 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpServletResponseTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpServletResponseTest.java
@@ -25,16 +25,15 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 import java.io.IOException;
 import java.io.PrintWriter;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
@@ -251,11 +250,16 @@ class HttpServletResponseTest {
     /**
      * Test servlet that sends a redirect.
      */
-    public static class TestRedirect2aServlet extends HttpServlet {
-
-        public TestRedirect2aServlet() {
-        }
-        
+    static class TestRedirect2aServlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
         @Override
         protected void doGet(HttpServletRequest request,
                 HttpServletResponse response) throws IOException, ServletException {
@@ -266,11 +270,16 @@ class HttpServletResponseTest {
     /**
      * Test servlet that receives the redirect.
      */
-    public static class TestRedirect2bServlet extends HttpServlet {
-
-        public TestRedirect2bServlet() {
-        }
-
+    static class TestRedirect2bServlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
         @Override
         protected void doGet(HttpServletRequest request,
                 HttpServletResponse response) throws IOException, ServletException {
@@ -284,11 +293,16 @@ class HttpServletResponseTest {
     /**
      * Test servlet that sends a redirect.
      */
-    public static class TestRedirect3Servlet extends HttpServlet {
-
-        public TestRedirect3Servlet() {
-        }
-
+    static class TestRedirect3Servlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
         @Override
         protected void doGet(HttpServletRequest request,
                 HttpServletResponse response) throws IOException, ServletException {
@@ -299,11 +313,16 @@ class HttpServletResponseTest {
     /**
      * Test servlet that sends a redirect.
      */
-    public static class TestRedirect4Servlet extends HttpServlet {
-
-        public TestRedirect4Servlet() {
-        }
-        
+    static class TestRedirect4Servlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
         @Override
         protected void doGet(HttpServletRequest request,
                 HttpServletResponse response) throws IOException, ServletException {
@@ -314,11 +333,16 @@ class HttpServletResponseTest {
     /**
      * Test servlet that tries to send a redirect after flushing the buffer.
      */
-    public static class TestRedirectAfterFlushServlet extends HttpServlet {
-
-        public TestRedirectAfterFlushServlet() {
-        }
-
+    static class TestRedirectAfterFlushServlet extends HttpServlet {
+
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
         @Override
         protected void doGet(HttpServletRequest request,
                 HttpServletResponse response) throws IOException, ServletException {
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionAttributeListenerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionAttributeListenerTest.java
similarity index 94%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionAttributeListenerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionAttributeListenerTest.java
index 5e1472ee..a89f8303 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionAttributeListenerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionAttributeListenerTest.java
@@ -25,26 +25,24 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpSessionAttributeListener;
-import jakarta.servlet.http.HttpSessionBindingEvent;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionAttributeListener;
+import javax.servlet.http.HttpSessionBindingEvent;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for the HttpSessionAttributeListener API.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionIdListenerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionIdListenerTest.java
similarity index 92%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionIdListenerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionIdListenerTest.java
index b0bc5777..c036aa7b 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionIdListenerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionIdListenerTest.java
@@ -25,7 +25,7 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
@@ -33,20 +33,18 @@ import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpSessionEvent;
-import jakarta.servlet.http.HttpSessionIdListener;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionEvent;
+import javax.servlet.http.HttpSessionIdListener;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for testing everything related to the HttpSessionIdListener
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionListenerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionListenerTest.java
similarity index 93%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionListenerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionListenerTest.java
index a2c21279..531d8bc4 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/HttpSessionListenerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/HttpSessionListenerTest.java
@@ -25,27 +25,25 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
-import jakarta.servlet.http.HttpSession;
-import jakarta.servlet.http.HttpSessionEvent;
-import jakarta.servlet.http.HttpSessionListener;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.HttpSessionEvent;
+import javax.servlet.http.HttpSessionListener;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for the HttpSessionListener API.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ListenerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ListenerTest.java
new file mode 100644
index 00000000..724e346a
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ListenerTest.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.util.EventListener;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletRequestListener;
+import javax.servlet.http.HttpSessionListener;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for testing everything related to the addListener and
+ * createListener methods.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ListenerTest {
+
+    /**
+     * Test addListener method.
+     */
+    @Test
+    void testAddListener() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addListener("ClassNotFoundListener");
+    }
+
+    /**
+     * Test addListener method.
+     */
+    @Test
+    void testAddListener2() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.initialize();
+        assertThrows(IllegalStateException.class, () -> webApplication.addListener("ClassNotFoundListener"));
+    }
+
+    /**
+     * Test addListener method.
+     */
+    @Test
+    void testAddListener3() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addListener(TestHttpSessionListener.class.getName());
+    }
+
+    /**
+     * Test addListener method.
+     */
+    @Test
+    void testAddListener4() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addListener(TestHttpSessionListener.class);
+    }
+
+    /**
+     * Test addListener method.
+     */
+    @Test
+    void testAddListener5() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        assertThrows(IllegalArgumentException.class, () -> webApplication.addListener(TestInvalidTypeOfListener.class));
+    }
+
+    /**
+     * Test addListener method.
+     */
+    @Test
+    void testAddListener6() {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addListener(TestBrokenHttpSessionListener.class);
+    }
+
+    /**
+     * Test createListener method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testCreateListener() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        assertThrows(IllegalArgumentException.class, () -> webApplication.createListener(TestInvalidTypeOfListener.class));
+    }
+
+    /**
+     * Test createListener method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testCreateListener2() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        assertNotNull(webApplication.createListener(
+                TestHttpSessionListener.class));
+    }
+
+    /**
+     * Test createListener method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testCreateListener3() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        assertNotNull(webApplication.createListener(
+                TestServletContextListener.class));
+    }
+
+    /**
+     * Test createListener method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testCreateListener4() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        assertNotNull(webApplication.createListener(
+                TestServletRequestListener.class));
+    }
+
+    /**
+     * Test HTTP session listener.
+     */
+    static class TestHttpSessionListener implements HttpSessionListener {
+
+        /**
+         * Constructor.
+         */
+        TestHttpSessionListener() {
+        }
+    }
+
+    /**
+     * Test event listener.
+     */
+    static class TestInvalidTypeOfListener implements EventListener {
+
+        /**
+         * Constructor.
+         */
+        TestInvalidTypeOfListener() {
+        }
+    }
+
+    /**
+     * Test Servlet context listener.
+     */
+    static class TestServletContextListener implements ServletContextListener {
+
+        /**
+         * Constructor.
+         */
+        TestServletContextListener() {
+        }
+    }
+
+    /**
+     * Test Servlet request listener.
+     */
+    static class TestServletRequestListener implements ServletRequestListener {
+
+        /**
+         * Constructor.
+         */
+        TestServletRequestListener() {
+        }
+    }
+
+    /**
+     * Test HTTP session listener.
+     */
+    static class TestBrokenHttpSessionListener implements HttpSessionListener {
+
+        /**
+         * Constructor.
+         */
+        TestBrokenHttpSessionListener() {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/MimeTypeManagerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/MimeTypeManagerTest.java
similarity index 96%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/MimeTypeManagerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/MimeTypeManagerTest.java
index d728872f..4dce5a7e 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/MimeTypeManagerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/MimeTypeManagerTest.java
@@ -25,10 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import cloud.piranha.webapp.api.MimeTypeManager;
-import cloud.piranha.webapp.impl.DefaultMimeTypeManager;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import org.junit.jupiter.api.BeforeEach;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContainerInitializerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContainerInitializerTest.java
similarity index 89%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContainerInitializerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContainerInitializerTest.java
index eb87a9b5..8eac232b 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContainerInitializerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContainerInitializerTest.java
@@ -25,10 +25,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
-import cloud.piranha.webapp.impl.DefaultAnnotationManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
@@ -39,10 +37,10 @@ import java.util.Collections;
 import java.util.Optional;
 import java.util.Set;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.annotation.HandlesTypes;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.annotation.HandlesTypes;
 
 import org.junit.jupiter.api.Test;
 
@@ -129,11 +127,21 @@ class ServletContainerInitializerTest {
      * A test ServletContainerInitializer used to make sure they are called when
      * the web application initializes.
      */
-    public static class TestInitializer implements ServletContainerInitializer {
+    static class TestInitializer implements ServletContainerInitializer {
 
-        public TestInitializer() {
+        /**
+         * Constructor.
+         */
+        TestInitializer() {
         }
 
+        /**
+         * Handle on startup.
+         *
+         * @param classes the classes.
+         * @param servletContext the servlet context.
+         * @throws ServletException when a servlet error occurs.
+         */
         @Override
         public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
             servletContext.setAttribute("initializerCalled", true);
@@ -141,11 +149,7 @@ class ServletContainerInitializerTest {
     }
 
     @HandlesTypes({Set.class, SomeAnnotation.class})
-    public static class InitializerWithHandlesTypes implements ServletContainerInitializer{
-
-        public InitializerWithHandlesTypes() {
-        }
-        
+    static class InitializerWithHandlesTypes implements ServletContainerInitializer{
         @Override
         public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {
             Optional<Class<?>> classInstance = classes.stream().filter(Set.class::isAssignableFrom).findFirst();
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContextAttributeListenerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContextAttributeListenerTest.java
similarity index 94%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContextAttributeListenerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContextAttributeListenerTest.java
index cf54806a..cf86d57b 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletContextAttributeListenerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContextAttributeListenerTest.java
@@ -25,25 +25,23 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletContextAttributeEvent;
-import jakarta.servlet.ServletContextAttributeListener;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletContextAttributeEvent;
+import javax.servlet.ServletContextAttributeListener;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for the ServletContextAttributeListener API.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContextListenerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContextListenerTest.java
new file mode 100644
index 00000000..53b4e0b8
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletContextListenerTest.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for testing everything related to the ServletContextListener
+ * API.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletContextListenerTest {
+
+    /**
+     * Test contextDestroyed method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testContextDestroyed() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addListener(new TestServletContextListener());
+        webApplication.initialize();
+        webApplication.destroy();
+        assertNotNull(webApplication.getAttribute("contextDestroyed"));
+    }
+
+    /**
+     * Test contextInitialized method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testContextInitialized() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.addListener(new TestServletContextListener());
+        webApplication.initialize();
+        webApplication.destroy();
+        assertNotNull(webApplication.getAttribute("contextInitialized"));
+    }
+
+    /**
+     * Test ServletContextListener to validate contextInitialized and
+     * contextDestroyed are properly called.
+     */
+    class TestServletContextListener implements ServletContextListener {
+
+        /**
+         * Context destroyed event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void contextDestroyed(ServletContextEvent event) {
+            event.getServletContext().setAttribute("contextDestroyed", true);
+        }
+
+        /**
+         * Context initialized event.
+         *
+         * @param event the event.
+         */
+        @Override
+        public void contextInitialized(ServletContextEvent event) {
+            event.getServletContext().setAttribute("contextInitialized", true);
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRegistrationTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRegistrationTest.java
similarity index 97%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRegistrationTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRegistrationTest.java
index f83a4670..26ecc2fd 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRegistrationTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRegistrationTest.java
@@ -25,13 +25,12 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 import java.util.HashMap;
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.http.HttpServlet;
+import javax.servlet.ServletRegistration;
+import javax.servlet.http.HttpServlet;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestAttributeListenerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestAttributeListenerTest.java
similarity index 94%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestAttributeListenerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestAttributeListenerTest.java
index b8549fd1..81b08402 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestAttributeListenerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestAttributeListenerTest.java
@@ -25,25 +25,23 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 import java.io.IOException;
 
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRequestAttributeEvent;
-import jakarta.servlet.ServletRequestAttributeListener;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequestAttributeEvent;
+import javax.servlet.ServletRequestAttributeListener;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for the ServletRequestAttributeListener API.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestListenerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestListenerTest.java
similarity index 94%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestListenerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestListenerTest.java
index fe0eb9be..1e1a4bac 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletRequestListenerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestListenerTest.java
@@ -25,19 +25,17 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 
-import jakarta.servlet.ServletRequestEvent;
-import jakarta.servlet.ServletRequestListener;
+import javax.servlet.ServletRequestEvent;
+import javax.servlet.ServletRequestListener;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for ServletRequestListener API.
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestTest.java
new file mode 100644
index 00000000..f989bc7e
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletRequestTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import javax.servlet.ServletRequest;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * The JUnit tests for the ServletRequest API.
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+class ServletRequestTest {
+
+    /**
+     * Stores the servlet request.
+     */
+    protected ServletRequest request;
+
+    /**
+     * Setup before testing.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @BeforeEach
+    void setUp() throws Exception {
+        request = new TestWebApplicationRequest();
+    }
+
+    /**
+     * Test getInputStream method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetInputStream() throws Exception {
+        assertNotNull(request.getInputStream());
+    }
+
+    /**
+     * Test getInputStream method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetInputStream2() throws Exception {
+        assertNotNull(request.getInputStream());
+        assertThrows(IllegalStateException.class, () -> request.getReader());
+    }
+
+    /**
+     * Test getReader method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetReader() throws Exception {
+        assertNotNull(request.getReader());
+    }
+
+    /**
+     * Test getReader method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    void testGetReader2() throws Exception {
+        assertNotNull(request.getReader());
+        assertThrows(IllegalStateException.class, () -> request.getInputStream());
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletTest.java
similarity index 89%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletTest.java
index a3bf1561..47b8e61c 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/ServletTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/ServletTest.java
@@ -25,7 +25,7 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
@@ -33,20 +33,18 @@ import static org.junit.jupiter.api.Assertions.fail;
 
 import java.io.IOException;
 
-import jakarta.servlet.Servlet;
-import jakarta.servlet.ServletConfig;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRegistration;
-import jakarta.servlet.http.HttpServlet;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
+import javax.servlet.Servlet;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import cloud.piranha.webapp.api.WebApplication;
-import cloud.piranha.webapp.impl.DefaultHttpSessionManager;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
 
 /**
  * The JUnit tests for the Servlet API.
@@ -169,7 +167,7 @@ class ServletTest {
     /**
      * Test to verify instantiating a broken servlet fails.
      */
-    public static class TestBrokenServlet extends HttpServlet {
+    class TestBrokenServlet extends HttpServlet {
 
         private static final long serialVersionUID = 1L;
 
@@ -187,15 +185,20 @@ class ServletTest {
     }
 
     /**
-     * Test to verify instantiating a Servlet succeeds.
+     * Test to verify instantiating a servlet succeeds.
      */
-    public static class TestServlet extends HttpServlet {
+    static class TestServlet extends HttpServlet {
 
         private static final long serialVersionUID = 1L;
 
-        public TestServlet() {
-        }
-        
+        /**
+         * Handle GET request.
+         *
+         * @param request the request.
+         * @param response the response.
+         * @throws IOException when an I/O error occurs.
+         * @throws ServletException when a Servlet error occurs.
+         */
         @Override
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             response.getWriter().println("SUCCESS");
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/SessionCookieConfigTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/SessionCookieConfigTest.java
new file mode 100644
index 00000000..8270f3b2
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/SessionCookieConfigTest.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import javax.servlet.ServletContextEvent;
+import javax.servlet.ServletContextListener;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import static org.junit.jupiter.api.Assertions.fail;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests related to SessionCookieConfig.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class SessionCookieConfigTest {
+    
+    /**
+     * Test changing using a ServletContextListener.
+     * 
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    public void testServletContextListener() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.getHttpSessionManager().setWebApplication(webApplication);
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setWebApplication(webApplication);
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+        response.setUnderlyingOutputStream(byteOutput);
+        webApplication.addServlet("TestServletContextListenerServlet", new TestServletContextListenerServlet());
+        webApplication.addServletMapping("TestServletContextListenerServlet", "/*");
+        webApplication.addListener(new TestServletContextListener());
+        webApplication.initialize();
+        webApplication.start();
+        try {
+            webApplication.service(request, response);
+        } catch (ServletException se) {
+            fail();
+        }
+        webApplication.stop();
+    }
+    
+    public class TestServletContextListener implements ServletContextListener {
+
+        @Override
+        public void contextInitialized(ServletContextEvent event) {
+            event.getServletContext().getSessionCookieConfig().setComment("MY COMMENT");
+        }
+    }
+
+    public class TestServletContextListenerServlet extends HttpServlet {
+
+        @Override
+        protected void service(HttpServletRequest request,
+                HttpServletResponse response) throws ServletException, IOException {
+
+            request.getSession(true);
+            
+            if (!request.getServletContext().getSessionCookieConfig().getComment().equals("MY COMMENT")) {
+                throw new ServletException("ServletContextListener did not work");
+            }
+        }
+    }
+    /**
+     * Test setName method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    public void testSetName() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.getHttpSessionManager().setWebApplication(webApplication);
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setWebApplication(webApplication);
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+        response.setUnderlyingOutputStream(byteOutput);
+        webApplication.addServlet("TestSetNameServlet", new TestSetNameServlet());
+        webApplication.addServletMapping("TestSetNameServlet", "/*");
+        webApplication.initialize();
+        webApplication.start();
+        try {
+            webApplication.service(request, response);
+            fail();
+        } catch (IllegalStateException ise) {
+        }
+        webApplication.stop();
+    }
+
+    public class TestSetNameServlet extends HttpServlet {
+
+        @Override
+        protected void service(HttpServletRequest request,
+                HttpServletResponse response) throws ServletException, IOException {
+
+            request.getSession(true);
+            request.getServletContext().getSessionCookieConfig().setName("MYNAME");
+        }
+    }
+
+    /**
+     * Test setSecure method.
+     *
+     * @throws Exception when a serious error occurs.
+     */
+    @Test
+    public void testSetSecure() throws Exception {
+        DefaultWebApplication webApplication = new DefaultWebApplication();
+        webApplication.getHttpSessionManager().setWebApplication(webApplication);
+        DefaultWebApplicationRequest request = new DefaultWebApplicationRequest();
+        request.setWebApplication(webApplication);
+        DefaultWebApplicationResponse response = new DefaultWebApplicationResponse();
+        response.setWebApplication(webApplication);
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();
+        response.setUnderlyingOutputStream(byteOutput);
+        webApplication.addServlet("TestSetSecureServlet", new TestSetSecureServlet());
+        webApplication.addServletMapping("TestSetSecureServlet", "/*");
+        webApplication.initialize();
+        webApplication.start();
+        try {
+            webApplication.service(request, response);
+            fail();
+        } catch (IllegalStateException ise) {
+        }
+        webApplication.stop();
+    }
+
+    public class TestSetSecureServlet extends HttpServlet {
+
+        @Override
+        protected void service(HttpServletRequest request,
+                HttpServletResponse response) throws ServletException, IOException {
+
+            request.getSession(true);
+            request.getServletContext().getSessionCookieConfig().setSecure(true);
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestChat1Servlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestChat1Servlet.java
new file mode 100644
index 00000000..dd2555bd
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestChat1Servlet.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import javax.servlet.AsyncContext;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A test chat servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestChat1Servlet extends HttpServlet {
+
+    /**
+     * Stores the async queue.
+     */
+    private static final ConcurrentLinkedQueue<AsyncContext> ASYNC_QUEUE = new ConcurrentLinkedQueue<>();
+
+    /**
+     * Stores the message queue.
+     */
+    private static final LinkedBlockingQueue<String> MESSAGE_QUEUE = new LinkedBlockingQueue<>();
+
+    /**
+     * Stores the message thread.
+     */
+    private Thread messageThread = null;
+
+    /**
+     * Stores serial version UID.
+     */
+    private static final long serialVersionUID = -2919167206889576860L;
+
+    /**
+     * Initialize the servlet.
+     *
+     * @param config the servlet config.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void init(ServletConfig config) throws ServletException {
+        Runnable messageRunnable = () -> {
+            boolean done = false;
+            while (!done) {
+                String message;
+                try {
+                    message = MESSAGE_QUEUE.take();
+                    ASYNC_QUEUE.stream().forEach((context) -> {
+                        try {
+                            PrintWriter writer = context.getResponse().getWriter();
+                            writer.println(message);
+                            writer.flush();
+                        } catch (IOException exception) {
+                            ASYNC_QUEUE.remove(context);
+                        }
+                    });
+                } catch (InterruptedException exception) {
+                    done = true;
+                }
+            }
+        };
+        /**
+         * Run the notifier thread.
+         */
+        messageThread = new Thread(messageRunnable);
+        messageThread.start();
+    }
+
+    /**
+     * Get request, which initializes the async processing.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        response.setContentType("text/html");
+        response.setHeader("Cache-Control", "private");
+        response.setHeader("Pragma", "no-cache");
+        PrintWriter writer = response.getWriter();
+        writer.flush();
+        final AsyncContext context = request.startAsync();
+        context.setTimeout(300000);
+        context.addListener(new AsyncListener() {
+
+            /**
+             * Handle the completion.
+             *
+             * @param event the event.
+             */
+            @Override
+            public void onComplete(AsyncEvent event) throws IOException {
+                ASYNC_QUEUE.remove(context);
+            }
+
+            /**
+             * Handle the timeout.
+             *
+             * @param event the event.
+             */
+            @Override
+            public void onTimeout(AsyncEvent event) throws IOException {
+                ASYNC_QUEUE.remove(context);
+            }
+
+            /**
+             * Handle an error.
+             *
+             * @param event the event.
+             */
+            @Override
+            public void onError(AsyncEvent event) throws IOException {
+                ASYNC_QUEUE.remove(context);
+            }
+
+            /**
+             * Handle starting async processing.
+             *
+             * @param event the event.
+             */
+            @Override
+            public void onStartAsync(AsyncEvent event) throws IOException {
+            }
+        });
+        ASYNC_QUEUE.add(context);
+    }
+
+    /**
+     * Post the action.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        response.setContentType("text/plain");
+        response.setHeader("Cache-Control", "private");
+        response.setHeader("Pragma", "no-cache");
+        String action = request.getParameter("action");
+        String name = request.getParameter("name");
+        if (null != action) {
+            switch (action) {
+                case "login": {
+                    String message = name + " has joined.";
+                    notify(message);
+                    response.getWriter().println("success");
+                    break;
+                }
+                case "post": {
+                    String content = request.getParameter("message");
+                    String message = name + " said " + content;
+                    notify(message);
+                    response.getWriter().println("success");
+                    break;
+                }
+                default:
+                    response.sendError(422, "Unable to process");
+                    break;
+            }
+        }
+    }
+
+    /**
+     * Destroy the servlet.
+     */
+    @Override
+    public void destroy() {
+        ASYNC_QUEUE.clear();
+        messageThread.interrupt();
+    }
+
+    /**
+     * Notify.
+     *
+     * @param message the message.
+     * @throws IOException when an I/O error occurs.
+     */
+    private void notify(String message) throws IOException {
+        try {
+            MESSAGE_QUEUE.put(message);
+        } catch (InterruptedException exception) {
+            throw new IOException(exception);
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestChat2Servlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestChat2Servlet.java
new file mode 100644
index 00000000..2ae80ce4
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestChat2Servlet.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import javax.servlet.AsyncContext;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A test chat servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestChat2Servlet extends HttpServlet {
+
+    /**
+     * Stores the async queue.
+     */
+    private static final ConcurrentLinkedQueue<AsyncContext> ASYNC_QUEUE = new ConcurrentLinkedQueue<>();
+
+    /**
+     * Stores the message queue.
+     */
+    private static final LinkedBlockingQueue<String> MESSAGE_QUEUE = new LinkedBlockingQueue<>();
+
+    /**
+     * Stores the message thread.
+     */
+    private Thread messageThread = null;
+
+    /**
+     * Stores serial version UID.
+     */
+    private static final long serialVersionUID = -2919167206889576860L;
+
+    /**
+     * Initialize the servlet.
+     *
+     * @param config the servlet config.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void init(ServletConfig config) throws ServletException {
+        Runnable messageRunnable = () -> {
+            boolean done = false;
+            while (!done) {
+                String message;
+                try {
+                    message = MESSAGE_QUEUE.take();
+                    ASYNC_QUEUE.stream().forEach((context) -> {
+                        try {
+                            PrintWriter writer = context.getResponse().getWriter();
+                            writer.println(message);
+                            writer.flush();
+                        } catch (IOException exception) {
+                            ASYNC_QUEUE.remove(context);
+                        }
+                    });
+                } catch (InterruptedException exception) {
+                    done = true;
+                }
+            }
+        };
+        /**
+         * Run the notifier thread.
+         */
+        messageThread = new Thread(messageRunnable);
+        messageThread.start();
+    }
+
+    /**
+     * Get request, which initializes the async processing.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        response.setContentType("text/html");
+        response.setHeader("Cache-Control", "private");
+        response.setHeader("Pragma", "no-cache");
+        PrintWriter writer = response.getWriter();
+        writer.flush();
+        final AsyncContext context = request.startAsync(request, response);
+        context.setTimeout(300000);
+        context.addListener(new AsyncListener() {
+
+            /**
+             * Handle the completion.
+             *
+             * @param event the event.
+             */
+            @Override
+            public void onComplete(AsyncEvent event) throws IOException {
+                ASYNC_QUEUE.remove(context);
+            }
+
+            /**
+             * Handle the timeout.
+             *
+             * @param event the event.
+             */
+            @Override
+            public void onTimeout(AsyncEvent event) throws IOException {
+                ASYNC_QUEUE.remove(context);
+            }
+
+            /**
+             * Handle an error.
+             *
+             * @param event the event.
+             */
+            @Override
+            public void onError(AsyncEvent event) throws IOException {
+                ASYNC_QUEUE.remove(context);
+            }
+
+            /**
+             * Handle starting async processing.
+             *
+             * @param event the event.
+             */
+            @Override
+            public void onStartAsync(AsyncEvent event) throws IOException {
+            }
+        });
+        ASYNC_QUEUE.add(context);
+    }
+
+    /**
+     * Post the action.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        response.setContentType("text/plain");
+        response.setHeader("Cache-Control", "private");
+        response.setHeader("Pragma", "no-cache");
+        String action = request.getParameter("action");
+        String name = request.getParameter("name");
+        if (null != action) {
+            switch (action) {
+                case "login": {
+                    String message = name + " has joined.";
+                    notify(message);
+                    response.getWriter().println("success");
+                    break;
+                }
+                case "post": {
+                    String content = request.getParameter("message");
+                    String message = name + " said " + content;
+                    notify(message);
+                    response.getWriter().println("success");
+                    break;
+                }
+                default:
+                    response.sendError(422, "Unable to process");
+                    break;
+            }
+        }
+    }
+
+    /**
+     * Destroy the servlet.
+     */
+    @Override
+    public void destroy() {
+        ASYNC_QUEUE.clear();
+        messageThread.interrupt();
+    }
+
+    /**
+     * Notify.
+     *
+     * @param message the message.
+     * @throws IOException when an I/O error occurs.
+     */
+    private void notify(String message) throws IOException {
+        try {
+            MESSAGE_QUEUE.put(message);
+        } catch (InterruptedException exception) {
+            throw new IOException(exception);
+        }
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestEcho1Servlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestEcho1Servlet.java
new file mode 100644
index 00000000..77258cf4
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestEcho1Servlet.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A test echo servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestEcho1Servlet extends HttpServlet {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Service the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        response.getWriter().print("ECHO");
+        response.getWriter().flush();
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestEcho2Servlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestEcho2Servlet.java
new file mode 100644
index 00000000..11542ec4
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestEcho2Servlet.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A test echo servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestEcho2Servlet extends HttpServlet {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Service the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        response.getOutputStream().write("ECHO".getBytes());
+        response.getOutputStream().flush();
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestHttpServerRequest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestHttpServerRequest.java
new file mode 100644
index 00000000..459373cd
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestHttpServerRequest.java
@@ -0,0 +1,329 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import cloud.piranha.http.api.HttpServerRequest;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+
+/**
+ * A Test HttpServerRequest class.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestHttpServerRequest implements HttpServerRequest {
+
+    @Override
+    public String getHeader(String string) {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public Iterator<String> getHeaders(String name) {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public String getQueryParameter(String string) {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+    
+    /**
+     * Stores the headers.
+     */
+    private HashMap<String, String[]> headers;
+
+    /**
+     * Stores the input stream.
+     */
+    private InputStream inputStream;
+
+    /**
+     * Stores the local address.
+     */
+    private String localAddress;
+
+    /**
+     * Stores the local hostname.
+     */
+    private String localHostname;
+
+    /**
+     * Stores the local port.
+     */
+    private int localPort;
+
+    /**
+     * Stores the method.
+     */
+    private String method;
+
+    /**
+     * Stores the query string.
+     */
+    private String queryString;
+
+    /**
+     * Stores the remote address.
+     */
+    private String remoteAddress;
+
+    /**
+     * Stores the remote hostname.
+     */
+    private String remoteHostname;
+
+    /**
+     * Stores the remote port.
+     */
+    private int remotePort;
+
+    /**
+     * Stores the request target.
+     */
+    private String requestTarget;
+
+    /**
+     * Constructor.
+     */
+    public TestHttpServerRequest() {
+        this.headers = new HashMap<>();
+        this.inputStream = new ByteArrayInputStream(new byte[0]);
+        this.localAddress = "127.0.0.1";
+        this.localHostname = "localhost";
+        this.localPort = 8080;
+        this.remoteAddress = "127.0.0.2";
+        this.remoteHostname = "localhost";
+        this.remotePort = 18080;
+        this.requestTarget = "";
+        this.method = "GET";
+    }
+
+    /**
+     * Get the header names.
+     *
+     * @return the header names.
+     */
+    @Override
+    public Iterator<String> getHeaderNames() {
+        return headers.keySet().iterator();
+    }
+
+    /**
+     * Get the input stream.
+     *
+     * @return the input stream.
+     */
+    @Override
+    public InputStream getInputStream() {
+        return inputStream;
+    }
+
+    /**
+     * Get the local address.
+     *
+     * @return the local address.
+     */
+    @Override
+    public String getLocalAddress() {
+        return localAddress;
+    }
+
+    /**
+     * Get the local hostname.
+     *
+     * @return the local hostname.
+     */
+    @Override
+    public String getLocalHostname() {
+        return localHostname;
+    }
+
+    /**
+     * Get the local port.
+     *
+     * @return the local port.
+     */
+    @Override
+    public int getLocalPort() {
+        return localPort;
+    }
+
+    /**
+     * Get the method.
+     *
+     * @return the method.
+     */
+    @Override
+    public String getMethod() {
+        return method;
+    }
+
+    /**
+     * Get the query string.
+     *
+     * @return the query string.
+     */
+    @Override
+    public String getQueryString() {
+        return queryString;
+    }
+
+    /**
+     * Get the remote address.
+     *
+     * @return the remote address.
+     */
+    @Override
+    public String getRemoteAddress() {
+        return remoteAddress;
+    }
+
+    /**
+     * Get the remote hostname.
+     *
+     * @return the remote hostname.
+     */
+    @Override
+    public String getRemoteHostname() {
+        return remoteHostname;
+    }
+
+    /**
+     * Get the remote port.
+     *
+     * @return the remote port.
+     */
+    @Override
+    public int getRemotePort() {
+        return remotePort;
+    }
+
+    /**
+     * Get the request target.
+     *
+     * @return the request target.
+     */
+    @Override
+    public String getRequestTarget() {
+        return requestTarget;
+    }
+
+    /**
+     * Set the method.
+     *
+     * @param method the method.
+     */
+    public void setMethod(String method) {
+        this.method = method;
+    }
+
+    /**
+     * Set the input stream.
+     *
+     * @param inputStream the input stream.
+     */
+    public void setInputStream(InputStream inputStream) {
+        this.inputStream = inputStream;
+    }
+
+    /**
+     * Set the local address.
+     *
+     * @param localAddress the local address.
+     */
+    public void setLocalAddress(String localAddress) {
+        this.localAddress = localAddress;
+    }
+
+    /**
+     * Set the local hostname.
+     *
+     * @param localHostname the local hostname.
+     */
+    public void setLocalHostname(String localHostname) {
+        this.localHostname = localHostname;
+    }
+
+    /**
+     * Set the local port.
+     *
+     * @param localPort the local port.
+     */
+    public void setLocalPort(int localPort) {
+        this.localPort = localPort;
+    }
+
+    /**
+     * Set the query string.
+     *
+     * @param queryString the query string.
+     */
+    public void setQueryString(String queryString) {
+        this.queryString = queryString;
+    }
+
+    /**
+     * Set the remote address.
+     *
+     * @param remoteAddress the remote address.
+     */
+    public void setRemoteAddress(String remoteAddress) {
+        this.remoteAddress = remoteAddress;
+    }
+
+    /**
+     * Set the remote hostname.
+     *
+     * @param remoteHostname the remote hostname.
+     */
+    public void setRemoteHostname(String remoteHostname) {
+        this.remoteHostname = remoteHostname;
+    }
+
+    /**
+     * Set the remote port.
+     *
+     * @param remotePort the remote port.
+     */
+    public void setRemotePort(int remotePort) {
+        this.remotePort = remotePort;
+    }
+
+    /**
+     * Set the request target.
+     *
+     * @param requestTarget the request target.
+     */
+    public void setRequestTarget(String requestTarget) {
+        this.requestTarget = requestTarget;
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestHttpServerResponse.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestHttpServerResponse.java
new file mode 100644
index 00000000..cb5503d6
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestHttpServerResponse.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import cloud.piranha.http.api.HttpServerResponse;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * The HttpServerResponse used for testing.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestHttpServerResponse implements HttpServerResponse {
+
+    /**
+     * Stores the output stream.
+     */
+    private final ByteArrayOutputStream outputStream;
+
+    /**
+     * Constructor.
+     */
+    public TestHttpServerResponse() {
+        this.outputStream = new ByteArrayOutputStream();
+    }
+
+    /**
+     * Get the byte-array output stream.
+     * 
+     * @return the byte-array output stream.
+     */
+    public ByteArrayOutputStream getByteArrayOutputStream() {
+        return outputStream;
+    }
+
+    @Override
+    public void addHeader(String name, String value) {
+    }
+
+    @Override
+    public String getHeader(String name) {
+        return null;
+    }
+
+    @Override
+    public OutputStream getOutputStream() {
+        return outputStream;
+    }
+
+    @Override
+    public void setHeader(String name, String value) {
+    }
+
+    @Override
+    public void setStatus(int status) {
+    }
+
+    @Override
+    public void writeHeaders() throws IOException {
+    }
+
+    @Override
+    public void writeStatusLine() throws IOException {
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestIOExceptionServlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestIOExceptionServlet.java
new file mode 100644
index 00000000..2799fc13
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestIOExceptionServlet.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A test I/O exception servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestIOExceptionServlet extends HttpServlet {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Service the request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        throw new IOException();
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude2Servlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude2Servlet.java
new file mode 100644
index 00000000..dfe2ef68
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude2Servlet.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A servlet testing includes (performing the actual include).
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestInclude2Servlet extends HttpServlet {
+
+    /**
+     * Initialize the servlet.
+     *
+     * @param config the servlet config.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void init(ServletConfig config) throws ServletException {
+    }
+
+    /**
+     * Process GET request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response)
+            throws IOException, ServletException {
+        response.getWriter().print("This was included");
+        response.getWriter().flush();
+    }
+
+    /**
+     * Destroy the servlet.
+     */
+    @Override
+    public void destroy() {
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude3Servlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude3Servlet.java
new file mode 100644
index 00000000..41a557b2
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude3Servlet.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A servlet testing includes (performing the actual include).
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestInclude3Servlet extends HttpServlet {
+
+    /**
+     * Initialize the servlet.
+     *
+     * @param config the servlet config.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void init(ServletConfig config) throws ServletException {
+    }
+
+    /**
+     * Process GET request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response)
+            throws IOException, ServletException {
+        RequestDispatcher rd = request.getServletContext().getRequestDispatcher("/include");
+        rd.include(request, response);
+    }
+
+    /**
+     * Destroy the servlet.
+     */
+    @Override
+    public void destroy() {
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude4Servlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude4Servlet.java
new file mode 100644
index 00000000..9f47fb71
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestInclude4Servlet.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A servlet testing includes (performing the actual include).
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestInclude4Servlet extends HttpServlet {
+
+    /**
+     * Initialize the servlet.
+     *
+     * @param config the servlet config.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void init(ServletConfig config) throws ServletException {
+    }
+
+    /**
+     * Process GET request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response)
+            throws IOException, ServletException {
+        RequestDispatcher rd = request.getServletContext().getRequestDispatcher("/include");
+        rd.include(request, response);
+        rd = request.getServletContext().getRequestDispatcher("/include3");
+        rd.include(request, response);
+    }
+
+    /**
+     * Destroy the servlet.
+     */
+    @Override
+    public void destroy() {
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestIncludeServlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestIncludeServlet.java
new file mode 100644
index 00000000..48ddd6ef
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestIncludeServlet.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A servlet testing includes.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestIncludeServlet extends HttpServlet {
+
+    /**
+     * Initialize the servlet.
+     *
+     * @param config the servlet config.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void init(ServletConfig config) throws ServletException {
+    }
+
+    /**
+     * Process GET request.
+     *
+     * @param request the request.
+     * @param response the response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response)
+            throws IOException, ServletException {
+        RequestDispatcher rd = request.getServletContext().getRequestDispatcher("/include2");
+        rd.include(request, response);
+    }
+
+    /**
+     * Destroy the servlet.
+     */
+    @Override
+    public void destroy() {
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestRuntimeExceptionServlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestRuntimeExceptionServlet.java
new file mode 100644
index 00000000..84fc41cb
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestRuntimeExceptionServlet.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A test runtime exception servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestRuntimeExceptionServlet extends HttpServlet {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Service the request.
+     *
+     * @param request the servlet request.
+     * @param response the servlet response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        throw new RuntimeException();
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestSessionServlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestSessionServlet.java
new file mode 100644
index 00000000..11213c71
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestSessionServlet.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+
+/**
+ * A test HTTP session Servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestSessionServlet extends HttpServlet {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Processes the request.
+     *
+     * @param request the servlet request.
+     * @param response the servlet response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        response.setContentType("text/plain");
+        try (PrintWriter out = response.getWriter()) {
+            if (request.isRequestedSessionIdValid()) {
+                HttpSession session = request.getSession(false);
+                out.println("Session is " + session);
+                if (session == null) {
+                    session = request.getSession();
+                    out.println("Session is " + session);
+                }
+            } else {
+                HttpSession session = request.getSession();
+                out.println("Session is " + session + ", from request");
+            }
+        }
+    }
+
+    /**
+     * Handles the GET request.
+     *
+     * @param request the servlet request.
+     * @param response the servlet response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        processRequest(request, response);
+    }
+
+    /**
+     * Handles the POST request.
+     *
+     * @param request the servlet request.
+     * @param response the servlet response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        processRequest(request, response);
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestSnoopServlet.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestSnoopServlet.java
new file mode 100644
index 00000000..34f4566c
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestSnoopServlet.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.Locale;
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * A test Snoop Servlet.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestSnoopServlet extends HttpServlet {
+
+    /**
+     * Stores the serial version UID.
+     */
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Processes the request.
+     *
+     * @param request the servlet request.
+     * @param response the servlet response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @SuppressWarnings("deprecation")
+    protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        response.setContentType("text/html;charset=UTF-8");
+        PrintWriter out = response.getWriter();
+        out.println("<html>");
+        out.println(" <head>");
+        out.println("  <title>Snoop</title>");
+        out.println(" </head>");
+        out.println(" <body>");
+        out.println("  <h1>Snoop</h1>");
+        out.println("   <table>");
+        out.println("    <tr><td>Attribute Names:</td><td>" + request.getAttributeNames() + "</td></tr>");
+        out.println("<tr><td>Auth Type:</td><td>" + request.getAuthType() + "</td></tr>");
+        out.println("<tr><td>Character Encoding:</td><td>" + request.getCharacterEncoding() + "</td></tr>");
+        out.println("<tr><td>Class:</td><td>" + request.getClass() + "</td></tr>");
+        out.println("<tr><td>Content Length:</td><td>" + request.getContentLength() + "</td></tr>");
+        out.println("<tr><td>Content Type:</td><td>" + request.getContentType() + "</td></tr>");
+        out.println("<tr><td>Context Path:</td><td>" + request.getContextPath() + "</td></tr>");
+        out.println("<tr><td>Cookies:</td><td>" + Arrays.toString(request.getCookies()) + "</td></tr>");
+        out.println("<tr><td>Dispatcher Type:</td><td>" + request.getDispatcherType() + "</td></tr>");
+        out.println("<tr><td>Header Names:</td><td>" + request.getHeaderNames() + "</td></tr>");
+        out.println("<tr><td>Local Address:</td><td>" + request.getLocalAddr() + "</td></tr>");
+        out.println("<tr><td>Local Name:</td><td>" + request.getLocalName() + "</td></tr>");
+        out.println("<tr><td>Local Port:</td><td>" + request.getLocalPort() + "</td></tr>");
+        out.println("<tr><td>Locale:</td><td>" + request.getLocale() + "</td></tr>");
+        out.println("<tr><td>Locales:</td><td>" + request.getLocales() + "</td></tr>");
+        out.println("<tr><td>Method:</td><td>" + request.getMethod() + "</td></tr>");
+        out.println("<tr><td>Parameter Map:</td><td>" + request.getParameterMap() + "</td></tr>");
+        out.println("<tr><td>Parameter Names:</td><td>" + request.getParameterNames() + "</td></tr>");
+        out.println("<tr><td>Parts:</td><td>" + request.getParts() + "</td></tr>");
+        out.println("<tr><td>Path Info:</td><td>" + request.getPathInfo() + "</td></tr>");
+        out.println("<tr><td>Path Translated:</td><td>" + request.getPathTranslated() + "</td></tr>");
+        out.println("<tr><td>Protocol:</td><td>" + request.getProtocol() + "</td></tr>");
+        out.println("<tr><td>Query String:</td><td>" + request.getQueryString() + "</td></tr>");
+        out.println("<tr><td>Remote Address:</td><td>" + request.getRemoteAddr() + "</td></tr>");
+        out.println("<tr><td>Remote Host:</td><td>" + request.getRemoteHost() + "</td></tr>");
+        out.println("<tr><td>Remote Port:</td><td>" + request.getRemotePort() + "</td></tr>");
+        out.println("<tr><td>Remote User:</td><td>" + request.getRemoteUser() + "</td></tr>");
+        out.println("<tr><td>Request URI:</td><td>" + request.getRequestURI() + "</td></tr>");
+        out.println("<tr><td>Request URL:</td><td>" + request.getRequestURL() + "</td></tr>");
+        out.println("<tr><td>Requested Session Id:</td><td>" + request.getRequestedSessionId() + "</td></tr>");
+        out.println("<tr><td>Scheme:</td><td>" + request.getScheme() + "</td></tr>");
+        out.println("<tr><td>Server Name:</td><td>" + request.getServerName() + "</td></tr>");
+        out.println("<tr><td>Server Port:</td><td>" + request.getServerPort() + "</td></tr>");
+        out.println("<tr><td>Servlet Context:</td><td>" + request.getServletContext() + "</td></tr>");
+        out.println("<tr><td>Servlet Path:</td><td>" + request.getServletPath() + "</td></tr>");
+        out.println("<tr><td>Session:</td><td>" + request.getSession() + "</td></tr>");
+        out.println("<tr><td>User Principal:</td><td>" + request.getUserPrincipal() + "</td></tr>");
+        out.println("<tr><td>Is Async Started:</td><td>" + request.isAsyncStarted() + "</td></tr>");
+        out.println("<tr><td>Is Async Supported:</td><td>" + request.isAsyncSupported() + "</td></tr>");
+        out.println("<tr><td>Is Requested Session Id From Cookie:</td><td>" + request.isRequestedSessionIdFromCookie() + "</td></tr>");
+        out.println("<tr><td>Is Requested Session Id From URL:</td><td>" + request.isRequestedSessionIdFromURL() + "</td></tr>");
+        out.println("<tr><td>Is Secure:</td><td>" + request.isSecure() + "</td></tr>");
+        out.println("</table>");
+        out.println("<b>Attributes</b>");
+        Enumeration<String> attributeNames = request.getAttributeNames();
+        out.println("<table>");
+        while (attributeNames.hasMoreElements()) {
+            String name = attributeNames.nextElement();
+            out.println("<tr><td>" + name + "</td><td>" + request.getAttribute(name) + "</td></tr>");
+        }
+        out.println("</table>");
+        out.println("<b>Cookies</b>");
+        Cookie[] cookies = request.getCookies();
+        if (cookies != null) {
+            out.println("<table>");
+            for (Cookie cookie : cookies) {
+                out.println("<tr><td>" + cookie.getName() + "</td><td>" + cookie.getValue() + "</td></tr>");
+            }
+            out.println("</table>");
+        }
+        out.println("<b>Headers</b>");
+        Enumeration<String> headerNames = request.getHeaderNames();
+        out.println("<table>");
+        while (headerNames.hasMoreElements()) {
+            String name = headerNames.nextElement();
+            out.println("<tr><td>" + name + "</td><td>" + request.getHeader(name) + "</td></tr>");
+        }
+        out.println("</table>");
+        out.println("<b>Locales</b>");
+        Enumeration<Locale> locales = request.getLocales();
+        out.println("<table>");
+        while (locales.hasMoreElements()) {
+            Locale locale = locales.nextElement();
+            out.println("<tr><td>" + locale + "</td></tr>");
+        }
+        out.println("<b>Parameters</b>");
+        Enumeration<String> parameterNames = request.getParameterNames();
+        out.println("<table>");
+        while (parameterNames.hasMoreElements()) {
+            String name = parameterNames.nextElement();
+            out.println("<tr><td>" + name + "</td><td>" + Arrays.toString(request.getParameterValues(name)) + "</td></tr>");
+        }
+        out.println("</table>");
+        Enumeration<String> initParameterNames = getServletConfig().getInitParameterNames();
+        out.println("<b>Servlet Config</b>");
+        out.println("Init Parameters</b>");
+        out.println("<table>");
+        while (initParameterNames.hasMoreElements()) {
+            String name = initParameterNames.nextElement();
+            out.println("<tr><td>" + name + "</td><td>" + getServletConfig().getInitParameter(name) + "</td></tr>");
+        }
+        out.println("Servlet context: " + getServletConfig().getServletContext());
+        out.println("Servlet name: " + getServletConfig().getServletName());
+        out.println("</body>");
+        out.println("</html>");
+    }
+
+    /**
+     * Handles the GET request.
+     *
+     * @param request the servlet request.
+     * @param response the servlet response.
+     * @throws IOException when an I/O error occurs
+     * @throws ServletException when a servlet error occurs
+     */
+    @Override
+    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        processRequest(request, response);
+    }
+
+    /**
+     * Handles the POST request.
+     *
+     * @param request the servlet request.
+     * @param response the servlet response.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a servlet error occurs.
+     */
+    @Override
+    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        processRequest(request, response);
+    }
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestWebApplicationRequest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestWebApplicationRequest.java
new file mode 100644
index 00000000..024d2c3c
--- /dev/null
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestWebApplicationRequest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.impl;
+
+/**
+ * A test WebApplicationRequest.
+ *
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestWebApplicationRequest extends DefaultWebApplicationRequest {
+
+}
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestWebApplicationResponse.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestWebApplicationResponse.java
similarity index 95%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestWebApplicationResponse.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestWebApplicationResponse.java
index 114ee967..0ae08249 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/TestWebApplicationResponse.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/TestWebApplicationResponse.java
@@ -25,9 +25,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
-import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
 import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
 import java.io.ByteArrayOutputStream;
 
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/WebXmlManagerTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/WebXmlManagerTest.java
similarity index 98%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/WebXmlManagerTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/WebXmlManagerTest.java
index 612da391..7fa8890f 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/WebXmlManagerTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/WebXmlManagerTest.java
@@ -1,6 +1,5 @@
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
-import cloud.piranha.webapp.impl.WebXml;
 import org.junit.jupiter.api.Test;
 
 import java.util.Arrays;
@@ -9,7 +8,6 @@ import java.util.List;
 import java.util.stream.Collectors;
 
 import static cloud.piranha.webapp.impl.WebXml.OTHERS_TAG;
-import cloud.piranha.webapp.impl.WebXmlManager;
 import static org.junit.jupiter.api.Assertions.*;
 
 class WebXmlManagerTest {
diff --git a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/WelcomeFileTest.java b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/WelcomeFileTest.java
similarity index 93%
rename from webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/WelcomeFileTest.java
rename to webapp/impl/src/test/java/cloud/piranha/webapp/impl/WelcomeFileTest.java
index 237d102f..3ab3823a 100644
--- a/webapp/impl/src/test/java/cloud/piranha/webapp/impl/tests/WelcomeFileTest.java
+++ b/webapp/impl/src/test/java/cloud/piranha/webapp/impl/WelcomeFileTest.java
@@ -25,13 +25,9 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.impl.tests;
+package cloud.piranha.webapp.impl;
 
 import cloud.piranha.resource.DirectoryResource;
-import cloud.piranha.webapp.impl.DefaultServlet;
-import cloud.piranha.webapp.impl.DefaultWebApplication;
-import cloud.piranha.webapp.impl.DefaultWebApplicationRequest;
-import cloud.piranha.webapp.impl.DefaultWebApplicationResponse;
 import org.junit.jupiter.api.Test;
 
 import java.io.ByteArrayOutputStream;
diff --git a/webapp/scinitializer/pom.xml b/webapp/scinitializer/pom.xml
index 498ac191..1c577f9e 100644
--- a/webapp/scinitializer/pom.xml
+++ b/webapp/scinitializer/pom.xml
@@ -15,8 +15,8 @@
 
     <dependencies>
         <dependency>
-            <groupId>cloud.piranha.servlet</groupId>
-            <artifactId>piranha-servlet-api</artifactId>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
             <version>${project.version}</version>
             <scope>provided</scope>
         </dependency>
diff --git a/webapp/scinitializer/src/main/java/cloud/piranha/webapp/scinitializer/ServletContainerInitializerExtension.java b/webapp/scinitializer/src/main/java/cloud/piranha/webapp/scinitializer/ServletContainerInitializerExtension.java
index e1f77bb7..bbb290df 100644
--- a/webapp/scinitializer/src/main/java/cloud/piranha/webapp/scinitializer/ServletContainerInitializerExtension.java
+++ b/webapp/scinitializer/src/main/java/cloud/piranha/webapp/scinitializer/ServletContainerInitializerExtension.java
@@ -36,7 +36,7 @@ import java.util.List;
 import java.util.ServiceLoader;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.api.WebApplicationExtension;
diff --git a/webapp/scinitializer/src/main/java/module-info.java b/webapp/scinitializer/src/main/java/module-info.java
index d1e02e44..8f5876fb 100644
--- a/webapp/scinitializer/src/main/java/module-info.java
+++ b/webapp/scinitializer/src/main/java/module-info.java
@@ -26,13 +26,16 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-module cloud.piranha.webapp.scinitializer {
-    
-    exports cloud.piranha.webapp.scinitializer;
+import javax.servlet.ServletContainerInitializer;
 
-    opens cloud.piranha.webapp.scinitializer;
-
-    requires cloud.piranha.servlet.api;
+module cloud.piranha.webapp.scinitializer {
+    requires cloud.piranha.servlet4.api;
     requires cloud.piranha.webapp.api;
+
     requires java.logging;
+
+    uses ServletContainerInitializer;
+
+    exports cloud.piranha.webapp.scinitializer;
+    opens cloud.piranha.webapp.scinitializer;
 }
diff --git a/webapp/tempdir/pom.xml b/webapp/tempdir/pom.xml
index 16eb403b..aa2b16e2 100644
--- a/webapp/tempdir/pom.xml
+++ b/webapp/tempdir/pom.xml
@@ -15,8 +15,8 @@
 
     <dependencies>
         <dependency>
-            <groupId>cloud.piranha.servlet</groupId>
-            <artifactId>piranha-servlet-api</artifactId>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
             <version>${project.version}</version>
             <scope>provided</scope>
         </dependency>
diff --git a/webapp/tempdir/src/main/java/cloud/piranha/webapp/tempdir/TempDirExtension.java b/webapp/tempdir/src/main/java/cloud/piranha/webapp/tempdir/TempDirExtension.java
index 992a5eee..47c596ef 100644
--- a/webapp/tempdir/src/main/java/cloud/piranha/webapp/tempdir/TempDirExtension.java
+++ b/webapp/tempdir/src/main/java/cloud/piranha/webapp/tempdir/TempDirExtension.java
@@ -31,7 +31,7 @@ import java.lang.reflect.InvocationTargetException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.api.WebApplicationExtension;
diff --git a/webapp/tempdir/src/main/java/cloud/piranha/webapp/tempdir/TempDirInitializer.java b/webapp/tempdir/src/main/java/cloud/piranha/webapp/tempdir/TempDirInitializer.java
index 79e804c1..30628089 100644
--- a/webapp/tempdir/src/main/java/cloud/piranha/webapp/tempdir/TempDirInitializer.java
+++ b/webapp/tempdir/src/main/java/cloud/piranha/webapp/tempdir/TempDirInitializer.java
@@ -28,15 +28,15 @@
 package cloud.piranha.webapp.tempdir;
 
 import static java.util.logging.Level.FINE;
-import static jakarta.servlet.ServletContext.TEMPDIR;
+import static javax.servlet.ServletContext.TEMPDIR;
 
 import java.io.File;
 import java.util.Set;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 /**
  * The ServletContext temporary directory initializer.
diff --git a/webapp/tempdir/src/main/java/module-info.java b/webapp/tempdir/src/main/java/module-info.java
index 96cb4af6..439c7b01 100644
--- a/webapp/tempdir/src/main/java/module-info.java
+++ b/webapp/tempdir/src/main/java/module-info.java
@@ -27,12 +27,11 @@
  */
 
 module cloud.piranha.webapp.tempdir {
-    
-    exports cloud.piranha.webapp.tempdir;
-
-    opens cloud.piranha.webapp.tempdir;
-
-    requires cloud.piranha.servlet.api;
+    requires cloud.piranha.servlet4.api;
     requires cloud.piranha.webapp.api;
+
     requires java.logging;
+
+    exports cloud.piranha.webapp.tempdir;
+    opens cloud.piranha.webapp.tempdir;
 }
diff --git a/webapp/webannotation/pom.xml b/webapp/webannotation/pom.xml
index 905f3cf2..d831cc39 100644
--- a/webapp/webannotation/pom.xml
+++ b/webapp/webannotation/pom.xml
@@ -12,12 +12,12 @@
     <artifactId>piranha-webapp-webannotation</artifactId>
     <packaging>jar</packaging>
 
-    <name>Piranha Webapplication - Web Annotation Integration</name>
+    <name>Piranha Webapplication - @WebServlet</name>
 
     <dependencies>
         <dependency>
-            <groupId>cloud.piranha.servlet</groupId>
-            <artifactId>piranha-servlet-api</artifactId>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
             <version>${project.version}</version>
             <scope>provided</scope>
         </dependency>
diff --git a/webapp/webannotation/src/main/java/cloud/piranha/webapp/webannotation/WebAnnotationExtension.java b/webapp/webannotation/src/main/java/cloud/piranha/webapp/webannotation/WebAnnotationExtension.java
index fa1b3225..0d6b0bb8 100644
--- a/webapp/webannotation/src/main/java/cloud/piranha/webapp/webannotation/WebAnnotationExtension.java
+++ b/webapp/webannotation/src/main/java/cloud/piranha/webapp/webannotation/WebAnnotationExtension.java
@@ -31,7 +31,7 @@ import java.lang.reflect.InvocationTargetException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.api.WebApplicationExtension;
diff --git a/webapp/webannotation/src/main/java/cloud/piranha/webapp/webannotation/WebAnnotationInitializer.java b/webapp/webannotation/src/main/java/cloud/piranha/webapp/webannotation/WebAnnotationInitializer.java
index 4ffd956c..10e9a38a 100644
--- a/webapp/webannotation/src/main/java/cloud/piranha/webapp/webannotation/WebAnnotationInitializer.java
+++ b/webapp/webannotation/src/main/java/cloud/piranha/webapp/webannotation/WebAnnotationInitializer.java
@@ -42,17 +42,17 @@ import java.util.logging.Logger;
 
 import javax.annotation.security.DeclareRoles;
 import javax.annotation.security.RolesAllowed;
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
-import jakarta.servlet.ServletRegistration.Dynamic;
-import jakarta.servlet.annotation.ServletSecurity;
-import jakarta.servlet.annotation.WebFilter;
-import jakarta.servlet.annotation.WebListener;
-import jakarta.servlet.annotation.WebServlet;
-import jakarta.servlet.http.HttpServlet;
+import javax.servlet.DispatcherType;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration.Dynamic;
+import javax.servlet.annotation.ServletSecurity;
+import javax.servlet.annotation.WebFilter;
+import javax.servlet.annotation.WebListener;
+import javax.servlet.annotation.WebServlet;
+import javax.servlet.http.HttpServlet;
 
 import cloud.piranha.webapp.api.AnnotationManager;
 import cloud.piranha.webapp.api.AnnotationManager.AnnotationInfo;
diff --git a/webapp/webannotation/src/main/java/module-info.java b/webapp/webannotation/src/main/java/module-info.java
index 497fc504..6cf576bf 100644
--- a/webapp/webannotation/src/main/java/module-info.java
+++ b/webapp/webannotation/src/main/java/module-info.java
@@ -27,13 +27,11 @@
  */
 
 module cloud.piranha.webapp.webannotation {
-    
-    exports cloud.piranha.webapp.webannotation;
-
-    opens cloud.piranha.webapp.webannotation;
-    
-    requires cloud.piranha.servlet.api;
+    requires cloud.piranha.servlet4.api;
     requires cloud.piranha.webapp.api;
+
     requires java.annotation;
     requires java.logging;
+
+    exports cloud.piranha.webapp.webannotation;
 }
diff --git a/webapp/webxml/pom.xml b/webapp/webxml/pom.xml
index 9eed0823..f89cbe9e 100644
--- a/webapp/webxml/pom.xml
+++ b/webapp/webxml/pom.xml
@@ -22,8 +22,8 @@
             <scope>provided</scope>
         </dependency>
         <dependency>
-            <groupId>cloud.piranha.servlet</groupId>
-            <artifactId>piranha-servlet-api</artifactId>
+            <groupId>cloud.piranha.servlet4</groupId>
+            <artifactId>piranha-servlet4-api</artifactId>
             <version>${project.version}</version>
             <scope>provided</scope>
         </dependency>
diff --git a/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlExtension.java b/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlExtension.java
index d9670783..337a5ba5 100644
--- a/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlExtension.java
+++ b/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlExtension.java
@@ -31,7 +31,7 @@ import java.lang.reflect.InvocationTargetException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContainerInitializer;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.api.WebApplicationExtension;
diff --git a/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlInitializer.java b/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlInitializer.java
index b6230b8a..e33c02a4 100644
--- a/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlInitializer.java
+++ b/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlInitializer.java
@@ -39,9 +39,9 @@ import java.util.List;
 import java.util.Set;
 import java.util.logging.Logger;
 
-import jakarta.servlet.ServletContainerInitializer;
-import jakarta.servlet.ServletContext;
-import jakarta.servlet.ServletException;
+import javax.servlet.ServletContainerInitializer;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 
 import cloud.piranha.webapp.api.WebApplication;
 import cloud.piranha.webapp.impl.WebXml;
diff --git a/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlProcessor.java b/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlProcessor.java
index bdd565e9..9c69ab57 100644
--- a/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlProcessor.java
+++ b/webapp/webxml/src/main/java/cloud/piranha/webapp/webxml/WebXmlProcessor.java
@@ -37,9 +37,9 @@ import java.util.Map;
 import java.util.Set;
 import java.util.logging.Logger;
 
-import jakarta.servlet.DispatcherType;
-import jakarta.servlet.FilterRegistration;
-import jakarta.servlet.ServletRegistration;
+import javax.servlet.DispatcherType;
+import javax.servlet.FilterRegistration;
+import javax.servlet.ServletRegistration;
 
 import cloud.piranha.webapp.api.LocaleEncodingManager;
 import cloud.piranha.webapp.api.WebApplication;
diff --git a/webapp/webxml/src/main/java/module-info.java b/webapp/webxml/src/main/java/module-info.java
index e47f5125..98f15e9d 100644
--- a/webapp/webxml/src/main/java/module-info.java
+++ b/webapp/webxml/src/main/java/module-info.java
@@ -27,14 +27,16 @@
  */
 
 module cloud.piranha.webapp.webxml {
-    
-    exports cloud.piranha.webapp.webxml;
-
-    opens cloud.piranha.webapp.webxml;
-
-    requires cloud.piranha.servlet.api;
+    requires cloud.piranha.servlet4.api;
     requires cloud.piranha.webapp.api;
     requires cloud.piranha.webapp.impl;
+
     requires java.logging;
     requires java.xml;
+
+    exports cloud.piranha.webapp.webxml;
+    opens cloud.piranha.webapp.webxml;
+
+    // Tests
+    requires static cloud.piranha.resource;
 }
diff --git a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/TestFilter.java b/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/TestFilter.java
new file mode 100644
index 00000000..e5da2a5d
--- /dev/null
+++ b/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/TestFilter.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.webxml;
+
+import java.io.IOException;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+
+/**
+ * A test filter
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestFilter implements Filter {
+    
+    /**
+     * Filter processing.
+     * 
+     * @param request the request.
+     * @param response the response.
+     * @param chain the chain.
+     * @throws IOException when an I/O error occurs.
+     * @throws ServletException when a Servlet error occurs.
+     */
+    @Override
+    public void doFilter(ServletRequest request, ServletResponse response, 
+            FilterChain chain) throws IOException, ServletException {
+    }
+}
diff --git a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/TestServlet.java b/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/TestServlet.java
new file mode 100644
index 00000000..5e827bc4
--- /dev/null
+++ b/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/TestServlet.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2002-2020 Manorrock.com. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, 
+ *      this list of conditions and the following disclaimer.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the name of the copyright holder nor the names of its 
+ *      contributors may be used to endorse or promote products derived from
+ *      this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package cloud.piranha.webapp.webxml;
+
+import javax.servlet.http.HttpServlet;
+
+/**
+ * A test servlet
+ * 
+ * @author Manfred Riem (mriem@manorrock.com)
+ */
+public class TestServlet extends HttpServlet {
+}
diff --git a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/WebXmlInitializerTest.java b/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/WebXmlInitializerTest.java
similarity index 96%
rename from webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/WebXmlInitializerTest.java
rename to webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/WebXmlInitializerTest.java
index 1df12b98..11cf6af0 100644
--- a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/WebXmlInitializerTest.java
+++ b/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/WebXmlInitializerTest.java
@@ -25,14 +25,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.webxml.tests;
+package cloud.piranha.webapp.webxml;
 
 import cloud.piranha.resource.DirectoryResource;
 import cloud.piranha.webapp.impl.DefaultWebApplication;
 import cloud.piranha.webapp.impl.DefaultWebApplicationClassLoader;
-import cloud.piranha.webapp.webxml.WebXmlInitializer;
 import java.io.File;
-import jakarta.servlet.ServletRegistration;
+import javax.servlet.ServletRegistration;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
diff --git a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/WebXmlParserTest.java b/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/WebXmlParserTest.java
similarity index 98%
rename from webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/WebXmlParserTest.java
rename to webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/WebXmlParserTest.java
index fda5e67a..9440a526 100644
--- a/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/tests/WebXmlParserTest.java
+++ b/webapp/webxml/src/test/java/cloud/piranha/webapp/webxml/WebXmlParserTest.java
@@ -25,7 +25,7 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-package cloud.piranha.webapp.webxml.tests;
+package cloud.piranha.webapp.webxml;
 
 import cloud.piranha.resource.DirectoryResource;
 import cloud.piranha.webapp.impl.DefaultWebApplication;
@@ -40,7 +40,6 @@ import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import cloud.piranha.webapp.impl.WebXmlServletMapping;
-import cloud.piranha.webapp.webxml.WebXmlParser;
 import org.junit.jupiter.api.Test;
 
 /**
diff --git a/webapp/webxml/src/test/webxml/init/WEB-INF/web.xml b/webapp/webxml/src/test/webxml/init/WEB-INF/web.xml
index 76ee18e8..af4f968f 100644
--- a/webapp/webxml/src/test/webxml/init/WEB-INF/web.xml
+++ b/webapp/webxml/src/test/webxml/init/WEB-INF/web.xml
@@ -11,7 +11,7 @@
     </context-param>
     <servlet>
         <servlet-name>Test Servlet</servlet-name>
-        <servlet-class>cloud.piranha.webapp.webxml.TestServlet</servlet-class>
+        <servlet-class>cloud.piranha.servlet4.webxml.TestServlet</servlet-class>
         <load-on-startup>1</load-on-startup>
     </servlet>
     <servlet-mapping>
diff --git a/webapp/webxml/src/test/webxml/parse/WEB-INF/web.xml b/webapp/webxml/src/test/webxml/parse/WEB-INF/web.xml
index c00264cc..46113c25 100644
--- a/webapp/webxml/src/test/webxml/parse/WEB-INF/web.xml
+++ b/webapp/webxml/src/test/webxml/parse/WEB-INF/web.xml
@@ -12,17 +12,17 @@
     </context-param>
     <filter>
         <filter-name>>Test Filter</filter-name>
-        <filter-class>cloud.piranha.webapp.webxml.TestFilter</filter-class>
+        <filter-class>cloud.piranha.servlet4.webxml.TestFilter</filter-class>
     </filter>
     <servlet>
         <servlet-name>Test Servlet</servlet-name>
-        <servlet-class>cloud.piranha.webapp.webxml.TestServlet</servlet-class>
+        <servlet-class>cloud.piranha.servlet4.webxml.TestServlet</servlet-class>
         <load-on-startup>1</load-on-startup>
         <async-supported>true</async-supported>
     </servlet>    
     <servlet>
         <servlet-name>Test Servlet 2</servlet-name>
-        <servlet-class>cloud.piranha.webapp.webxml.TestServlet</servlet-class>
+        <servlet-class>cloud.piranha.servlet4.webxml.TestServlet</servlet-class>
         <async-supported>false</async-supported>
     </servlet>
     <servlet-mapping>
diff --git a/webapp/webxml/src/test/webxml/parse4/WEB-INF/web.xml b/webapp/webxml/src/test/webxml/parse4/WEB-INF/web.xml
index 32040559..fce026cc 100644
--- a/webapp/webxml/src/test/webxml/parse4/WEB-INF/web.xml
+++ b/webapp/webxml/src/test/webxml/parse4/WEB-INF/web.xml
@@ -3,7 +3,7 @@
 <web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">
     <servlet>
         <servlet-name>Test Servlet</servlet-name>
-        <servlet-class>cloud.piranha.webapp.webxml.TestServlet</servlet-class>
+        <servlet-class>cloud.piranha.servlet4.webxml.TestServlet</servlet-class>
     </servlet>
     <servlet-mapping>
         <servlet-name>Test Servlet</servlet-name>
